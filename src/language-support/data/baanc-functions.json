{
  "cmf.addaddressentry": {
    "name": "cmf.addAddressEntry",
    "type": "function",
    "syntax": "function long cmf.addaddressentry (long aid, string role, string name, string address, string addresstype [, domain ttcmf.catg key] [, domain ttcmf.catg category])",
    "description": "Creates an address child node in the address list aid. The attributes of the node are provided by the parameters of the function.",
    "arguments": [
      {
        "type": "long",
        "name": "aid",
        "description": "Identification of the address list."
      },
      {
        "type": "string",
        "name": "role",
        "description": ""
      },
      {
        "type": "string",
        "name": "name",
        "description": "Recipient name"
      },
      {
        "type": "string",
        "name": "address",
        "description": "Recipient address"
      },
      {
        "type": "string",
        "name": "addresstype",
        "description": "Recipient type of address (fax, telex, smtp and so on.)"
      },
      {
        "type": "domain ttcmf.catg",
        "name": "key",
        "description": "The key and the category of the recipient (that make a primary key) to easily find the address entry of this recipient in the address book."
      },
      {
        "type": "domain ttcmf.catg",
        "name": "category",
        "description": ""
      }
    ],
    "returnValue": "<>0 Object id of addresslist entry. =0 Error creating entry (most likely invalid address list id).",
    "category": "emessage_connector"
  },
  "cmf.addobjecttomessage": {
    "name": "cmf.addObjectToMessage",
    "type": "function",
    "syntax": "function long cmf.addobjecttomessage (long oid, long mid, string class(100))",
    "description": "The object identified by oid is added to the message object identified by mid . The class of this message is set to the string class (mandatory attribute for a message: for example CMF.TASK for tasks, CMF.APPOINTMENT for appointments and so on). The object is written to a temporary file with extension .xml, which is placed in the current working directory. This file is added as an attachment to the message object. The body attribute of this attachment is set to true, the mimetype is set to application/xml and the delete attribute is set to true. All attachments currently attached to the task are also attached to the message object. Finally the object identified by oid is deleted (because changes in this object are not reflected anymore in the message object).",
    "arguments": [
      {
        "type": "long",
        "name": "oid",
        "description": "Object identification."
      },
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "class(100)",
        "description": "Mandatory attribute for a message: for example CMF.TASK for tasks, CMF.APPOINTMENT for appointments and so on. For more information see cmf.setClasscmf.setClass ."
      }
    ],
    "returnValue": "0 Success. -1 General error (check logfiles) . -2 Oid or mid are not valid xml object id's. -3 Class argument empty. -4 Object could not be written to file.",
    "category": "emessage_connector"
  },
  "cmf.copyattachment": {
    "name": "cmf.copyAttachment",
    "type": "function",
    "syntax": "function long cmf.copyattachment (long attachment.id, long oid)",
    "description": "Copies the attachment identified by attachment.id from the object identified by id1 to the object identified by id2. All attributes and their values are also copied",
    "arguments": [
      {
        "type": "long",
        "name": "attachment.id",
        "description": "Identification of the source attachment."
      },
      {
        "type": "long",
        "name": "oid",
        "description": "Identification of the destination attachment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.create": {
    "name": "cmf.create",
    "type": "function",
    "syntax": "function long cmf.create ()",
    "description": "Creates a new Infor ERP Enterprise eMessage Connector message object.",
    "arguments": [],
    "returnValue": "<>0 (Bshell wide) unique Infor ERP Enterprise eMessage Connector message object id. 0 Message object creation error.",
    "category": "emessage_connector"
  },
  "cmf.createaddresslist": {
    "name": "cmf.createAddressList",
    "type": "function",
    "syntax": "function long cmf.createaddresslist ()",
    "description": "Creates an address list object.",
    "arguments": [],
    "returnValue": "<> 0 Id of root-element of address list. =0 Error creating object",
    "category": "emessage_connector"
  },
  "cmf.createappointment": {
    "name": "cmf.createAppointment",
    "type": "function",
    "syntax": "function long cmf.createappointment ( [long mid])",
    "description": "Creates a new Infor ERP Enterprise eMessage Connector appointment object.",
    "arguments": [
      {
        "type": "[long",
        "name": "mid ]",
        "description": "Use these optional arguments to pass a message object identification to which this new appointment object will be attached. When this argument is omitted, the function cmf.addObjectToMessage() must be used to attach an appointment object to a message object."
      }
    ],
    "returnValue": "<>0 (Bshell wide) unique Infor ERP Enterprise eMessage Connector appointment object id. =0 Appointment object creation error.",
    "category": "emessage_connector"
  },
  "cmf.createattachment": {
    "name": "cmf.createAttachment",
    "type": "function",
    "syntax": "function long cmf.createattachment (long mid)",
    "description": "Creates an attachment entry in the message identified by mid and returns the identification of the attachment.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      }
    ],
    "returnValue": "<>0 Attachment Identification. =0 Attachment could not be created (most likely invalid cmf object).",
    "category": "emessage_connector"
  },
  "cmf.createrecipient": {
    "name": "cmf.createRecipient",
    "type": "function",
    "syntax": "function long cmf.createrecipient (long mid, enum role)",
    "description": "Creates a recipient entry of type role in the message identified by mid and returns the identification of the recipient object.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "enum",
        "name": "role",
        "description": "The recipient's role: �FROM� | �TO� | �CC� | �BCC� | �OBO� | �NOTIFY�"
      }
    ],
    "returnValue": "<>0 Recipient Id. =0 Invalid object id.",
    "category": "emessage_connector"
  },
  "cmf.createtask": {
    "name": "cmf.createTask",
    "type": "function",
    "syntax": "function long cmf.createtask ()",
    "description": "Creates a new Infor ERP Enterprise eMessage Connector task object.",
    "arguments": [],
    "returnValue": "<>0 (Bshell wide) unique Infor ERP Enterprise eMessage Connector task object id. =0 Task object creation error.",
    "category": "emessage_connector"
  },
  "cmf.destroy": {
    "name": "cmf.destroy",
    "type": "function",
    "syntax": "function long cmf.destroy (long mid)",
    "description": "Destroys the Infor ERP Enterprise eMessage Connector (message) object identified by id. This function can also be used to destroy recipient objects, attachment objects, etc.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.enableservice": {
    "name": "cmf.enableService",
    "type": "function",
    "syntax": "function long cmf.enableservice (domain ttcmf.prov service, long enable)",
    "description": "Checks in the Services (ttcmf030) table if service is enabled (ttcmf030.enab = yes) or not. If not, and enable is true, then service is enabled. If yes, and enable is false, then service is disabled. In the other (two) cases nothing happens.",
    "arguments": [
      {
        "type": "domain ttcmf.prov",
        "name": "service",
        "description": "The service identification."
      },
      {
        "type": "long",
        "name": "enable",
        "description": ""
      }
    ],
    "returnValue": "2 service is enabled. 1 service is disabled. 0 nothing changed. -1 service not found in table Services (ttcmf030).",
    "category": "emessage_connector"
  },
  "cmf.getaddressbookkey": {
    "name": "cmf.getAddressBookKey",
    "type": "function",
    "syntax": "function long cmf.getaddressbookkey (long entry.id, ref string key, ref string category)",
    "description": "Gets the two key fields of the Address Book (ttcmf200) of the recipient identified by entry.id and returns them in the strings key and category.",
    "arguments": [
      {
        "type": "long",
        "name": "entry.id",
        "description": "The address list entry identification."
      },
      {
        "type": "ref string",
        "name": "key",
        "description": "The recipient key."
      },
      {
        "type": "ref string",
        "name": "category",
        "description": "The recipient category."
      }
    ],
    "returnValue": "0 Success. -1 Error retrieving category and key: probably invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getaddressdetails": {
    "name": "cmf.getAddressDetails",
    "type": "function",
    "syntax": "function long cmf.getaddressdetails (long entry_id, ref string category, ref string key, ref string role, ref string name, ref string address, ref string addresstype, ref long errorcode)",
    "description": "Retrieves the details of an address entry specified by entry_id. Entry_id is obtained from the function cmf.getNextAddress() or cmf.addAddressEntry() . The attribute values for the object identified by entry_id are copied to the appropriate parameter variables.",
    "arguments": [
      {
        "type": "long",
        "name": "entry_id",
        "description": "The address list entry identification."
      },
      {
        "type": "ref string",
        "name": "category",
        "description": "The recipient category."
      },
      {
        "type": "ref string",
        "name": "key",
        "description": "The recipient key."
      },
      {
        "type": "ref string",
        "name": "role",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "name",
        "description": "The recipient name."
      },
      {
        "type": "ref string",
        "name": "address",
        "description": "The recipient address."
      },
      {
        "type": "ref string",
        "name": "addresstype",
        "description": "The recipient addresstype."
      },
      {
        "type": "ref long",
        "name": "errorcode",
        "description": "See cmf.updateAddressStatus()cmf.updateAddressStatus for the error codes."
      }
    ],
    "returnValue": "0 Success. -1 Error retrieving details (most probably invalid address entry id).",
    "category": "emessage_connector"
  },
  "cmf.getappointmentalarm": {
    "name": "cmf.getAppointmentAlarm",
    "type": "function",
    "syntax": "function long cmf.getappointmentalarm (long apid, ref domain ttutc alarm)",
    "description": "Gets the alarm of the appointment identified by apid and returns it in the utc date alarm.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "alarm",
        "description": "The alarm time for the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentalldayevent": {
    "name": "cmf.getAppointmentAlldayevent",
    "type": "function",
    "syntax": "function long cmf.getappointmentalldayevent (long apid, ref enum alldayevent)",
    "description": "Gets the alldayevent flag of the appointment identified by apid and returns it in the string alldayevent.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref enum",
        "name": "alldayevent",
        "description": "All day event appointment: \"YES\" | \"NO\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentbusystatus": {
    "name": "cmf.getAppointmentBusystatus",
    "type": "function",
    "syntax": "function long cmf.getappointmentbusystatus (long apid, ref string busystatus)",
    "description": "Gets the busystatus of the appointment identified by apid and return string into busystatus.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref string",
        "name": "busystatus",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getappointmentdescription": {
    "name": "cmf.getAppointmentDescription",
    "type": "function",
    "syntax": "function long cmf.getAppointmentDescription (long apid, ref string description)",
    "description": "Get the value of the description text of the appointment identified by apid and returns it in description.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref string",
        "name": "description",
        "description": "The description text of the appointment"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentendtime": {
    "name": "cmf.getAppointmentEndtime",
    "type": "function",
    "syntax": "function long cmf.getappointmentendtime (long apid, ref domain ttutc endtime)",
    "description": "Gets the endtime of the appointment identified by apid and returns it in the utc date endtime.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "endtime",
        "description": "The end time of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentlocation": {
    "name": "cmf.getAppointmentLocation",
    "type": "function",
    "syntax": "function long cmf.getappointmentlocation (long apid, ref string location)",
    "description": "Gets the appointment location of the appointment identified by apid and return string into location.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref string",
        "name": "location",
        "description": "The location of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getappointmentmeeting": {
    "name": "cmf.getAppointmentMeeting",
    "type": "function",
    "syntax": "function long cmf.getAppointmentMeeting (long apid, ref enum meeting)",
    "description": "Gets the meeting flag of the appointment identified by apid and returns it in the string meeting.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref enum",
        "name": "meeting",
        "description": "Appointment meeting: \"YES\" | \"NO\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentmethod": {
    "name": "cmf.getAppointmentMethod",
    "type": "function",
    "syntax": "function long cmf.getAppointmentMethod (long apid, ref domain ttcmf.mth method)",
    "description": "Get the value of the METHOD attribute of the appointment identified by apid and returns it in method.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref domain ttcmf.mth",
        "name": "method",
        "description": "The method value"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentstarttime": {
    "name": "cmf.getAppointmentStarttime",
    "type": "function",
    "syntax": "function long cmf.getappointmentstarttime (long apid, ref domain ttutc starttime)",
    "description": "Gets the starttime of the appointment identified by apid and returns it in the utc date starttime.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "starttime",
        "description": "The start time of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.getappointmentsubject": {
    "name": "cmf.getAppointmentSubject",
    "type": "function",
    "syntax": "function long cmf.getappointmentsubject (long apid, ref string subject)",
    "description": "Gets the appointment subject of the appointment identified by apid and returns string into subject.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref string",
        "name": "subject",
        "description": "The subject of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getappointmentuuid": {
    "name": "cmf.getAppointmentUUID",
    "type": "function",
    "syntax": "function long cmf.getAppointmentUUID (long apid, ref string uuid)",
    "description": "Get the value of the UUID attribute of the appointment identified by apid and returns it in uuid.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "ref string",
        "name": "uuid",
        "description": "The unique ID of the appointment"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getattachmentbody": {
    "name": "cmf.getAttachmentBody",
    "type": "function",
    "syntax": "function long cmf.getattachmentbody (long attachment, enum ttyeno body)",
    "description": "Gets the type of the attachment identified by attachment and returns it in the enum body.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "enum ttyeno",
        "name": "body",
        "description": "Is attachment the bodytext: ttyeno.yes | ttyeno.no Only one attachment for each message can be the body."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.getattachmentfilename": {
    "name": "cmf.getAttachmentFilename",
    "type": "function",
    "syntax": "function long cmf.getattachmentfilename (long attachment, string filename, ref string displayname)",
    "description": "Gets the filename and display name of the attachment identified by attachment and return them in the strings&#65533; filename and displayname.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "string",
        "name": "filename",
        "description": "The physical filename."
      },
      {
        "type": "ref string",
        "name": "displayname",
        "description": "The name of the file that is displayed. If displayname is not supplied, then the physical filename is used."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.getattachmentmime": {
    "name": "cmf.getAttachmentMime",
    "type": "function",
    "syntax": "function long cmf.getattachmentmime (long attachment, ref string mime)",
    "description": "Gets the mime type of the attachment identified by attachment and returns it in the string mime.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "ref string",
        "name": "mime",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.getattachmentposition": {
    "name": "cmf.getAttachmentPosition",
    "type": "function",
    "syntax": "function long cmf.getattachmentposition (long attachment, string position(10))",
    "description": "Gets the position of the attachment identified by attachment and returns it in the string position.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "string",
        "name": "position(10)",
        "description": "The attachment position determines the number of characters (of the bodytext) after which the attachment-icon will be placed."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.getcategories": {
    "name": "cmf.getCategories",
    "type": "function",
    "syntax": "function long cmf.getcategories (long mid, ref string categories)",
    "description": "Gets the categories of the message identified by mid and returns string into categories.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "categories",
        "description": "Message category."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getchargecode": {
    "name": "cmf.getChargeCode",
    "type": "function",
    "syntax": "function long cmf.getchargecode (long mid, ref string chargecode)",
    "description": "Gets the message charge code of the message identified by mid and returns string into chargecode.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "chargecode",
        "description": "Message charge code."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getclass": {
    "name": "cmf.getClass",
    "type": "function",
    "syntax": "function long cmf.getclass (long mid, ref string class)",
    "description": "Gets the message class of the message identified by mid and returns string into class.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "class",
        "description": "Mandatory attribute for a message, identifying the meaning of a message: for example CMF.TASK for tasks, CMF.APPOINTMENT for appointments and so on."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getcreatetime": {
    "name": "cmf.getCreateTime",
    "type": "function",
    "syntax": "function long cmf.getcreatetime (long mid, ref domain ttutc createtime)",
    "description": "Gets the message creation time of the message identified by mid and returns it into utc date createtime.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "createtime",
        "description": "UTC date the message was created."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present). -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.getdisplay": {
    "name": "cmf.getDisplay",
    "type": "function",
    "syntax": "function long cmf.getdisplay (long mid, ref enum display)",
    "description": "Gets the display option of this message identified by mid and put it in the variable display .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref enum",
        "name": "display",
        "description": "\"TRUE\": message shows before sending. User interface based service will be started. \"FALSE\": message is send without showing it first. UI-based and non ui-based service(s) can be started"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.getduedate": {
    "name": "cmf.getDueDate",
    "type": "function",
    "syntax": "function long cmf.getduedate (long mid, ref domain ttutc duedate)",
    "description": "Gets the duedate of the message identified by mid and returns it in the utc date duedate.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "duedate",
        "description": "Message duedate time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getexpiry": {
    "name": "cmf.getExpiry",
    "type": "function",
    "syntax": "function long cmf.getexpiry (long mid, ref domain ttutc expiry)",
    "description": "Gets the expiry time of the message identified by mid and returns it in the utc date expiry.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "expiry",
        "description": "Message expiry time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getfollowupflag": {
    "name": "cmf.getFollowupFlag",
    "type": "function",
    "syntax": "function long cmf.getfollowupflag (long mid)",
    "description": "Get the value of the followup flag from the message identified by mid .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      }
    ],
    "returnValue": "true Followup flag was set. false Followup flag was not set or set to FALSE",
    "category": "emessage_connector"
  },
  "cmf.getid": {
    "name": "cmf.getId",
    "type": "function",
    "syntax": "function long cmf.getid (string messageld, string service, domain ttcmf.mdir message.direction, ref string error_string())",
    "description": "Creates a path to the header.xml file, which consists of the message storage path in the Services (ttcmf030) table and inbox or outbox (depending on message direction) and header.xml. This file is opened in read mode and then parsed with function xml.read which returns the bshell-wide unique object ID of the message object, which is often needed to call other functions in this library.",
    "arguments": [
      {
        "type": "string",
        "name": "messageld",
        "description": "Unique identification of a message within Infor ERP Enterprise eMessage Connector."
      },
      {
        "type": "string",
        "name": "service",
        "description": "Service offered by a provider, for example, Fax or Email."
      },
      {
        "type": "domain ttcmf.mdir",
        "name": "message.direction",
        "description": "This is an enumerated field that indicates whether the message was inbound (to the Bshell) or outbound (from the Bshell). This field also indicates whether the message is stored in the inbox or outbox subdirectories of the message storage directory. The possible values are: \"ttcmf.mdir.inbound|ttcmf.mdir.outbound\"."
      },
      {
        "type": "ref string",
        "name": "error_string()",
        "description": "Detailed error information."
      }
    ],
    "returnValue": "<> 0 mid = Bshell-wide unique message ID. =0 mid = no valid object id error_string contains detailed error information.",
    "category": "emessage_connector"
  },
  "cmf.getmessageid": {
    "name": "cmf.getMessageId",
    "type": "function",
    "syntax": "function long cmf.getmessageid (long mid, ref string messageId)",
    "description": "Gets the message id of the message identified by mid and return string into messageId.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "messageId",
        "description": "Unique identification of a message within Infor ERP Enterprise eMessage Connector."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.getnextaddress": {
    "name": "cmf.getNextAddress",
    "type": "function",
    "syntax": "function long cmf.getnextaddress (long aid, long previous)",
    "description": "Retrieves the next address child element in the address list root element identified by aid . If previous is 0 (zero) the id of the first entry on the addresslist is returned with type element. Else, the entry following the entry identified by previous is returned.",
    "arguments": [
      {
        "type": "long",
        "name": "aid",
        "description": "Identification of the address list."
      },
      {
        "type": "long",
        "name": "previous",
        "description": "Index in the address list."
      }
    ],
    "returnValue": "<>0 Id of address list child element. =0 End of child elements reached or invalid address list id supplied.",
    "category": "emessage_connector"
  },
  "cmf.getnextattachment": {
    "name": "cmf.getNextAttachment",
    "type": "function",
    "syntax": "function long cmf.getnextattachment (long mid, long previous)",
    "description": "Gets an attachment entry in the message identified by mid and returns the identification of the attachment. If previous is 0 (no valid object id), then the first attachment is returned. If previous is a valid object id (not 0) then the attachment id of the attachment that follows the attachment identified by previous is returned. Subsequent calls to this function return succeeding attachments. The current attachment pointer can be reset by setting previous to 0 again.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "long",
        "name": "previous",
        "description": "The identification of the attachment. If previous is 0 (no valid object id), then the first attachment is returned. If previous is a valid object id (not 0) then the attachment id of the attachment that follows the attachment identified by previous is returned."
      }
    ],
    "returnValue": "<>0 Attachment Identification. =0 Attachment could not be found (most likely end of attachment list).",
    "category": "emessage_connector"
  },
  "cmf.getnextrecipient": {
    "name": "cmf.getNextRecipient",
    "type": "function",
    "syntax": "function long cmf.getnextrecipient (long mid, ref enum role)",
    "description": "Retrieves the recipient entry in the message identified by the combination of role and the id of the previous recipient listed in the XML document. It returns the id of the recipient object. If previous is 0 (zero), the id of the first recipient listed in the XML document is returned.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref enum",
        "name": "role",
        "description": "The recipient's role: �FROM� | �TO� | �CC� | �BCC� | �OBO� | �NOTIFY�"
      }
    ],
    "returnValue": "<>0 Recipient Id. =0 No (next) recipient found or invalid object id.",
    "category": "emessage_connector"
  },
  "cmf.getnotification": {
    "name": "cmf.getNotification",
    "type": "function",
    "syntax": "function long cmf.getnotification (long mid, ref enum notification)",
    "description": "Gets the notification required of the message identified by mid and returns it in the enum notification.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref enum",
        "name": "notification",
        "description": "Message notification. �ALWAYS� | �DELIVERY� | �NON-DELIVERY� | �NEVER�"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.getpriority": {
    "name": "cmf.getPriority",
    "type": "function",
    "syntax": "function long cmf.getpriority (long mid, ref enum priority)",
    "description": "Gets the priority of the message identified by mid and returns it in the enum priority .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref enum",
        "name": "priority",
        "description": "Message priority. �LOW� | �NORMAL� | �HIGH�"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getrecipientaddress": {
    "name": "cmf.getRecipientAddress",
    "type": "function",
    "syntax": "function long cmf.getrecipientaddress (long recipient, ref string address)",
    "description": "Gets the address of the recipient identified by recipient and returns it in the string address.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref string",
        "name": "address",
        "description": "The address of the recipient."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getrecipientname": {
    "name": "cmf.getRecipientName",
    "type": "function",
    "syntax": "function long cmf.getrecipientname (long recipient, ref string name)",
    "description": "Gets the name of the recipient identified by recipient and returns it in the string name.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref string",
        "name": "name",
        "description": "The name of the recipient."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getrecipientreasoncode": {
    "name": "cmf.getRecipientReasoncode",
    "type": "function",
    "syntax": "function long cmf.getrecipientreasoncode (long recipient, ref long reasoncode)",
    "description": "Gets the reason code of the recipient identified by recipient and returns it in the string reasoncode.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref long",
        "name": "reasoncode",
        "description": "The code of the reason why the message could not be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getrecipientreasonstring": {
    "name": "cmf.getRecipientReasonstring",
    "type": "function",
    "syntax": "function long cmf.getrecipientreasonstring (long recipient, ref string reasonstring)",
    "description": "Gets the reason string of the recipient identified by recipient and returns it in the string reasonstring.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref string",
        "name": "reasonstring",
        "description": "The description of the reason why the message could not be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getrecipientresponsibility": {
    "name": "cmf.getRecipientResponsibility",
    "type": "function",
    "syntax": "function long cmf.getrecipientresponsibility (long recipient, ref string responsibility)",
    "description": "Gets the responsibility of the recipient identified by recipient and returns it in the string responsibility.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref string",
        "name": "responsibility",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getrecipienttype": {
    "name": "cmf.getRecipientType",
    "type": "function",
    "syntax": "function long cmf.getrecipienttype (long recipient, ref string type)",
    "description": "Gets the type of the recipient identified by recipient and returns it in the string type.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "ref string",
        "name": "type",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.getsensitivity": {
    "name": "cmf.getSensitivity",
    "type": "function",
    "syntax": "function long cmf.getsensitivity (long mid, ref enum sensitivity)",
    "description": "Gets the sensitivity of the message identified by mid and returns it in the enum sensitivity .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref enum",
        "name": "sensitivity",
        "description": "Message sensitivity. �NORMAL� | �PERSONAL� | �PRIVATE� | �CONFIDENTIAL� | �SECRET�"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getservice": {
    "name": "cmf.getService",
    "type": "function",
    "syntax": "function long cmf.getService (string addresstype, enum user_interaction, enum resolve, ref string service)",
    "description": "Returns the name of the service that supports the addresstype specified by the variables addresstype , user_interaction and resolve . The enum variables use the same enum types as their respective fields in the Infor ERP Enterprise eMessage Connector Address Types by Service table.",
    "arguments": [
      {
        "type": "string",
        "name": "addresstype",
        "description": "Specify the Infor ERP Enterprise eMessage Connector address type, for example, smtp, fax, telex and so on."
      },
      {
        "type": "enum",
        "name": "user_interaction",
        "description": "Specify if the service must allow user interaction before completion of the message transfer. \"YES\"|\"NO\""
      },
      {
        "type": "enum",
        "name": "resolve",
        "description": "Specify if the service should have resolve capability when given a name and address type. \"YES\"|\"NO\""
      },
      {
        "type": "ref string",
        "name": "service",
        "description": "Returns the service identification that supports given parameters."
      }
    ],
    "returnValue": "0 Success. -1 No matching service found. The value of service is undefined in this case.",
    "category": "emessage_connector"
  },
  "cmf.getstarttime": {
    "name": "cmf.getStartTime",
    "type": "function",
    "syntax": "function long cmf.getstarttime (long mid, ref domain ttutc starttime)",
    "description": "Gets the delivery start time of the message identified by mid and return in the utc date starttime.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "starttime",
        "description": "Start time when the message must be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present.",
    "category": "emessage_connector"
  },
  "cmf.getsubject": {
    "name": "cmf.getSubject",
    "type": "function",
    "syntax": "function long cmf.getsubject (long mid, ref string subject)",
    "description": "Gets the message subject of the message identified by mid and return string into subject.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "subject",
        "description": "Message subject line."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.gettaskduedate": {
    "name": "cmf.getTaskDuedate",
    "type": "function",
    "syntax": "function long cmf.gettaskduedate (long tid, ref domain ttutc duedate)",
    "description": "Gets the task duedate of the task identified by tid and return it in the utc date duedate.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "duedate",
        "description": "The date by which the task must be finished."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.gettaskpriority": {
    "name": "cmf.getTaskPriority",
    "type": "function",
    "syntax": "function long cmf.gettaskpriority (long tid, ref enum priority)",
    "description": "Gets the task priority of the task identified by tid and returns string into priority.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref enum",
        "name": "priority",
        "description": "The task priority: \"LOW\" | \"NORMAL\" | \"HIGH\""
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.gettaskremindertime": {
    "name": "cmf.getTaskReminderTime",
    "type": "function",
    "syntax": "function long cmf.gettaskremindertime (long tid, ref domain ttutc remindertime)",
    "description": "Gets the task remindertime of the task identified by tid and returns it in the utc date remindertime.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "remindertime",
        "description": "The task reminder time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.gettaskstartdate": {
    "name": "cmf.getTaskStartdate",
    "type": "function",
    "syntax": "function long cmf.gettaskstartdate (long tid, ref domain ttutc startdate)",
    "description": "Gets the task startdate of the task identified by tid and returns it in the string startdate.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref domain ttutc",
        "name": "startdate",
        "description": "Start date of the task."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object or element not present. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.gettasksubject": {
    "name": "cmf.getTaskSubject",
    "type": "function",
    "syntax": "function long cmf.gettasksubject (long tid, ref string subject)",
    "description": "Gets the task subject of the task identified by tid and return string into subject.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref string",
        "name": "subject",
        "description": "The task subject."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.gettasktotalwork": {
    "name": "cmf.getTaskTotalwork",
    "type": "function",
    "syntax": "function long cmf.gettasktotalwork (long tid, ref string totalwork)",
    "description": "Gets the totalwork of the task identified by tid and return string into totalwork.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "ref string",
        "name": "totalwork",
        "description": "The total work for the task."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.gettemplate": {
    "name": "cmf.getTemplate",
    "type": "function",
    "syntax": "function long cmf.gettemplate (long mid, ref string template)",
    "description": "Gets the message template of the message identified by mid and return string into template.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "ref string",
        "name": "template",
        "description": "Message template identification."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.isserviceenabled": {
    "name": "cmf.isServiceEnabled",
    "type": "function",
    "syntax": "function long cmf.isserviceenabled (domain ttcmf.prov service)",
    "description": "Checks in the Services (ttcmf030) table if service is enabled (ttcmf030.enab = yes) or not.",
    "arguments": [
      {
        "type": "domain ttcmf.prov",
        "name": "service",
        "description": "The service identification."
      }
    ],
    "returnValue": "1 true: service is enabled 0 false : service is disabled. -1 service not found in table Services (ttcmf030)",
    "category": "emessage_connector"
  },
  "cmf.messagedialog": {
    "name": "cmf.messageDialog",
    "type": "function",
    "syntax": "function long cmf.messagedialog (long mode, long show [, long show.message])",
    "description": "Launches a Message dialog box.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": ""
      },
      {
        "type": "long",
        "name": "show",
        "description": ""
      },
      {
        "type": "[long",
        "name": "show.message ]",
        "description": "If the optional show.message argument is set to 1, cmf.sendToPerson will start up a user interface based service (if available) for each message type found in the addresslist object."
      }
    ],
    "returnValue": "0 Success. -1 Error launching the Message Dialog. -2 Error: invalid argument value(s).",
    "category": "emessage_connector"
  },
  "cmf.receive": {
    "name": "cmf.receive",
    "type": "function",
    "syntax": "function long cmf.receive (long mid, domain ttcmf.prov service, long block)",
    "description": "Receives a Infor ERP Enterprise eMessage Connector message object and returns the object id in mid . The appropriate connector must have been previously started prior to calling this function using cmf.startService()cmf.startService .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "domain ttcmf.prov",
        "name": "service",
        "description": "Service offered by a provider, for example, Fax or Email."
      },
      {
        "type": "long",
        "name": "block",
        "description": "Flag indicating whether cmf.receive will wait for a message (blocking) or simply return if there is no message waiting (nonblocking)."
      }
    ],
    "returnValue": "0 Success. -1 Error receiving message. -2 Service not started.",
    "category": "emessage_connector"
  },
  "cmf.resolveaddress": {
    "name": "cmf.resolveAddress",
    "type": "function",
    "syntax": "function long cmf.resolveaddress (ref domain ttcmf.catg category, ref domain ttcmf.catg key, ref domain ttcmf.defa addresstype, ref string address(), ref string message.str [, string name(100) mb] [, long use.default])",
    "description": "Selects address data of recipient identified by key and category from Address Book and sets address depending on value of addresstype. Address data is selected from Tools Address Book (table ttcmf200) if current company is 0 and from Infor ERP Enterprise Address Book (table tccom130/131) if current company is not 0.",
    "arguments": [
      {
        "type": "ref domain ttcmf.catg",
        "name": "category",
        "description": "Recipient's category."
      },
      {
        "type": "ref domain ttcmf.catg",
        "name": "key",
        "description": "Recipient's key."
      },
      {
        "type": "ref domain ttcmf.defa",
        "name": "addresstype",
        "description": "Recipient type of address (fax, telex, smtp and so on.)"
      },
      {
        "type": "ref string",
        "name": "address()",
        "description": "Recipient's actual address depending on the address type."
      },
      {
        "type": "ref string",
        "name": "message.str",
        "description": ""
      },
      {
        "type": "[string",
        "name": "name(100) mb ]",
        "description": "The name of the recipient."
      },
      {
        "type": "[long",
        "name": "use.default ]",
        "description": "If true, the default address type for the recipient is used."
      }
    ],
    "returnValue": "0 Success. -1 Error: no address specified for addresstype in Address Book -2 Error: recipient not found in Address Book -3 Error: more than one record found in Address Book -4 Error: dll tcintdlltccom not found on server -5 Error: function tcint.dlltccom.start.addresses not found in dll tcintdlltccom. -6 Error: key field must be filled if category is Business Contact -7 Error: table tccom130 and/or tccom131 not found -8 Error: something went wrong in execution of function tcint.dlltccom.start.addresses in DLL tcintdlltccom",
    "category": "emessage_connector"
  },
  "cmf.send": {
    "name": "cmf.send",
    "type": "function",
    "syntax": "function long cmf.send (long mid, string service(15))",
    "description": "Sends the Infor ERP Enterprise eMessage Connector message object identified by mid using the service specified by service . The message class is set to the service name.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "service(15)",
        "description": "Service offered by a provider, for example, Fax or Email."
      }
    ],
    "returnValue": "0 Success. -1 Error sending message -2 Service not started",
    "category": "emessage_connector"
  },
  "cmf.sendtoperson": {
    "name": "cmf.sendToPerson",
    "type": "function",
    "syntax": "function long cmf.sendtoperson (long mid, long aid, long display, long show.progress, ref string message_string(), long convert, string filename1 ...)",
    "description": "Takes the message object and sends it to the recipients in the addresslist object that is identified by aid.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "long",
        "name": "aid",
        "description": "Identification of the address list."
      },
      {
        "type": "long",
        "name": "display",
        "description": ""
      },
      {
        "type": "long",
        "name": "show.progress",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "message_string()",
        "description": "Constructed error message which contains the number of recipients that could not be reached, and the error details. If no errors, message_string contains a success message"
      },
      {
        "type": "long",
        "name": "convert",
        "description": ""
      },
      {
        "type": "string",
        "name": "filename1 ...",
        "description": ""
      }
    ],
    "returnValue": "0 Success for all recipients. -1 Failure for some or all recipients (Check recipient list object).",
    "category": "emessage_connector"
  },
  "cmf.setappointmentalarm": {
    "name": "cmf.setAppointmentAlarm",
    "type": "function",
    "syntax": "function long cmf.setappointmentalarm (long apid, domain ttutc alarm)",
    "description": "Sets the alarm of the appointment identified by apid to the value alarm.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "domain ttutc",
        "name": "alarm",
        "description": "The alarm time for the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentalldayevent": {
    "name": "cmf.setAppointmentAlldayevent",
    "type": "function",
    "syntax": "function long cmf.setappointmentalldayevent (long apid, enum alldayevent)",
    "description": "Sets the alldayevent flag of the appointment identified by apid to the value alldayevent.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "enum",
        "name": "alldayevent",
        "description": "All day event appointment: \"YES\" | \"NO\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentbusystatus": {
    "name": "cmf.setAppointmentBusystatus",
    "type": "function",
    "syntax": "function long cmf.setappointmentbusystatus (long apid, enum busystatus)",
    "description": "Sets the busystatus of the appointment identified by apid to the value busystatus.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "enum",
        "name": "busystatus",
        "description": "The busy status of the appointment. \"BUSY\" | \"FREE\" | \"OUTOFOFFICE\" | \"TENTATIVE\""
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setappointmentdescription": {
    "name": "cmf.setAppointmentDescription",
    "type": "function",
    "syntax": "function long cmf.setAppointmentDescription (long apid, string description)",
    "description": "Set the description text of the appointment identified by apid to the value description . The description of an appointment is optional and may consist of multiple lines of text. Each line must be terminated by a linefeed character.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "string",
        "name": "description",
        "description": "The description text."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentendtime": {
    "name": "cmf.setAppointmentEndtime",
    "type": "function",
    "syntax": "function long cmf.setappointmentendtime (long apid, domain ttutc endtime)",
    "description": "Sets the endtime of the appointment identified by apid to the value endtime.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "domain ttutc",
        "name": "endtime",
        "description": "The end time of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentlocation": {
    "name": "cmf.setAppointmentLocation",
    "type": "function",
    "syntax": "function long cmf.setappointmentlocation (long apid, string location)",
    "description": "Sets the appointment location of the appointment identified by apid to the value location.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "string",
        "name": "location",
        "description": "The location of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setappointmentmeeting": {
    "name": "cmf.setAppointmentMeeting",
    "type": "function",
    "syntax": "function long cmf.setappointmentmeeting (long apid, enum meeting)",
    "description": "Sets the meeting flag of the appointment identified by apid to the value meeting.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "enum",
        "name": "meeting",
        "description": "Appointment meeting: \"YES\" | \"NO\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentmethod": {
    "name": "cmf.setAppointmentMethod",
    "type": "function",
    "syntax": "function long cmf.setAppointmentMethod (long apid, domain ttcmf.mth method)",
    "description": "Set the METHOD attribute of the appointment identified by apid to the value method .",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "domain ttcmf.mth",
        "name": "method",
        "description": "The new method value which is one of ttcmf.mth.request for sending a new or update on an appointment or ttcmf.mth.cancel for canceling an appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setappointmentstarttime": {
    "name": "cmf.setAppointmentStarttime",
    "type": "function",
    "syntax": "function long cmf.setappointmentstarttime (long apid, domain ttutc starttime)",
    "description": "Sets the appointment starttime of the appointment identified by apid to the value starttime.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "domain ttutc",
        "name": "starttime",
        "description": "The start time of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error",
    "category": "emessage_connector"
  },
  "cmf.setappointmentsubject": {
    "name": "cmf.setAppointmentSubject",
    "type": "function",
    "syntax": "function long cmf.setappointmentsubject (long apid, string subject)",
    "description": "Sets the appointment subject of the appointment identified by apid to the value subject.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "string",
        "name": "subject",
        "description": "The subject of the appointment."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setappointmentuuid": {
    "name": "cmf.setAppointmentUUID",
    "type": "function",
    "syntax": "function long cmf.setAppointmentUUID (long apid, string uuid)",
    "description": "Set the unique identifier attribute of the appointment identified by apid to the value uuid . The function cmf.createAppointment() creates globally unique identifier and assigns it to the created appointment object. The function cmf.setAppointmentUUID() can be used to change this identifier. This identifier is used by calendar systems to correlate previously sent appointments to this appointment. For instance to recognize an appointment as an update of previously sent appointment the same UUID must be used. In addition the UUID must be set by the application to cancel a previously sent appointment.",
    "arguments": [
      {
        "type": "long",
        "name": "apid",
        "description": "The appointment identification."
      },
      {
        "type": "string",
        "name": "uuid",
        "description": "The new uuid value."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setattachmentbody": {
    "name": "cmf.setAttachmentBody",
    "type": "function",
    "syntax": "function long cmf.setattachmentbody (long attachment, enum body)",
    "description": "Sets the type of the attachment identified by attachment to the value body. If body is �YES�, then the attachment is considered to be the bodytext. Only one body attachment is allowed for each message object, although this is NOT enforced by the Infor ERP Enterprise eMessage Connector.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "enum",
        "name": "body",
        "description": "Is attachment the bodytext: ttyeno.yes | ttyeno.no Only one attachment for each message can be the body."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.setattachmentfilename": {
    "name": "cmf.setAttachmentFilename",
    "type": "function",
    "syntax": "function long cmf.setattachmentfilename (long attachment, string filename [, string displayname])",
    "description": "Sets the physical filename of the attachment identified by attachment to the value filename. Sets the human-readable filename to displayname . If displayname is not supplied, then the readable filename is set to the physical filename.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "string",
        "name": "filename",
        "description": "The physical filename."
      },
      {
        "type": "[string",
        "name": "displayname ]",
        "description": "The name of the file that is displayed. If displayname is not supplied, then the physical filename is used."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.setattachmentmime": {
    "name": "cmf.setAttachmentMIME",
    "type": "function",
    "syntax": "function long cmf.setattachmentmime (long attachment, string mimetype)",
    "description": "Sets the mime type of the attachment identified by attachment to the value mime.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "string",
        "name": "mimetype",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.setattachmentposition": {
    "name": "cmf.setAttachmentPosition",
    "type": "function",
    "syntax": "function long cmf.setattachmentposition (long attachment, string position(10))",
    "description": "Sets the position of the attachment identified as attachment to the value position. Position determines the number of characters (of the bodytext) after which the attachment-icon will be placed. By default the attachment-icon is positioned at the end of the bodytext.",
    "arguments": [
      {
        "type": "long",
        "name": "attachment",
        "description": "The attachment identification."
      },
      {
        "type": "string",
        "name": "position(10)",
        "description": "The attachment position determines the number of characters (of the bodytext) after which the attachment-icon will be placed."
      }
    ],
    "returnValue": "0 Success. -1 Invalid attachment identification.",
    "category": "emessage_connector"
  },
  "cmf.setcategories": {
    "name": "cmf.setCategories",
    "type": "function",
    "syntax": "function long cmf.setcategories (long mid, string categories)",
    "description": "Sets the categories of the message identified by mid to the value categories. Categories are supplied in a comma delimited list. Mail clients such as Microsoft Outlook make use of categories and all categories used in Outlook can be used here.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "categories",
        "description": "Message category."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setchargecode": {
    "name": "cmf.setChargeCode",
    "type": "function",
    "syntax": "function long cmf.setchargecode (long mid, string chargecode)",
    "description": "Sets the message charge code of the message identified by mid to the value chargecode. Chargecodes are used to determine who will be charged for sending/receiving this message.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "chargecode",
        "description": "Message charge code."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setclass": {
    "name": "cmf.setClass",
    "type": "function",
    "syntax": "function long cmf.setclass (long mid, string class)",
    "description": "Sets the message class of the message identified by mid to the value class.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.setdisplay": {
    "name": "cmf.setDisplay",
    "type": "function",
    "syntax": "function long cmf.setdisplay (long mid, enum display)",
    "description": "Sets the display option of this message identified by mid to the value display .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "enum",
        "name": "display",
        "description": "When set to \"TRUE\" the message will be shown before sending it. A User interface based service will be started. \"FALSE\" means the message will be sent without showing it first. UI-based and non ui-based service(s) can be started"
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setduedate": {
    "name": "cmf.setDueDate",
    "type": "function",
    "syntax": "function long cmf.setduedate (long mid, domain ttutc duedate)",
    "description": "Sets the duedate of the message identified by mid to the value duedate. In case this message is routed through Microsoft Outlook, the message follow-up flag is set together with the indicated duedate.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "domain ttutc",
        "name": "duedate",
        "description": "Message duedate time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.setexpiry": {
    "name": "cmf.setExpiry",
    "type": "function",
    "syntax": "function long cmf.setexpiry (long mid, domain ttutc expiry)",
    "description": "Sets the expiry time of the message identified by mid to the value expiry.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "domain ttutc",
        "name": "expiry",
        "description": "Message expiry time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.setfollowupflag": {
    "name": "cmf.setFollowupFlag",
    "type": "function",
    "syntax": "function long cmf.setfollowupflag (long mid)",
    "description": "Sets the follow-up flag of the message identified by mid .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setmessageid": {
    "name": "cmf.setMessageId",
    "type": "function",
    "syntax": "function long cmf.setmessageid (long mid, string messageId)",
    "description": "Sets the message ID of the message identified by mid and returns string into messageId. The messageId is a string that uniquely identifies a message within Infor ERP Enterprise eMessage Connector. The application using Baan eMessage Connector need not to call this function as Infor ERP Enterprise eMessage Connector will take care of this automatically.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "messageId",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id or element not present).",
    "category": "emessage_connector"
  },
  "cmf.setnotification": {
    "name": "cmf.setNotification",
    "type": "function",
    "syntax": "function long cmf.setnotification (long mid, enum notification)",
    "description": "Sets the notification required of the message identified by mid to the value notification.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "enum",
        "name": "notification",
        "description": "Message Notification: \"ALWAYS\"|\"DELIVERY\"|\"NON-DELIVERY\"|\"NEVER\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setpriority": {
    "name": "cmf.setPriority",
    "type": "function",
    "syntax": "function long cmf.setpriority (long mid, enum priority)",
    "description": "Sets the priority of the message identified by mid to the value priority.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "enum",
        "name": "priority",
        "description": "Message priority. �LOW� | �NORMAL� | �HIGH� ."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setrecipientaddress": {
    "name": "cmf.setRecipientAddress",
    "type": "function",
    "syntax": "function long cmf.setrecipientaddress (long recipient, string address)",
    "description": "Sets the address of the recipient identified by recipient to the value address. An address could be a fax number, SMTP address, SMS number, and so on)",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "string",
        "name": "address",
        "description": "The address of the recipient."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setrecipientname": {
    "name": "cmf.setRecipientName",
    "type": "function",
    "syntax": "function long cmf.setrecipientname (long recipient, string name)",
    "description": "Sets the (human-readable) name of the recipient identified by recipient to the value name.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "string",
        "name": "name",
        "description": "The name of the recipient."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setrecipientreasoncode": {
    "name": "cmf.setRecipientReasoncode",
    "type": "function",
    "syntax": "function long cmf.setrecipientreasoncode (long recipient, long reasoncode)",
    "description": "Sets the reason code of the recipient identified by recipient to the value reasoncode. The reason code is used only in case of a non-delivery of a message to a recipient.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "long",
        "name": "reasoncode",
        "description": "The code of the reason why the message could not be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setrecipientreasonstring": {
    "name": "cmf.setRecipientReasonstring",
    "type": "function",
    "syntax": "function long cmf.setrecipientreasonstring (long recipient, string reasonstring(100))",
    "description": "Sets the (human-readable) reason string of the recipient identified by recipient to the value reasonstring. The reason string is used only in case of a non-delivery of a message to a recipient.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "string",
        "name": "reasonstring(100)",
        "description": "The description of the reason why the message could not be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setrecipientresponsibility": {
    "name": "cmf.setRecipientResponsibility",
    "type": "function",
    "syntax": "function long cmf.setrecipientresponsibility (long recipient, string responsibility)",
    "description": "Sets the responsibility of the recipient identified by recipient to the value responsibility.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "string",
        "name": "responsibility",
        "description": "The responsibility of the recipient: \"TRUE\"|\"FALSE\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setrecipienttype": {
    "name": "cmf.setRecipientType",
    "type": "function",
    "syntax": "function long cmf.setrecipienttype (long recipient, string type)",
    "description": "Sets the type of the recipient identified by recipient to the value type. The listed types are only examples and new types can be introduced at any time.",
    "arguments": [
      {
        "type": "long",
        "name": "recipient",
        "description": "The recipient identification."
      },
      {
        "type": "string",
        "name": "type",
        "description": "The type of the recipient: �FAX� | �TELEX� | �SMTP� | �SMS � | �SITA� | �BAAN� | �"
      }
    ],
    "returnValue": "0 Success. -1 Invalid recipient id.",
    "category": "emessage_connector"
  },
  "cmf.setsensitivity": {
    "name": "cmf.setSensitivity",
    "type": "function",
    "syntax": "function long cmf.setsensitivity (long mid, enum sensitivity)",
    "description": "Sets the sensitivity of the message identified by mid to the value sensitivity .",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "enum",
        "name": "sensitivity",
        "description": "Message sensitivity. �NORMAL� | �PERSONAL� | �PRIVATE� | �CONFIDENTIAL� | �SECRET\""
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object.",
    "category": "emessage_connector"
  },
  "cmf.setstarttime": {
    "name": "cmf.setStartTime",
    "type": "function",
    "syntax": "function long cmf.setstarttime (long mid, domain ttutc starttime)",
    "description": "Sets the delivery start time of the message identified by mid to the value starttime.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "domain ttutc",
        "name": "starttime",
        "description": "Start time when the message must be delivered."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.setsubject": {
    "name": "cmf.setSubject",
    "type": "function",
    "syntax": "function long cmf.setsubject (long mid, string subject)",
    "description": "Sets the message subject line of the message identified by mid to the value subject. This is a mandatory property for a Infor ERP Enterprise eMessage Connector Connector message.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "subject",
        "description": "Message subject line."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.settaskduedate": {
    "name": "cmf.setTaskDuedate",
    "type": "function",
    "syntax": "function long cmf.settaskduedate (long tid, domain ttutc duedate)",
    "description": "Sets the task duedate of the task identified by tid to the value duedate.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "domain ttutc",
        "name": "duedate",
        "description": "The date by which the task must be finished."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.settaskpriority": {
    "name": "cmf.setTaskPriority",
    "type": "function",
    "syntax": "function long cmf.settaskpriority (long tid, enum priority)",
    "description": "Sets the task priority of the task identified by tid to the value priority. This is a mandatory property for a Infor ERP Enterprise eMessage Connector task.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "enum",
        "name": "priority",
        "description": "The task priority: \"LOW\" | \"NORMAL\" | \"HIGH\""
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.settaskremindertime": {
    "name": "cmf.setTaskReminderTime",
    "type": "function",
    "syntax": "function long cmf.settaskremindertime (long tid, domain ttutc remindertime)",
    "description": "Sets the task remindertime of the task identified by tid to the value remindertime.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "domain ttutc",
        "name": "remindertime",
        "description": "The task reminder time."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Date conversion error.",
    "category": "emessage_connector"
  },
  "cmf.settaskstartdate": {
    "name": "cmf.setTaskStartdate",
    "type": "function",
    "syntax": "function long cmf.settaskstartdate (long tid, domain ttutc startdate)",
    "description": "Sets the task startdate of the task identified by tid to the value startdate.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "domain ttutc",
        "name": "startdate",
        "description": "Start date of the task."
      }
    ],
    "returnValue": "0 Success. -1 Invalid cmf object. -2 Invalid value for startdate .",
    "category": "emessage_connector"
  },
  "cmf.settasksubject": {
    "name": "cmf.setTaskSubject",
    "type": "function",
    "syntax": "function long cmf.settasksubject (long tid, string subject)",
    "description": "Sets the task subject of the task identified by tid to the value subject. This is a mandatory property for a Infor ERP Enterprise eMessage Connector task.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "string",
        "name": "subject",
        "description": "The task subject."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.settasktotalwork": {
    "name": "cmf.setTaskTotalwork",
    "type": "function",
    "syntax": "function long cmf.settasktotalwork (long tid, string totalwork)",
    "description": "Sets the task totalwork of the task identified by tid to the value totalwork.",
    "arguments": [
      {
        "type": "long",
        "name": "tid",
        "description": "The Infor ERP Enterprise eMessage Connector task object identification."
      },
      {
        "type": "string",
        "name": "totalwork",
        "description": "The total work for the task."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.settemplate": {
    "name": "cmf.setTemplate",
    "type": "function",
    "syntax": "function long cmf.settemplate (long mid, string template)",
    "description": "Sets the message template identification of the message identified by mid to the value template.",
    "arguments": [
      {
        "type": "long",
        "name": "mid",
        "description": "Message object identification."
      },
      {
        "type": "string",
        "name": "template",
        "description": "Message template identification."
      }
    ],
    "returnValue": "0 Success. -1 Error (most likely invalid object id).",
    "category": "emessage_connector"
  },
  "cmf.startservice": {
    "name": "cmf.startService",
    "type": "function",
    "syntax": "function long cmf.startservice (long service(15), long mode [, string address(13)])",
    "description": "Starts the Infor ERP Enterprise eMessage Connector service",
    "arguments": [
      {
        "type": "long",
        "name": "service(15)",
        "description": "The service offered by a provider, for example, Fax or Email."
      },
      {
        "type": "long",
        "name": "mode",
        "description": ""
      },
      {
        "type": "[string",
        "name": "address(13) ]",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Service not present. -2 Service could not be started. -3 Service not enabled.",
    "category": "emessage_connector"
  },
  "cmf.stopallservices": {
    "name": "cmf.stopAllServices",
    "type": "function",
    "syntax": "function void cmf.stopallservices ()",
    "description": "Stops all Infor ERP Enterprise eMessage Connector services started by cmf.sendToPerson() .",
    "arguments": [],
    "returnValue": "None.",
    "category": "emessage_connector"
  },
  "cmf.stopservice": {
    "name": "cmf.stopService",
    "type": "function",
    "syntax": "function long cmf.stopservice (long service(15), long mode)",
    "description": "Stops the currently running Infor ERP Enterprise eMessage Connector service named service which is running in mode mode.",
    "arguments": [
      {
        "type": "long",
        "name": "service(15)",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 No service running. -2 Service could not be stopped normally.",
    "category": "emessage_connector"
  },
  "cmf.updateaddressstatus": {
    "name": "cmf.updateAddressStatus",
    "type": "function",
    "syntax": "function long cmf.updateaddressstatus (long entry_id, long errorcode)",
    "description": "Updates the error status of an address entry. Entry_id is obtained from the function cmf.getNextAddress(). The possible values of errorcode are subdivided into two categories: errors which can also occur when the addresslist object is empty (global error variables used) and errors which only occur when the addresslist object is filled with one or more recipients: then the errorcode of the recipient is set to indicate the nature of the error. Possible values:",
    "arguments": [
      {
        "type": "long",
        "name": "entry_id",
        "description": "The address list entry identification."
      },
      {
        "type": "long",
        "name": "errorcode",
        "description": "See tables above."
      }
    ],
    "returnValue": "0 Success. -1 Error updating entry (most likely invalid address entry id).",
    "category": "emessage_connector"
  },
  "emessage connector examples": {
    "name": "eMessage Connector examples",
    "type": "function",
    "syntax": "function eMessage Connector examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "emessage_connector"
  },
  "emessage connector overview": {
    "name": "eMessage Connector overview",
    "type": "function",
    "syntax": "function eMessage Connector overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "emessage_connector"
  },
  "emessage connector synopsis": {
    "name": "eMessage Connector synopsis",
    "type": "function",
    "syntax": "function eMessage Connector synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "emessage_connector"
  },
  "event array parameters": {
    "name": "Event array parameters",
    "type": "function",
    "syntax": "function Event array parameters()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "events"
  },
  "event types": {
    "name": "Event types",
    "type": "function",
    "syntax": "function Event types()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "events"
  },
  "next.event": {
    "name": "next.event",
    "type": "function",
    "syntax": "function long next.event ( [ref long event(EVTMAXSIZE)])",
    "description": "This removes the event at the top of the event queue and stores it in event . If the event queue is empty, the function waits (that is, it is blocked) until an event arrives. To time out the next.event() function, use set.timer()set.timer.",
    "arguments": [
      {
        "type": "[ref long",
        "name": "event(EVTMAXSIZE) ]",
        "description": "Optional reference argument containing a long array in which the next.event() function will write the event array parameters ."
      }
    ],
    "returnValue": "The event type. See Event types .",
    "category": "events"
  },
  "events overview": {
    "name": "Events overview",
    "type": "function",
    "syntax": "function Events overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "events"
  },
  "peek.event": {
    "name": "peek.event",
    "type": "function",
    "syntax": "function long peek.event ( [ref long event(EVTMAXSIZE)])",
    "description": "This reads the event at the top of the event queue and stores it in event . It does not remove the event from the queue. If the event queue is empty, the function waits (that is, it is blocked) until an event arrives. To time out the peek.event() function, use set.timer()set.timer.",
    "arguments": [
      {
        "type": "[ref long",
        "name": "event(EVTMAXSIZE) ]",
        "description": "Optional reference argument containing a long array in which the peek.event() function will write the event array parameters ."
      }
    ],
    "returnValue": "The event type. See Event types .",
    "category": "events"
  },
  "pending.events": {
    "name": "pending.events",
    "type": "function",
    "syntax": "function long pending.events ()",
    "description": "This returns the number of events present in the event queue of the process group. Note that including the function in an empty loop uses a lot of processor time. For example:",
    "arguments": [],
    "returnValue": ">0 number of events in event queue 0 empty queue",
    "category": "events"
  },
  "events sample program": {
    "name": "Events sample program",
    "type": "function",
    "syntax": "function Events sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "events"
  },
  "select.event.input": {
    "name": "select.event.input",
    "type": "function",
    "syntax": "function void select.event.input (long object_id, long masks)",
    "description": "This defines which event types can be generated by the specified object.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object to which the specified masks apply."
      },
      {
        "type": "long",
        "name": "masks",
        "description": "A combination of one or more values that indicate the event types that the specified object can generate. If the event queue already contains events not specified by this function, they are NOT removed from the queue. The possible event mask values are: EVTNOEVENTMASKNo events EVTALLEVENTMASK All events EVTBUTTONPRESSMASK Mouse button press events EVTBUTTONDPRESSMASK Mouse button double press events EVTBUTTONRELEASEMASK Mouse button release events EVTBUTTONMOTIONMASK Mouse pointer motion events EVTKEYPRESSMASK Key press events EVTRESIZEWINDOWMASK Resize window events EVTBUTTONSELECTMASK Control button select events EVTFIELDSELECTMASK Field select events EVTGRIDEVENTMASK Grid events EVTLISTBOXSELECTMASK List box item select events EVTMENUSELECTMASK Menu item select events EVTSCROLLBARSELECTMASK Scrollbar select events EVTTABSELECTMASK Tab frame events EVTTREESELECTMASK Tree events EVTCHANGEFOCUSMASK Change focus events EVTSETFOCUSMASK Set focus events EVTIOEVENTMASK I/O events EVTOLEEVENTMASK OLE events EVTTERMINATIONMASK Termination events EVTHELPEVENTMASK Help events"
      }
    ],
    "returnValue": "",
    "category": "events"
  },
  "send.event": {
    "name": "send.event",
    "type": "function",
    "syntax": "function long send.event (long proc_grp, long event(EVTMAXSIZE))",
    "description": "This sends an event from the current process to the specified process group. It enables event-driven communication between processes. A process can send any event type using this function. Note that this is the only way to send events of type EVTCLIENTMESSAGE.",
    "arguments": [
      {
        "type": "long",
        "name": "proc_grp",
        "description": "The ID of the process group."
      },
      {
        "type": "long",
        "name": "event(EVTMAXSIZE)",
        "description": "Long array containing the event array parameters of the event that must be sent to the process group."
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "events"
  },
  "events synopsis": {
    "name": "Events synopsis",
    "type": "function",
    "syntax": "function Events synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "events"
  },
  "appl.delete.excl": {
    "name": "appl.delete.excl",
    "type": "function",
    "syntax": "function long appl.delete.excl (const string name)",
    "description": "This removes a specified exclusive application lock. Only the owner of the lock can delete it. And a lock can be deleted only from within the same process in which it was set.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The lock name"
      }
    ],
    "returnValue": "0 Lock removed -1 Lock not found -3 Internal error",
    "category": "functions_appl"
  },
  "appl.delete": {
    "name": "appl.delete",
    "type": "function",
    "syntax": "function long appl.delete (const string name)",
    "description": "This removes a specified application lock. Only the owner of the lock can delete it. And a lock can be deleted only from within the same process in which it was set.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The lock name"
      }
    ],
    "returnValue": "0 Lock removed -1 Lock not found -3 Internal error",
    "category": "functions_appl"
  },
  "appl.get.user.excl": {
    "name": "appl.get.user.excl",
    "type": "function",
    "syntax": "function long appl.get.user.excl (const string name, ref string user(12) [, ref string session(13)])",
    "description": "This retrieves the BAAN login name of the user who created the specified exclusive application lock.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the lock."
      },
      {
        "type": "ref string",
        "name": "user(12)",
        "description": "The username of the user who created the lock."
      },
      {
        "type": "[ref string",
        "name": "session(13) ]",
        "description": "The session that has been locked."
      }
    ],
    "returnValue": "0 success -1 lock not found",
    "category": "functions_appl"
  },
  "appl.get.user": {
    "name": "appl.get.user",
    "type": "function",
    "syntax": "function long appl.get.user (const string name, ref string user(12) [, ref string session(13)])",
    "description": "This retrieves the BAAN login name of the user who created the specified application lock.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the lock."
      },
      {
        "type": "ref string",
        "name": "user(12)",
        "description": "The username of the user who created the lock."
      },
      {
        "type": "[ref string",
        "name": "session(13) ]",
        "description": "The session that has been locked."
      }
    ],
    "returnValue": "0 success -1 lock not found",
    "category": "functions_appl"
  },
  "appl.modify": {
    "name": "appl.modify",
    "type": "function",
    "syntax": "function long appl.modify (const string name, long old.owner, long new.owner)",
    "description": "This changes the owner of a specified application lock. That is, it links the application lock to another 4GL process in the same bshell.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the application lock."
      },
      {
        "type": "long",
        "name": "old.owner",
        "description": "The process ID of the current owner."
      },
      {
        "type": "long",
        "name": "new.owner",
        "description": "The process ID of the new owner."
      }
    ],
    "returnValue": "0 success -1 lock not found -2 new owner not found -3 internal error",
    "category": "functions_appl"
  },
  "appl.set.excl": {
    "name": "appl.set.excl",
    "type": "function",
    "syntax": "function long appl.set.excl (const string name)",
    "description": "This creates an exclusive application lock for the current application.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the application lock. This must be unique."
      }
    ],
    "returnValue": "0 success -1 application-wide lock present -3 internal error >0 application lock already present; mode is returned",
    "category": "functions_appl"
  },
  "appl.set": {
    "name": "appl.set",
    "type": "function",
    "syntax": "function long appl.set (const string name, long mode)",
    "description": "This creates an application lock for the current application.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the application lock. This must be unique."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "The type of application lock to set: APPL.READ APPL.WRITE APPL.EXCL APPL.WIDE You can combine APPL.WIDE with any one of the other lock types."
      }
    ],
    "returnValue": "0 success -1 application-wide lock present -3 internal error >0 application lock already present; mode is returned",
    "category": "functions_appl"
  },
  "application locks: overview": {
    "name": "Application locks: overview",
    "type": "function",
    "syntax": "function Application locks: overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_appl"
  },
  "application locks: synopsis": {
    "name": "Application locks: synopsis",
    "type": "function",
    "syntax": "function Application locks: synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_appl"
  },
  "artm.begin.transaction": {
    "name": "artm.begin.transaction",
    "type": "function",
    "syntax": "function long artm.begin.transaction (long artm.transaction.class.id [, long metric.type] [, void metric.value])",
    "description": "Marks the beginning of a transaction. Each time a transaction starts, artm.begin.transaction() must be called at the beginning of each transaction instance the user wants to monitor.",
    "arguments": [
      {
        "type": "long",
        "name": "artm.transaction.class.id",
        "description": "The unique identifier assigned to the transaction class. This is the id generated by artm.define.transaction.class(). If the tran.id is less than zero, this artm.begin.transaction() call will be treated as a NULL operation, and a negative transaction id is returned."
      },
      {
        "type": "[long",
        "name": "metric.type ]",
        "description": "The metrics, as defined in artm.define.transaction.class(), can be initialized here. Each metric consists of an id, which determines the type of metric, and its initial value. The value must be of the correct type. See artm.define.transaction.class() for the types. The amount of metrics must not exceed the amount as defined in artm.define.transaction.class(). The metrics must also be passed in the same sequence. It is possible to skip the metrics you don't want to pass. In that case, pass ARTM.METRIC.SKIP as the metric type, and omit the metric value. If the last metrics are of this type, you don't need to pass them at all."
      },
      {
        "type": "[void",
        "name": "metric.value ]",
        "description": ""
      }
    ],
    "returnValue": ">= 0 The transaction id. This id has to be passed to functions artm.update.transaction() and artm.end.transaction(). < 0 An error occurred in communicating with the measurement agent, or ARTM is switched off. The most likely cause is passing an invalid value for artm.transaction.class.id.",
    "category": "functions_artm"
  },
  "artm.define.transaction.class": {
    "name": "artm.define.transaction.class",
    "type": "function",
    "syntax": "function long artm.define.transaction.class (string tran.name(128), string tran.detail(128) [, long metric.type] [, string metric.name(44)])",
    "description": "Assigns a unique identifier to a transaction class, and optionally to describe the format of additional data passed on by artm.begin.transaction (), artm.update.transaction(), and the artm.end.transaction() calls. This is normally done during the initialization of the specified application. The value returned by artm.define.transaction.class() is passed as a parameter in artm.begin.transaction() calls to identify which class of transaction is starting.",
    "arguments": [
      {
        "type": "string",
        "name": "tran.name(128)",
        "description": "The unique name of a transaction class. It is defined for each transaction class by the application developer. It must be unique within the application."
      },
      {
        "type": "string",
        "name": "tran.detail(128)",
        "description": "Additional information about a transaction class. If no tran.detail is associated with this transaction, the string must be empty."
      },
      {
        "type": "[long",
        "name": "metric.type ]",
        "description": "It is possible to pass several metrics to ARTM. These metrics give information about the status of a transaction. Artm.define.transaction.class() is used to define the metrics to be used in the transaction class. Each metric consists of an id, which determines the type of metric, and a descriptive name. Five metrics can be passed at a maximum. These metrics may be chosen arbitrarily from the following list: ARTM.COUNTER (long) A counter must be used when it makes sense to add up the values over an interval. Examples are bytes printed and records written. ARTM.GAUGE (long) A gauge must be used instead of a counter when it is not meaningful to add up the values over an interval. An example is the amount of memory used. ARTM.NUMERIC (long) A numeric id is simply a numeric value that is used as an identifier, and not as a measurement value. Examples are message numbers and error codes. ARTM.CODE (string(8)) A measurement agent should process a string in the same way as a numeric id. As with numeric ids it is not meaningful to do arithmetic operations on a string value."
      },
      {
        "type": "[string",
        "name": "metric.name(44) ]",
        "description": ""
      }
    ],
    "returnValue": ">= 0 The unique transaction class id. This id has to be passed to function artm.begin.transaction() for each transaction of this class. < 0 The registering of the class failed.",
    "category": "functions_artm"
  },
  "artm.end.transaction": {
    "name": "artm.end.transaction",
    "type": "function",
    "syntax": "function long artm.end.transaction (long artm.transaction.id, long tran.status [, long metric.type] [, void metric.value])",
    "description": "Marks the end of a transaction instance that was started with artm.begin.transaction(). artm.end.transaction () should be called from the application program just after each transaction instance ends.",
    "arguments": [
      {
        "type": "long",
        "name": "artm.transaction.id",
        "description": "The unique handle from the artm.begin.transaction () call that marked the start of this transaction instance. Artm.transaction.id must be passed in each artm.end.transaction() call. Many transaction instances may be carried out at the same time from this and other applications, so this handle is essential for the measurement agent to identify which transaction instance is stopping. If artm.transaction.id is less than zero, this artm.end.transaction () call will be treated as a NULL operation, and a negative value is returned."
      },
      {
        "type": "long",
        "name": "tran.status",
        "description": "The completion code of the transaction, as determined by the application: ARTM.TRANSACTION.SUCCESS Use this value when the operation is completed normally and as expected. ARTM.TRANSACTION.ABORTED Use this value when there was a fundamental failure in the system. ARTM.TRANSACTION.FAILED Use this value in application where the transaction worked properly, but no result was generated."
      },
      {
        "type": "[long",
        "name": "metric.type ]",
        "description": "The metrics, as defined in artm.define.transaction.class(), can be updated here. Each metric consists of an id, which determines the type of metric, and its current value. The value must be of the correct type. See artm.define.transaction.class() for the types. The amount of metrics must not exceed the amount as defined in artm.define.transaction.class(). The metrics must also be passed in the same sequence. It is possible to skip the metrics you don�t want to pass. In that case, pass ARTM.METRIC.SKIP as the metric type, and omit the metric value. If the last metrics are of this type, you don�t need to pass them at all."
      },
      {
        "type": "[void",
        "name": "metric.value ]",
        "description": ""
      }
    ],
    "returnValue": ">= 0 Success < 0 An error occurred in communicating with the measurement agent, or ARTM is switched off. The most likely cause is passing an invalid value for artm.transaction.id.",
    "category": "functions_artm"
  },
  "artm.redefine.transaction.class": {
    "name": "artm.redefine.transaction.class",
    "type": "function",
    "syntax": "function long artm.redefine.transaction.class (string tran.name(128) [, long metric.type] [, string metric.name(44)])",
    "description": "Updates the metrics of a predefined session transaction class at the beginning of a session.",
    "arguments": [
      {
        "type": "string",
        "name": "tran.name(128)",
        "description": "The name of the form command function. It must be unique within the application. The 4GL-Engine determines through this name which transaction you want to redefine. Therefore, it must match the function�s name exactly."
      },
      {
        "type": "[long",
        "name": "metric.type ]",
        "description": "It is possible to pass several metrics to ARTM. These metrics give information about the status of a transaction. Artm.define.transaction.class() is used to define the metrics to be used in the transaction class. Each metric consists of an id, which determines the type of metric, and a descriptive name. Five metrics can be passed at a maximum. These metrics may be chosen arbitrarily from the following list: ARTM.COUNTER (long) A counter must be used when it makes sense to add up the values over an interval. Examples are bytes printed and records written. ARTM.GAUGE (long) A gauge must be used instead of a counter when it is not meaningful to add up the values over an interval. An example is the amount of memory used. ARTM.NUMERIC (long) A numeric id is simply a numeric value that is used as an identifier, and not as a measurement value. Examples are message numbers and error codes. ARTM.CODE (string(8)) A measurement agent should process a string in the same way as a numeric id. As with numeric ids it is not meaningful to do arithmetic operations on a string value."
      },
      {
        "type": "[string",
        "name": "metric.name(44) ]",
        "description": ""
      }
    ],
    "returnValue": ">= 0 The unique transaction class id. This id has to be passed to function artm.begin.transaction() for each transaction of this class. < 0 The registering of the class failed.",
    "category": "functions_artm"
  },
  "artm.update.transaction": {
    "name": "artm.update.transaction",
    "type": "function",
    "syntax": "function long artm.update.transaction (long artm.transaction.id [, long metric.type] [, void metric.value])",
    "description": "This function is not required, and can thus be omitted if not needed. It can be used for two purposes, namely:",
    "arguments": [
      {
        "type": "long",
        "name": "artm.transaction.id",
        "description": "The unique identifier assigned to the transaction. This is the id generated by artm.begin.transaction(). Artm.transaction.id must be passed in each artm.update.transaction() call. Many transaction instances may be carried out at the same time from this and other applications, so this handle is essential for the measurement agent to identify which transaction instance is updated. If artm.transaction.id is less than zero, this artm.update.transaction () call will be treated as a NULL operation, and a negative value is returned."
      },
      {
        "type": "[long",
        "name": "metric.type ]",
        "description": "It is possible to skip the metrics you don�t want to pass. In that case, pass ARTM.METRIC.SKIP as the metric type, and omit the metric value. If the last metrics are of this type, you don�t need to pass them at all. It is possible to skip the metrics you don�t want to pass. In that case, pass ARTM.METRIC.SKIP as the metric type, and omit the metric value. If the last metrics are of this type, you don�t need to pass them at all."
      },
      {
        "type": "[void",
        "name": "metric.value ]",
        "description": ""
      }
    ],
    "returnValue": ">= 0 Success < 0 An error occurred in communicating with the measurement agent, or ARTM is switched off. The most likely cause is passing an invalid value for artm.transaction.id.",
    "category": "functions_artm"
  },
  "application response time measurement (artm) debugging": {
    "name": "Application Response Time Measurement (ARTM) Debugging",
    "type": "function",
    "syntax": "function Application Response Time Measurement (ARTM) Debugging()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_artm"
  },
  "application response time measurement (artm) error codes": {
    "name": "Application Response Time Measurement (ARTM) Error Codes",
    "type": "function",
    "syntax": "function Application Response Time Measurement (ARTM) Error Codes()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_artm"
  },
  "application response time measurement (artm) examples": {
    "name": "Application Response Time Measurement (ARTM) Examples",
    "type": "function",
    "syntax": "function Application Response Time Measurement (ARTM) Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_artm"
  },
  "application response time measurement (artm) overview": {
    "name": "Application Response Time Measurement (ARTM) Overview",
    "type": "function",
    "syntax": "function Application Response Time Measurement (ARTM) Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_artm"
  },
  "application response time measurement (artm) synopsis": {
    "name": "Application Response Time Measurement (ARTM) Synopsis",
    "type": "function",
    "syntax": "function Application Response Time Measurement (ARTM) Synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_artm"
  },
  "asc": {
    "name": "asc",
    "type": "function",
    "syntax": "function long asc (string characters)",
    "description": "This function returns the sum of the code point values encoded in the supplied string.",
    "arguments": [
      {
        "type": "string",
        "name": "characters",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_ascii_conversion"
  },
  "ascii conversion - overview and synopsis": {
    "name": "ASCII Conversion - Overview and Synopsis",
    "type": "function",
    "syntax": "function ASCII Conversion - Overview and Synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_ascii_conversion"
  },
  "chr$": {
    "name": "chr$",
    "type": "function",
    "syntax": "function string chr$ (long code)",
    "description": "This function returns a single character string corresponding to the supplied code point.",
    "arguments": [
      {
        "type": "long",
        "name": "code",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_ascii_conversion"
  },
  "audit information overview": {
    "name": "Audit Information Overview",
    "type": "function",
    "syntax": "function Audit Information Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "audit information sample program": {
    "name": "Audit Information Sample Program",
    "type": "function",
    "syntax": "function Audit Information Sample Program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "audit information synopsis": {
    "name": "Audit Information Synopsis",
    "type": "function",
    "syntax": "function Audit Information Synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "aud_close_audit": {
    "name": "aud_close_audit",
    "type": "function",
    "syntax": "function long aud_close_audit (long seqid)",
    "description": "Discards the specified sequence identifier. seqid is the identifier returned by aud_open_audit() aud_open_audit when the particular sequence file was opened. When the last sequence file associated with an info file is closed, the info file is also closed.",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": ""
      }
    ],
    "returnValue": "0 success -1 error (for example, could not close the sequence file or info file).",
    "category": "functions_aud"
  },
  "aud_get_audit_dd": {
    "name": "aud_get_audit_dd",
    "type": "function",
    "syntax": "function void aud_get_audit_dd (const string seqhdr(), ref string colnames(,), ref long colinfo(,))",
    "description": "This retrieves the audit data dictionary information from the sequence header of a particular sequence file.",
    "arguments": [
      {
        "type": "const string",
        "name": "seqhdr()",
        "description": "The buffer containing the sequence header. You fill this by calling aud_read_seq_hdr() or aud_read_info_seq_hdr() ."
      },
      {
        "type": "ref string",
        "name": "colnames(,)",
        "description": "An array containing the names of the audited fields. This array must be allocated dynamically."
      },
      {
        "type": "ref long",
        "name": "colinfo(,)",
        "description": "An array containing the data dictionary information for the audited fields. This array must be allocated dynamically. The information for the n -th audited field can be interpreted as follows: colinfo(AUD_FLD_TYPE, n) contains the field type; for example: DB.LONG, DB.FLOAT . See this list of database types . colinfo(AUD_FLD_DEPT, n) contains the field depth; for non-array fields this is always 1. colinfo(AUD_FLD_LEN, n) contains the field length; See this list of database types and related byte counts . The length of fields of type DB.TIME depends on the TIV level of the porting set which generated the sequence file. If this TIV level is less than 2000, then DB.TIME fields have length 4 and the field contains a UTC long format value in Utc32 layout. If this TIV level is at least 2000, then DB.TIME fields have length 5 and the field contains a UTC long format value in Utc40 layout."
      }
    ],
    "returnValue": "",
    "category": "functions_aud"
  },
  "aud_get_col_info": {
    "name": "aud_get_col_info",
    "type": "function",
    "syntax": "function void aud_get_col_info (const string seqhdr(), long col_no, ref string col_name(), ref long col_type, ref long col_dep, ref long col_len)",
    "description": "This retrieves information about a specified field from the sequence header of a particular sequence file. It retrieves the same information as aud_get_audit_dd() , but for a single field only.",
    "arguments": [
      {
        "type": "const string",
        "name": "seqhdr()",
        "description": "The buffer containing the sequence header. You fill this by calling aud_read_seq_hdr() or aud_read_info_seq_hdr() ."
      },
      {
        "type": "long",
        "name": "col_no",
        "description": "The column number."
      },
      {
        "type": "ref string",
        "name": "col_name()",
        "description": "The field name."
      },
      {
        "type": "ref long",
        "name": "col_type",
        "description": "The field type � for example, DB.LONG, DB.STRING. See this list of database types ."
      },
      {
        "type": "ref long",
        "name": "col_dep",
        "description": "The field depth. This is always 1 for non-array fields."
      },
      {
        "type": "ref long",
        "name": "col_len",
        "description": "The field length. See this list of database types and related byte counts . The length of fields of type DB.TIME depends on the TIV level of the porting set which generated the sequence file. If this TIV level is less than 2000, then DB.TIME fields have length 4 and the field contains a UTC long format value in Utc32 layout. If this TIV level is at least 2000, then DB.TIME fields have length 5 and the field contains a UTC long format value in Utc40 layout."
      }
    ],
    "returnValue": "",
    "category": "functions_aud"
  },
  "aud_get_fld_values": {
    "name": "aud_get_fld_values",
    "type": "function",
    "syntax": "function long aud_get_fld_values (long colno, const long colinfo, const string rec_buff(), ref string values(,))",
    "description": "This retrieves the values of a specified field from an audit record. You can use this for records of type insert, delete, and update only. For records of type insert and delete, you can retrieve the values of any field. For records of type update, you can retrieve the values of changed fields and primary key fields only.",
    "arguments": [
      {
        "type": "long",
        "name": "colno",
        "description": "The column number."
      },
      {
        "type": "const long",
        "name": "colinfo",
        "description": "An array containing the audit DD of the sequence file that contains the audit record. You fill this by calling aud_get_audit_dd()"
      },
      {
        "type": "const string",
        "name": "rec_buff()",
        "description": "The buffer containing the audit record. You fill this by calling aud_read_audit_rec() or aud_read_next_audit_rec() ."
      },
      {
        "type": "ref string",
        "name": "values(,)",
        "description": "An array containing the field values in string format. There are two string elements, the first containing the old value of the field, the second containing the new value. For example: values(1,1) old value values(2,1) new value The size of the both elements is determined by the predefined constant AUD_MAX_FLD_SIZE."
      }
    ],
    "returnValue": "0 Record of type insert or delete. In these cases, there is no new value. Only values (1,1) is relevant. 1 Record of type update. Both old and new values are relevant. -1 Error. Possibly invalid column number or record not of type insert, delete, or update.",
    "category": "functions_aud"
  },
  "aud_get_hdr_size": {
    "name": "aud_get_hdr_size",
    "type": "function",
    "syntax": "function long aud_get_hdr_size (long seqid)",
    "description": "Because the audit DD of a table can differ in different sequence files, the size of the sequence header can also differ from sequence file to sequence file.",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": ""
      }
    ],
    "returnValue": ">0 Sequence header size (in bytes) -1 Error; probably invalid seqid",
    "category": "functions_aud"
  },
  "aud_get_info_seq_hdr_size": {
    "name": "aud_get_info_seq_hdr_size",
    "type": "function",
    "syntax": "function long aud_get_info_seq_hdr_size (long seqid, long seqno)",
    "description": "Because the audit DD of a table can differ in different sequence files, the size of the sequence header can also differ from sequence file to sequence file.",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "long",
        "name": "seqno",
        "description": "The sequence number of the sequence file."
      }
    ],
    "returnValue": ">0 length of the sequence file header -1 Error; Possible reasons are: Error occurred while opening sequence file Open file limit reached",
    "category": "functions_aud"
  },
  "aud_open_audit": {
    "name": "aud_open_audit",
    "type": "function",
    "syntax": "function long aud_open_audit (const string host_name(), const string table_name(), long compno, long seqno)",
    "description": "This opens a specified sequence file. You identify the file to open by the table/company combination with which it is associated, the host on which it is located, and the sequence file number. The function returns a unique identifier for the file. Other audit functions use this identifier (referred to as the sequence identifier) to refer to this particular sequence file.",
    "arguments": [
      {
        "type": "const string",
        "name": "host_name()",
        "description": "The name of the host on which the sequence file is to be accessed. You can use aud_select_host() to select the host to be used. If this argument is an empty string, aud_select_host() is called automatically to select a host name."
      },
      {
        "type": "const string",
        "name": "table_name()",
        "description": "The name of the table with which the sequence file is associated. This takes the form ppmmfff , where pp is the package code, mmm is the module code, and fff is the file number."
      },
      {
        "type": "long",
        "name": "compno",
        "description": "The company number."
      },
      {
        "type": "long",
        "name": "seqno",
        "description": "The number of the particular sequence file to open."
      }
    ],
    "returnValue": ">0 Sequence id for file -1 Error; Possible reasons are: Table or sequence file does not exist Error occurred while opening sequence file Open file limit reached",
    "category": "functions_aud"
  },
  "aud_read_audit_rec": {
    "name": "aud_read_audit_rec",
    "type": "function",
    "syntax": "function long aud_read_audit_rec (long seqid, long rec_no, ref string rec_buff())",
    "description": "This retrieves a specified audit record from the current transaction. You can use aud_read_next_audit_rec() to retrieve the next and subsequent records from the transaction. You can access information in the audit record using the Macros - transaction record .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "long",
        "name": "rec_no",
        "description": "The number of the audit record within the transaction. Specify 1 to retrieve the first audit record, 2 to retrieve the second, and so on."
      },
      {
        "type": "ref string",
        "name": "rec_buff()",
        "description": "A buffer containing the actual audited record. The predefined constant AUD_MAX_REC_SIZE holds the size of this buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Possible reasons are: seqid does not exist rec_no does not exist",
    "category": "functions_aud"
  },
  "aud_read_info_hdr": {
    "name": "aud_read_info_hdr",
    "type": "function",
    "syntax": "function long aud_read_info_hdr (const string host_name(), const string table_name(), long compno, ref string info_hdr())",
    "description": "This retrieves the header of the info file associated with a specified table and company number combination. You can access information in the info header using the Macros - info header .",
    "arguments": [
      {
        "type": "const string",
        "name": "host_name()",
        "description": ""
      },
      {
        "type": "const string",
        "name": "table_name()",
        "description": "The name of the table with which the info file is associated. This takes the form ppmmfff , where pp is the package code, mmm is the module code, and fff is the file number."
      },
      {
        "type": "long",
        "name": "compno",
        "description": "The company number."
      },
      {
        "type": "ref string",
        "name": "info_hdr()",
        "description": "The buffer in which the info header is stored. The info header size is fixed. The predefined constant AUD_INFO_HDR_SIZE holds the size of the buffer."
      }
    ],
    "returnValue": ">0 Success -1 Error; Possible reasons are: host not found info file not found error opening info file info file locked unable to unlock file after read action unable to close info file",
    "category": "functions_aud"
  },
  "aud_read_info_seq_hdr": {
    "name": "aud_read_info_seq_hdr",
    "type": "function",
    "syntax": "function long aud_read_info_seq_hdr (long seqid, long seqno, ref string seqhdr)",
    "description": "This reads the header information for a particular sequence file from the associated info file. You can access information in the sequence header using the Macros - sequence header .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "long",
        "name": "seqno",
        "description": "The sequence number of the sequence file."
      },
      {
        "type": "ref string",
        "name": "seqhdr",
        "description": "The buffer in which the sequence header information is stored. Use aud_get_hdr_size() or aud_get_info_seq_hdr_size() to retrieve the size of this buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Probably invalid seqid .",
    "category": "functions_aud"
  },
  "aud_read_next_audit_rec": {
    "name": "aud_read_next_audit_rec",
    "type": "function",
    "syntax": "function long aud_read_next_audit_rec (long seqid, ref string rec_buff)",
    "description": "This reads the next audited record from the current transaction. You can use aud_read_audit_rec() to read a specific audit record and then use aud_read_next_audit_rec() to read the next and subsequent records. You can access information in the audited record using the Macros - transaction record",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "ref string",
        "name": "rec_buff",
        "description": "A buffer containing the actual audited record. The predefined constant AUD_MAX_REC_SIZE holds the size of the buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Possible reasons are: seqid does not exist no more records in the current transaction of the specified sequence file",
    "category": "functions_aud"
  },
  "aud_read_next_tran": {
    "name": "aud_read_next_tran",
    "type": "function",
    "syntax": "function long aud_read_next_tran (long seqid, ref string tran_hdr())",
    "description": "This reads the next transaction header in the specified sequence file. You can use aud_read_tran() to read a specific transaction header and then use aud_read_next_tran() to read the next and subsequent transaction headers. You can access information in the transaction header using the Macros - transaction header .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "ref string",
        "name": "tran_hdr()",
        "description": "A buffer containing the transaction header information. The predefined constant AUD_TRAN_HDR_SIZE holds the size of this buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Possible reasons are: seqid does not exist No more transactions in the sequence file.",
    "category": "functions_aud"
  },
  "aud_read_seq_hdr": {
    "name": "aud_read_seq_hdr",
    "type": "function",
    "syntax": "function long aud_read_seq_hdr (long seqid, ref string seqhdr)",
    "description": "This retrieves the header information from a specified sequence file. You can access information in the sequence header with the Macros - sequence header .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "ref string",
        "name": "seqhdr",
        "description": "The buffer in which the sequence header information is stored. Use aud_get_hdr_size() or aud_get_info_seq_hdr_size() to retrieve the size of this buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Probably invalid seqid",
    "category": "functions_aud"
  },
  "aud_read_tran": {
    "name": "aud_read_tran",
    "type": "function",
    "syntax": "function long aud_read_tran (long seqid, long tran_no, ref string tran_hdr())",
    "description": "This reads a specified transaction header from a specified sequence file. You can use aud_read_tran() to read a specific transaction header and then use aud_read_next_tran() to read the next and subsequent transaction headers. You can access information in the transaction header with the Macros - transaction header .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "long",
        "name": "tran_no",
        "description": "The number of the required transaction within the sequence file. Specify 1 to read the header for the first transaction in the sequence file, specify 2 to read the header for the second transaction, and so on."
      },
      {
        "type": "ref string",
        "name": "tran_hdr()",
        "description": "A buffer containing the transaction header information. The predefined constant AUD_TRAN_HDR_SIZE holds the size of this buffer."
      }
    ],
    "returnValue": "0 Success -1 Error; Possible reasons are: seqid does not exist Transaction does not exist",
    "category": "functions_aud"
  },
  "aud_select_host": {
    "name": "aud_select_host",
    "type": "function",
    "syntax": "function long aud_select_host (const string table_name(), long compno, long user_interaction, ref string host_name())",
    "description": "Audit files can be located on more than one host (for example, on the local host and a remote host, or on two or more remote hosts). The system maintains a list of hosts where audit files for particular table and company number combinations are located. When accessing audit files, this host list is used to select the particular host on which the files are to be accessed.",
    "arguments": [
      {
        "type": "const string",
        "name": "table_name()",
        "description": "The name of the table for which audit files are to be accessed. This takes the form ppmmfff , where pp is the package code, mmm is the module code, and fff is the file number."
      },
      {
        "type": "long",
        "name": "compno",
        "description": "The company number."
      },
      {
        "type": "long",
        "name": "user_interaction",
        "description": "Specifies whether or not user interaction is required. Possible values are: USR_INTACTION_YES If there is more than one host in the host list for the specified table and company number, the user is prompted to select the host to be used. The function then returns the name of that host. If there is only one host in the list, that host is returned automatically, without user interaction."
      }
    ],
    "returnValue": ">=0 Success -1 Error; Possibly unable to find host list or auditing not enabled for the specified table and company.",
    "category": "functions_aud"
  },
  "aud_update_infofile": {
    "name": "aud_update_infofile",
    "type": "function",
    "syntax": "function long aud_update_infofile (long seqid, const string seqhdr)",
    "description": "This writes sequence header information to the info file associated with the specified sequence file. You can set the information for the sequence header with the Macros - sequence header",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "const string",
        "name": "seqhdr",
        "description": "The buffer that contains the sequence header information."
      }
    ],
    "returnValue": "0 Success -1 Error; Possible reasons are: Error occurred while opening the information file Open file limit reached Incorrect sequence identifier",
    "category": "functions_aud"
  },
  "aud_write_info_hdr": {
    "name": "aud_write_info_hdr",
    "type": "function",
    "syntax": "function long aud_write_info_hdr (long host_name(), string table_name(), long compno, const string info_hdr)",
    "description": "This writes info header information to a specified info file. You can set the information for the info header with the Macros - info header",
    "arguments": [
      {
        "type": "long",
        "name": "host_name()",
        "description": ""
      },
      {
        "type": "string",
        "name": "table_name()",
        "description": "The name of the table with which the info file is associated. This takes the form ppmmfff , where pp is the package code, mmm is the module code, and fff is the file number."
      },
      {
        "type": "long",
        "name": "compno",
        "description": "The company number."
      },
      {
        "type": "const string",
        "name": "info_hdr",
        "description": "The buffer that contains the header information to be written to the info file."
      }
    ],
    "returnValue": ">0 Success -1 Error; Possible reasons are: Host not found Table or information file does not exist Error occurred while opening information file Open file limit reached",
    "category": "functions_aud"
  },
  "aud_write_seq_hdr": {
    "name": "aud_write_seq_hdr",
    "type": "function",
    "syntax": "function long aud_write_seq_hdr (long seqid, const string seqhdr())",
    "description": "This writes header information to a specified sequence file. You can set the information for the sequence header with the Macros - sequence header .",
    "arguments": [
      {
        "type": "long",
        "name": "seqid",
        "description": "The sequence identifier returned by aud_open_audit() when the sequence file was opened."
      },
      {
        "type": "const string",
        "name": "seqhdr()",
        "description": "The buffer that contains the header information to be written to the sequence file."
      }
    ],
    "returnValue": "0 Success -1 Error; Probably incorrect seqid .",
    "category": "functions_aud"
  },
  "macros - dates and times": {
    "name": "Macros - dates and times",
    "type": "function",
    "syntax": "function Macros - dates and times()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "macros - info header": {
    "name": "Macros - info header",
    "type": "function",
    "syntax": "function Macros - info header()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "macros - sequence header": {
    "name": "Macros - sequence header",
    "type": "function",
    "syntax": "function Macros - sequence header()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "macros - transaction dates and times": {
    "name": "Macros - transaction dates and times",
    "type": "function",
    "syntax": "function Macros - transaction dates and times()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "macros - transaction header": {
    "name": "Macros - transaction header",
    "type": "function",
    "syntax": "function Macros - transaction header()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "macros - transaction record": {
    "name": "Macros - transaction record",
    "type": "function",
    "syntax": "function Macros - transaction record()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_aud"
  },
  "aud.audit.is.on.for.table": {
    "name": "aud.audit.is.on.for.table",
    "type": "function",
    "syntax": "function boolean aud.audit.is.on.for.table (const string table.code(), long company)",
    "description": "This function checks whether audit is on for a specific database table.",
    "arguments": [
      {
        "type": "const string",
        "name": "table.code()",
        "description": "The table for which auditing must be checked."
      },
      {
        "type": "long",
        "name": "company",
        "description": "The physical company of the table. The physical company number must be used, because the audit trail is created per physical company. For a logical table, the physical company can be retrieved using function db.get.physical.compnr()"
      }
    ],
    "returnValue": "True Audit is on for the specified table. False Audit is not on for the specified table, or an error occurred.",
    "category": "functions_audtr"
  },
  "aud.close.selection": {
    "name": "aud.close.selection",
    "type": "function",
    "syntax": "function long aud.close.selection (long selection.id)",
    "description": "The opening of the audit trail is not done explicitly in comparison to the low-level audit library functions. To close the opened files again, the developer must use the aud.close.selection. During the invocation of aud.select.transactions() and all functions beginning with aud.get.next, each file that is opened but not closed will be registered within the Infor ERP Enterprise Audit Management. The function aud.close.selection() will use this information to close the files that are registered as being open. The function also closes the selection of transactions that have been created using the aud.select.transactions function.",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions() ."
      }
    ],
    "returnValue": "AUD_OK All files are closed successfully and the dynamic SQL selection is also closed successfully AUD_INCORRECT_SELECTION_ID Selection.id is invalid. AUD_FAIL Not all files could be closed or the dynamic SQL statement is not closed successfully.",
    "category": "functions_audtr"
  },
  "aud.get.field.ids": {
    "name": "aud.get.field.ids",
    "type": "function",
    "syntax": "function long aud.get.field.ids (long selection.id, long table.id, long number.of.fields, const string field.names(,), ref long field.ids())",
    "description": "aud.get.next.action() stores the contents of the action row internally: old value, new value and status of each field. To retrieve this information, the application needs to have a reference for each field. These references are called field ids. Only when the meta data is changed do the field ids change, so only in such a case does this function have to be used. This function also enables the user to filter only those fields that are relevant to the application by means of a field.names array. This array contains the field names for which an id has to be retrieved.",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions()"
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, which is used to retrieve the detailed action data using function aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "long",
        "name": "number.of.fields",
        "description": "The number of fields specified in the field.names array."
      },
      {
        "type": "const string",
        "name": "field.names(,)",
        "description": "An array that contains one or more fields of the table."
      },
      {
        "type": "ref long",
        "name": "field.ids()",
        "description": "An array that contains an index for each field in the field.names array. If the field is not in the audit trail data, the index is 0. These ids can be used in function aud.get.field.info() , aud.get.field.status(), aud.put.old.field.value() and aud.put.new.field.value()."
      }
    ],
    "returnValue": "AUD_INCORRECT_SELECTION_ID Selection.id is invalid. AUD_INCORRECT_TABLE_ID Table.Id is invalid. AUD_OK The meta data information was retrieved successfully. Note: if one or more field.ids are 0, this function will still return. AUD_FAIL The meta data information could not be found.",
    "category": "functions_audtr"
  },
  "aud.get.field.info": {
    "name": "aud.get.field.info",
    "type": "function",
    "syntax": "function void aud.get.field.info (long selection.id, long table.id, long field.id, ref long field.depth, ref long field.type, ref long field.length)",
    "description": "Returns the format of the field at the time it was audited. The information consists of the type, the depth and the size of the field. This function will not check the input, because of performance reasons. Instead the combination selection.id , table.id , field.id is assumed to refer to an existing field, as returned by aud.get.field.ids() . This means that if the input parameters are not valid, an error message will be presented to the end user",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions() ."
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, which is used to retrieve the detailed action data using function aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "long",
        "name": "field.id",
        "description": "Identifier for a field, as retrieved using the functions aud.get.field.ids() or aud.get.field.list(). Precondition: field.id should not be 0: for not existing fields no field information can be retrieved."
      },
      {
        "type": "ref long",
        "name": "field.depth",
        "description": "Depth of the field: 1 for non array fields, > for array fields"
      },
      {
        "type": "ref long",
        "name": "field.type",
        "description": "Data type of the field, for example db.long, db.double, db.string, db.multibyte and so on. See this list of database types ."
      },
      {
        "type": "ref long",
        "name": "field.length",
        "description": "Length of the field in the action row string. The field.length specifies the number of characters to be extracted from the old value or the new value string. See this list of database types and related byte counts . The length of fields of type DB.TIME depends on the TIV level of the porting set which audited the transaction. If this TIV level is less than 2000, then DB.TIME fields have length 4 and the field contains a UTC long format value in Utc32 layout. If this TIV level is at least 2000, then DB.TIME fields have length 5 and the field contains a UTC long format value in Utc40 layout."
      }
    ],
    "returnValue": "None",
    "category": "functions_audtr"
  },
  "aud.get.field.list": {
    "name": "aud.get.field.list",
    "type": "function",
    "syntax": "function long aud.get.field.list (long selection.id, long table.id, ref string field.names(,))",
    "description": "Use this function to get the field names of all fields logged for a database table in the audit trail. This function is especially useful if the user is not aware or interested in the table fields but simply needs the names of all fields. In this case the user uses the aud.get.number.of.fields() to determine how many fields are available and also uses aud.get.field.list() to obtain the field ids for each field. The information of these two function can be used to further retrieve field info as well as the value of the field using the functions: aud.get.field.info() , aud.get.field.status() and aud.put.old.field.value() and aud.put.new.field.value() .",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions() ."
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, as provided by the aud.get.next.action function. The table.id is used to retrieve the detailed action data using function aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "ref string",
        "name": "field.names(,)",
        "description": "An array that contains the fields of the table. Note: the number of elements in this array is equal to the number.of.fields returned by function aud.get.number.of.fields()"
      }
    ],
    "returnValue": "AUD_INCORRECT_SELECTION_ID Selection.id is invalid. AUD_INCORRECT_TABLE_ID Table.Id is invalid. AUD_OK Names of all fields can be determined",
    "category": "functions_audtr"
  },
  "aud.get.field.status": {
    "name": "aud.get.field.status",
    "type": "function",
    "syntax": "function string aud.get.field.status (long selection.id, long table.id, long field.id)",
    "description": "Retrieves the status of a field in a database action (insert, update or delete).",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions"
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, which is used to retrieve the detailed action data using function aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "long",
        "name": "field.id",
        "description": "Identifier for a field, as retrieved using the functions aud.get.field.ids() or aud.get.field.list(). Note: if field.id = 0 (the field does not exist) status \"X\" is returned."
      }
    ],
    "returnValue": "See description.",
    "category": "functions_audtr"
  },
  "aud.get.next.action": {
    "name": "aud.get.next.action",
    "type": "function",
    "syntax": "function long aud.get.next.action (long selection.id, ref long table.id, ref long company, ref string table.code, ref bool meta.data.changed, ref long current.action.number, ref string action.type)",
    "description": "Determines and reads the next action from the list of tables that was constructed by the aud.get.next.transaction() function.",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions()"
      },
      {
        "type": "ref long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred that is used to retrieve the detailed action data using functions aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "ref long",
        "name": "company",
        "description": "Infor ERP Enterprise company that contains the table on which the database action was done."
      },
      {
        "type": "ref string",
        "name": "table.code",
        "description": "The code of the updated database table"
      },
      {
        "type": "ref bool",
        "name": "meta.data.changed",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "current.action.number",
        "description": "Sequence number of the action within the transaction."
      },
      {
        "type": "ref string",
        "name": "action.type",
        "description": "A character that specifies the type of action retrieved. The string contains an 'I' for inserting a row, 'U' for updating a row and a 'D' for deleting a row. For table operations the string contains a 'C' for creating a table, 'L' for clearing a table and 'R' for dropping a table."
      }
    ],
    "returnValue": "AUD_OK Next transaction in the selection is determined and transaction header data is retrieved AUD_FAIL The transaction data could not be retrieved AUD_NO_MORE_ACTIONS There are no more transactions in the selection",
    "category": "functions_audtr"
  },
  "aud.get.next.transaction": {
    "name": "aud.get.next.transaction",
    "type": "function",
    "syntax": "function long aud.get.next.transaction (long selection.id, long number.of.retries, long retry.interval, ref string transaction.id, ref long commit.time, ref string session, ref string user)",
    "description": "After the transactions to be selected have been specified using aud.select.transactions() the next step is to retrieve the audit data from the audit trail. The retrieved audit data can be processed in combination with the acquired meta data. The aud.get.next.transaction function fetches the next transaction data based on the selection defined with the aud.select.transactions() function. When a transaction is read successfully, the function returns the transaction header, consisting of transaction.id , commit.time , session and user .",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selected transactions returned by aud.select.transactions() ."
      },
      {
        "type": "long",
        "name": "number.of.retries",
        "description": ""
      },
      {
        "type": "long",
        "name": "retry.interval",
        "description": "Number of milliseconds to wait before doing a retry to retrieve the data."
      },
      {
        "type": "ref string",
        "name": "transaction.id",
        "description": "Id of the transaction, as read from the audit trail."
      },
      {
        "type": "ref long",
        "name": "commit.time",
        "description": "The commit date and time of the next transaction (UTC format)."
      },
      {
        "type": "ref string",
        "name": "session",
        "description": "The code of the session that is responsible for the transaction."
      },
      {
        "type": "ref string",
        "name": "user",
        "description": "The Infor ERP Enterprise user code of the user who is responsible for the transaction."
      }
    ],
    "returnValue": "AUD_OK Next transaction could be determined and transaction header data is retrieved successfully AUD_FAIL An error occured when trying to retrieve the transaction data AUD_NO_MORE_TRANSACTIONS If there are no more transactions that meet the selection criteria defined, using function aud.select.transactions, the function returns NO_MORE_TRANSACTIONS.",
    "category": "functions_audtr"
  },
  "aud.get.number.of.fields": {
    "name": "aud.get.number.of.fields",
    "type": "function",
    "syntax": "function long aud.get.number.of.fields (long selection.id, long table.id, ref long number.of.fields)",
    "description": "Use this function to determine the number of fields, read from the data dictionary, that are stored in the sequence files. This function is especially useful if the user is not aware or interested in the table fields but simply needs to pick up the value of all fields. In this situation the user uses this function together with the aud.get.field.list() to read all the information of all fields.",
    "arguments": [
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions()"
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred as provided by the aud.get.next.action() . The table.id is used to retrieve the detailed action data using function aud.get.field.status() , aud.put.old.field.value() , and aud.put.new.field.value() . This id is also used to get the meta data information, in case it has been changed."
      },
      {
        "type": "ref long",
        "name": "number.of.fields",
        "description": "The number of fields logged in the audit trail for the specified table. This can be used to run the function aud.get.field.list() ."
      }
    ],
    "returnValue": "AUD_INCORRECT_SELECTION_ID is invalid. AUD_INCORRECT_TABLE_ID is invalid. AUD_OK The number of fields can be retrieved.",
    "category": "functions_audtr"
  },
  "aud.put.new.field.value": {
    "name": "aud.put.new.field.value",
    "type": "function",
    "syntax": "function void aud.put.new.field.value (long pid, string variable.name, long selection.id, long table.id, long field.id, long element [, bool endian])",
    "description": "Use aud.put.new.field.value to retrieve the value of a field from the new value string. The retrieved value is put into the variable supplied by the application.",
    "arguments": [
      {
        "type": "long",
        "name": "pid",
        "description": "Id of the current process. This must be filled in the same manner as the Infor ERP Enterprise function put.var()."
      },
      {
        "type": "string",
        "name": "variable.name",
        "description": "The name of the variable that will contain the extracted field value."
      },
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions"
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, which is used to retrieve the detailed action data using function aud.get.field.status, aud.put.old.field.value and aud.put.new.field.value. This id is also used to get the meta data information, in case it has been changed.company: the company that holds the updated table."
      },
      {
        "type": "long",
        "name": "field.id",
        "description": "Identification of the field as retrieved using function aud.get.field.ids. Precondition: field.id must not be 0: for not existing fields no field information can be retrieved. ( action.type = 'I' and FieldStatus = 'A') or ( action.type = 'U' and FieldStatus = ('Y' or 'N'))."
      },
      {
        "type": "long",
        "name": "element",
        "description": "Identification of the array element within a field."
      },
      {
        "type": "[bool",
        "name": "endian ]",
        "description": "Defines how the data in element must be interpreted. It is assumed that data is stored in big endian order (highest byte first) . If little endian order is required set this optional argument to 1."
      }
    ],
    "returnValue": "None",
    "category": "functions_audtr"
  },
  "aud.put.old.field.value": {
    "name": "aud.put.old.field.value",
    "type": "function",
    "syntax": "function void aud.put.old.field.value (long pid, string variable.name, long selection.id, long table.id, long field.id, long element [, bool endian])",
    "description": "Use aud.put.old.field.value to retrieve the value of a field from the old (new) value string. The retrieved value is put into the variable supplied by the application.",
    "arguments": [
      {
        "type": "long",
        "name": "pid",
        "description": "Id of the current process. This must be filled in the same manner as the Infor ERP Enterprise function put.var()."
      },
      {
        "type": "string",
        "name": "variable.name",
        "description": "The name of the variable that will contain the extracted field value."
      },
      {
        "type": "long",
        "name": "selection.id",
        "description": "Id of the selection, as provided by aud.select.transactions"
      },
      {
        "type": "long",
        "name": "table.id",
        "description": "Id of the table on which the action occurred, which is used to retrieve the detailed action data using function aud.get.field.status, aud.put.old.field.value and aud.put.new.field.value. This id is also used to get the meta data information, in case it has been changed.company: the company that holds the updated table."
      },
      {
        "type": "long",
        "name": "field.id",
        "description": "Identification of the field as retrieved using function aud.get.field.ids. Precondition: field.id must not be 0: for not existing fields no field information can be retrieved. ( action.type = 'D' and FieldStatus = 'A') or ( action.type = 'U' and FieldStatus = ('Y' or 'N'))."
      },
      {
        "type": "long",
        "name": "element",
        "description": "Identification of the array element within a field."
      },
      {
        "type": "[bool",
        "name": "endian ]",
        "description": "Defines how the data in element must be interpreted. It is assumed that data is stored in big endian order (highest byte first) . If little endian order is required set this optional argument to 1."
      }
    ],
    "returnValue": "None",
    "category": "functions_audtr"
  },
  "aud.select.transactions": {
    "name": "aud.select.transactions",
    "type": "function",
    "syntax": "function long aud.select.transactions (long nr.tables, const string table.codes(,), const long companies(), const string selection.criteria, ref long selection.id)",
    "description": "Before transactional data can be read from the audit trail the developer has to select the transactions. This function selects transactions from the audit trail using a list of tables and, if required, some additional selection criteria. The selection.criteria is given in a SQL 'where' like fashion and is used to filter the desired transactions.",
    "arguments": [
      {
        "type": "long",
        "name": "nr.tables",
        "description": "The number of tables for which transaction data must be selected. This must be greater than 0."
      },
      {
        "type": "const string",
        "name": "table.codes(,)",
        "description": "An array containing the tables for which transaction data must be selected. This array must have at least nr.tables elements."
      },
      {
        "type": "const long",
        "name": "companies()",
        "description": "An array containing the company for each table in the table.codes array. This array must have at least nr.tables elements. The physical company number must be used, because the audit trail is created per physical company. For a logical table, the physical company can be retrieved using function db.get.physical.compnr()."
      },
      {
        "type": "const string",
        "name": "selection.criteria",
        "description": "A string that holds the where clause for the selection. This string may be empty, in which case you will select all transaction data for the specified tables."
      },
      {
        "type": "ref long",
        "name": "selection.id",
        "description": "Id of the prepared selection of transactions. This value can be used in subsequent function calls to functions like aud.get.next.transaction()."
      }
    ],
    "returnValue": "AUD_OK Success. AUD_NO_TABLES No tables are specified. AUD_NO_AUDIT The specified tables/companies are not valid, or audit is not on for one of the tables. AUD_INCORRECT_SELECTION The selection.criteria is not valid. AUD_TOO_BIG Too many tables, too many different companies, or a very long selection.criteria string are specified. AUD_MULTI_COMPANY The companies array contains multiple different companies, but the system setup doesn't allow simultaneous selection of transaction data for those companies. AUD_FAIL The selection.criteria is not valid.",
    "category": "functions_audtr"
  },
  "audit management examples": {
    "name": "Audit management examples",
    "type": "function",
    "syntax": "function Audit management examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_audtr"
  },
  "audit management overview": {
    "name": "Audit management overview",
    "type": "function",
    "syntax": "function Audit management overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_audtr"
  },
  "audit management synopsis": {
    "name": "Audit management synopsis",
    "type": "function",
    "syntax": "function Audit management synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_audtr"
  },
  "bc.decode": {
    "name": "bc.decode",
    "type": "function",
    "syntax": "function long bc.decode (const string encoded.barcode, ref long bytes.read [, ref long xmlid])",
    "description": "Use this function to decode the output of bc$() function.",
    "arguments": [
      {
        "type": "const string",
        "name": "encoded.barcode",
        "description": "The input string, which typically contains the output of the bc$() function."
      },
      {
        "type": "ref long",
        "name": "bytes.read",
        "description": "The number of bytes read from the input buffer."
      },
      {
        "type": "[ref long",
        "name": "xmlid ]",
        "description": "The decoded output in XML form. If no xmlid is provided, the encoded barcode string is not validated."
      }
    ],
    "returnValue": "Returns zero upon success, non-zero otherwise. If an xmlid argument is supplied, then xmlid contains an XML document upon success. When finished, use xmlDelete to free the returned XML document from memory. In case of error return, the xmlid argument value is always zero. The function will return with an error if an xmlid was provided and the encoded input contains an invalid barcode string. In case of error return, the bytes.read argument is set if the input was a barcode, even if the encoded input encapsulated an invalid barcode string.",
    "category": "functions_barcodes"
  },
  "bc$": {
    "name": "bc$",
    "type": "function",
    "syntax": "function string bc$ (long type, long rows, string barcode, long options)",
    "description": "Use this to create a barcode of the specified type.",
    "arguments": [
      {
        "type": "long",
        "name": "type",
        "description": "barcode type. The mapping to a type depends on the used client. For BWPrint the type is a number in the range 1-1000 for a 1D-barcode and 1001-2000 for a 2D-barcode."
      },
      {
        "type": "long",
        "name": "rows",
        "description": "The height of the barcode, as a number of lines."
      },
      {
        "type": "string",
        "name": "barcode",
        "description": "The string (or binary data) that must be converted to a barcode."
      },
      {
        "type": "long",
        "name": "options",
        "description": "Options for the barcode, see below"
      }
    ],
    "returnValue": "The returned data is an encoded string. In case of error, the return value is an empty string. The returned string should not be modified. Truncation or modification of this return value will result in undefined behavior if the value is interpreted (e.g. by BwPrint).",
    "category": "functions_barcodes"
  },
  "base64.decode": {
    "name": "base64.decode",
    "type": "function",
    "syntax": "function long base64.decode (string data.in, ref string data.out)",
    "description": "Decodes the Base64 encoded input to binary output.",
    "arguments": [
      {
        "type": "string",
        "name": "data.in",
        "description": "String with Base64 encoded input. All non-Base64 characters are skipped, including null-characters and unexpected padding characters (=)."
      },
      {
        "type": "ref string",
        "name": "data.out",
        "description": "String which will receive the binary output."
      }
    ],
    "returnValue": "The size of the binary output is returned. If this value is greater than the size of data.out, then the output is completely filled with binary output, but that is less than the complete decoded version of the Base64 encoded input. To compute the size of the binary output, it is not enough to know the size of the Base64 encoded input, because all unexpected input characters are skipped. For each four not skipped Base64 encoded input characters, normally three binary output bytes are produced. However, when these four characters end with a single padding character (=), then two output bytes are produced, and when they end with two padding characters (==), then one output byte is produced.",
    "category": "functions_base64"
  },
  "base64.encode": {
    "name": "base64.encode",
    "type": "function",
    "syntax": "function long base64.encode (string data.in, ref string data.out)",
    "description": "Encodes the binary input to Base64 encoded output.",
    "arguments": [
      {
        "type": "string",
        "name": "data.in",
        "description": "String with binary input."
      },
      {
        "type": "ref string",
        "name": "data.out",
        "description": "String which will receive the Base64 encoded output. The output is NOT null-terminated."
      }
    ],
    "returnValue": "The size of the Base64 encoded output is returned. If this value is greater than the size of data.out, then no output at all is written to data.out. To compute the size of the Base64 encoded output, only the size of the binary input must be known, the actual input itself is not needed. For each three binary input bytes, four Base64 encoded output characters are produced. For any (one or two) remaining binary input bytes at the end, also four Base64 encoded output characters are produced. So, to compute the size of the Base64 encoded output, divide the size of the binary input by 3, and if that is not an integer, round up to the next integer. Multiply the result by 4.",
    "category": "functions_base64"
  },
  "base64 overview": {
    "name": "Base64 overview",
    "type": "function",
    "syntax": "function Base64 overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_base64"
  },
  "base64 synopsis": {
    "name": "Base64 synopsis",
    "type": "function",
    "syntax": "function Base64 synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_base64"
  },
  "bit.and, bit.exor, bit.in, bit.inv, bit.or": {
    "name": "bit.and, bit.exor, bit.in, bit.inv, bit.or",
    "type": "function",
    "syntax": "function long bit.and (long pattern1, long pattern2)",
    "description": "Bitwise AND function",
    "arguments": [
      {
        "type": "long",
        "name": "pattern1",
        "description": ""
      },
      {
        "type": "long",
        "name": "pattern2",
        "description": ""
      }
    ],
    "returnValue": "The function bit.and returns the bitwise AND of the supplied input values. Each bit in the two�s complement representation of the result is set if and only if each of the corresponding bits in the two�s complement representation of the supplied input values is set. Notice that the behavior of this function does not depend on the width of the used two�s complement representation.",
    "category": "functions_bit"
  },
  "bit operations: overview and synopsis": {
    "name": "Bit operations: overview and synopsis",
    "type": "function",
    "syntax": "function Bit operations: overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_bit"
  },
  "bit.shiftl, bit.shiftr": {
    "name": "bit.shiftl, bit.shiftr",
    "type": "function",
    "syntax": "function long bit.shiftl (long bitpattern, long no_of_bits)",
    "description": "Bitwise shift left function",
    "arguments": [
      {
        "type": "long",
        "name": "bitpattern",
        "description": "The value of which the bits of its two�s complement representation must be shifted. Preferably, this value should not be negative. For negative values, the normal shift behavior can be expected for bits which remain in the result. However, the behavior with respect to bits shifted out at the left side of the bit pattern is declared to be unspecified."
      },
      {
        "type": "long",
        "name": "no_of_bits",
        "description": "The number of positions to shift. This value must not be negative. Do not expect any well-defined behavior for negative values. For example, shifting left over a negative number of bit positions is not specified as a right shift operation. This value must be less than the width of the bitpattern, i.e. it must be less than BitCountOfLong . Do not expect that shifting left over at least BitCountOfLong positions will result in value 0. Also, do not expect any other well-defined behavior."
      }
    ],
    "returnValue": "The function bit.shiftl returns the value bitpattern * 2^no_of_bits. This is only specified for non-negative values of no_of_bits, less than BitCountOfLong . If the exact result of this multiplication is not in the signed BitCountOfLong -bit range, then the result is unspecified. In practice, the same wrap around behavior can be expected as in normal arithmetic: repeatedly add or subtract 2^ BitCountOfLong until the result is in the allowed range. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, any case described above as not allowed or not specified, is considered as a fatal error and may (now or in a future version of the bshell) cause the current 3GL process to be terminated.",
    "category": "functions_bit"
  },
  "db.blob.append": {
    "name": "db.blob.append",
    "type": "function",
    "syntax": "function long db.blob.append (const string blob.locator, long num.bytes, const string bytes.array [, long mode] [, long eflag])",
    "description": "This function appends data to the BLOB, to which the BLOB locator refers. Before calling db.blob.append() , the BLOB locator must be read from the database.",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "long",
        "name": "num.bytes",
        "description": "The number of bytes to append to the BLOB"
      },
      {
        "type": "const string",
        "name": "bytes.array",
        "description": "The buffer with the BLOB data"
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This has one possible value: DB.RETRY"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_blob"
  },
  "db.blob.append.xml": {
    "name": "db.blob.append.xml",
    "type": "function",
    "syntax": "function long db.blob.append.xml (const string blob.locator, long xml.node [, long mode] [, long eflag])",
    "description": "This function appends data from an XML tree to the BLOB, to which the BLOB locator refers. Before calling db.blob.append.xml() , the BLOB locator must be read from the database.",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "long",
        "name": "xml.node",
        "description": "The top node of the XML tree to append to the BLOB"
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This has one possible value: DB.RETRY"
      }
    ],
    "returnValue": "0 Success. <>0 Error. for some negative return values additional information can be found with function xmlWrite() .",
    "category": "functions_blob"
  },
  "db.blob.clear": {
    "name": "db.blob.clear",
    "type": "function",
    "syntax": "function long db.blob.clear (const string blob.locator [, long mode] [, long eflag])",
    "description": "This function clears the BLOB, to which the BLOB locator refers. Before calling db.blob.clear() , the BLOB locator must be read from the database.",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This has one possible value: DB.RETRY"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_blob"
  },
  "db.blob.read": {
    "name": "db.blob.read",
    "type": "function",
    "syntax": "function long db.blob.read (const string blob.locator, long offset, long num.bytes, ref string bytes.array, ref long num.bytes.read)",
    "description": "This function reads data from the BLOB, to which the BLOB locator refers. Before calling db.blob.read() , the BLOB locator must be read from the database. For example, the following code retrieves the BLOB locator that refers to a certain picture from a table, and then retrieves the first 256 bytes of the picture:",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "long",
        "name": "offset",
        "description": "The offset at which to read data from the BLOB"
      },
      {
        "type": "long",
        "name": "num.bytes",
        "description": "The number of bytes to read from the BLOB"
      },
      {
        "type": "ref string",
        "name": "bytes.array",
        "description": "The buffer for the BLOB data"
      },
      {
        "type": "ref long",
        "name": "num.bytes.read",
        "description": "Returns the number of bytes read. This can be lower than num.bytes when reading at or beyond the end of a BLOB value"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_blob"
  },
  "db.blob.read.xml": {
    "name": "db.blob.read.xml",
    "type": "function",
    "syntax": "function long db.blob.read.xml (const string blob.locator, long offset, ref long bytes.read, ref long xml.node, ref string error, long whitespacehandling)",
    "description": "This function reads data from the BLOB, to which the BLOB locator refers, and parses it to an XML tree. Before calling db.blob.read.xml() , the BLOB locator must be read from the database. For example, the following code retrieves the BLOB locator that refers to a certain picture from a table, and then retrieves the first 256 bytes of the picture:",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "long",
        "name": "offset",
        "description": "The offset into the BLOB where the XML parsing starts. The most common pattern is to have a single XML document in a BLOB value; in that case the offset is 1."
      },
      {
        "type": "ref long",
        "name": "bytes.read",
        "description": "Returns the number of bytes that was read by the XML parser."
      },
      {
        "type": "ref long",
        "name": "xml.node",
        "description": "Returns a new xml node that contains the data (don't forget to xmlDelete the node later)"
      },
      {
        "type": "ref string",
        "name": "error",
        "description": "contains a description of the error in case a parsing error occurs. This is an English text, which can be used for logging purposes. Maximum length of this error string is 120 characters (this is just like the function xmlRead )"
      },
      {
        "type": "long",
        "name": "whitespacehandling",
        "description": "whitespacehandling can have one of the three values XmlWhiteSpaceLegacyMode, XmlPreserveWhiteSpace, and XmlReplaceWhiteSpaceBySingleSpace. When this optional argument is not supplied, the value XmlWhiteSpaceLegacyMode is assumed (these values are described in detail for the function xmlRead )."
      }
    ],
    "returnValue": "0 Success. <>0 Error, e.g. E_BDB_INVALID_BLOB or E_BDB_XML_PARSE_ERROR",
    "category": "functions_blob"
  },
  "db.blob.read.xml.ns": {
    "name": "db.blob.read.xml.ns",
    "type": "function",
    "syntax": "function long db.blob.read.xml.ns (const string blob.locator, long offset, ref long bytes.read, ref long xml.node, ref string error, long whitespacehandling)",
    "description": "This function reads data from the BLOB, to which the BLOB locator refers, and parses it to an XML tree. Before calling db.blob.read.xml.ns() , the BLOB locator must be read from the database. For example, the following code retrieves the BLOB locator that refers to a certain picture from a table, and then retrieves the first 256 bytes of the picture:",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "long",
        "name": "offset",
        "description": "The offset into the BLOB where the XML parsing starts. The most common pattern is to have a single XML document in a BLOB value; in that case the offset is 1."
      },
      {
        "type": "ref long",
        "name": "bytes.read",
        "description": "Returns the number of bytes that was read by the XML parser."
      },
      {
        "type": "ref long",
        "name": "xml.node",
        "description": "Returns a new xml node that contains the data (don't forget to xmlDelete the node later)"
      },
      {
        "type": "ref string",
        "name": "error",
        "description": "contains a description of the error in case a parsing error occurs. This is an English text, which can be used for logging purposes. Maximum length of this error string is 120 characters (this is just like the function xmlRead )"
      },
      {
        "type": "long",
        "name": "whitespacehandling",
        "description": "whitespacehandling can have one of the three values XmlWhiteSpaceLegacyMode, XmlPreserveWhiteSpace, and XmlReplaceWhiteSpaceBySingleSpace. When this optional argument is not supplied, the value XmlWhiteSpaceLegacyMode is assumed (these values are described in detail for the function xmlRead )."
      }
    ],
    "returnValue": "0 Success. <>0 Error, e.g. E_BDB_INVALID_BLOB or E_BDB_XML_PARSE_ERROR",
    "category": "functions_blob"
  },
  "db.blob.size": {
    "name": "db.blob.size",
    "type": "function",
    "syntax": "function long db.blob.size (const string blob.locator, ref long num.bytes)",
    "description": "This function retrieves the size of the BLOB, to which the BLOB locator refers. Before calling db.blob.size() , the BLOB locator must be read from the database. For example, the following code retrieves the BLOB locator that refers to a certain picture from a table, and then retrieves the size of the picture:",
    "arguments": [
      {
        "type": "const string",
        "name": "blob.locator",
        "description": "The BLOB locator, which is fetched from the database by e.g. db.eq or by a SQL statement"
      },
      {
        "type": "ref long",
        "name": "num.bytes",
        "description": "Returns the size of the BLOB in bytes"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_blob"
  },
  "blob handling overview": {
    "name": "BLOB handling overview",
    "type": "function",
    "syntax": "function BLOB handling overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_blob"
  },
  "blob handling synopsis": {
    "name": "BLOB handling synopsis",
    "type": "function",
    "syntax": "function BLOB handling synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_blob"
  },
  "btol": {
    "name": "btol",
    "type": "function",
    "syntax": "function long btol (boolean boolean_value)",
    "description": "Cast a boolean to a long.",
    "arguments": [
      {
        "type": "boolean",
        "name": "boolean_value",
        "description": "boolean to cast to a long."
      }
    ],
    "returnValue": "",
    "category": "functions_boolean"
  },
  "ltob": {
    "name": "ltob",
    "type": "function",
    "syntax": "function boolean ltob (long long_value)",
    "description": "Cast a long to a boolean.",
    "arguments": [
      {
        "type": "long",
        "name": "long_value",
        "description": "long to cast to a boolean."
      }
    ],
    "returnValue": "",
    "category": "functions_boolean"
  },
  "boolean overview and synopsis": {
    "name": "Boolean overview and synopsis",
    "type": "function",
    "syntax": "function Boolean overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_boolean"
  },
  "copy.cdf": {
    "name": "copy.cdf",
    "type": "function",
    "syntax": "function long copy.cdf (long dest.table.id, long src.table.id)",
    "description": "This function facilitates the application in the task of carrying forward the information in the CDFs through the business process. The function will copy CDFs from a source record buffer to a destination record buffer if the destination table has a CDF with the same name.",
    "arguments": [
      {
        "type": "long",
        "name": "dest.table.id",
        "description": "destination table"
      },
      {
        "type": "long",
        "name": "src.table.id",
        "description": "source table"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_cdf"
  },
  "cdf (customer defined fields) handling overview": {
    "name": "CDF (Customer Defined Fields) handling overview",
    "type": "function",
    "syntax": "function CDF (Customer Defined Fields) handling overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cdf"
  },
  "cdf (customer defined fields) handling synopsis": {
    "name": "CDF (Customer Defined Fields) handling synopsis",
    "type": "function",
    "syntax": "function CDF (Customer Defined Fields) handling synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cdf"
  },
  "bg$": {
    "name": "bg$",
    "type": "function",
    "syntax": "function string bg$ ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "box": {
    "name": "box",
    "type": "function",
    "syntax": "function void box (long box_x, long box_y, long box_width, long box_height, long mode)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "box_x",
        "description": "The screen co-ordinates for the top left corner of the box."
      },
      {
        "type": "long",
        "name": "box_y",
        "description": ""
      },
      {
        "type": "long",
        "name": "box_width",
        "description": "The width and height respectively of the box."
      },
      {
        "type": "long",
        "name": "box_height",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": "0 only the box is drawn; no other screen modifications are made 1 the interior of the box is cleared 2 the box is drawn dimmed; no other screen modifications are made 3 the box is drawn dimmed and its interior is cleared In addition to the above values, you can specify special effects such as reversed and blinking. For a list of possible attributes, see see cf$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "bs$": {
    "name": "bs$",
    "type": "function",
    "syntax": "function string bs$ ( [long num_expr])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "num_expr ]",
        "description": "The number of positions to go to the left, default 1"
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "cf$": {
    "name": "cf$",
    "type": "function",
    "syntax": "function string cf$ (long attribute_code)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "attribute_code",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "change.window": {
    "name": "change.window",
    "type": "function",
    "syntax": "function void change.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "cl.screen": {
    "name": "cl.screen",
    "type": "function",
    "syntax": "function void cl.screen (long column, long row, long no_of_cols, long no_of_rows)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "column",
        "description": "The column and row co-ordinates for the top left corner of the area to be cleared."
      },
      {
        "type": "long",
        "name": "row",
        "description": ""
      },
      {
        "type": "long",
        "name": "no_of_cols",
        "description": "The number of columns to be cleared."
      },
      {
        "type": "long",
        "name": "no_of_rows",
        "description": "The number of rows to be cleared."
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "cp$": {
    "name": "cp$",
    "type": "function",
    "syntax": "function string cp$ (long column, long row)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "column",
        "description": ""
      },
      {
        "type": "long",
        "name": "row",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "cr$": {
    "name": "cr$",
    "type": "function",
    "syntax": "function string cr$ ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "cs$": {
    "name": "cs$",
    "type": "function",
    "syntax": "function string cs$ ( [long num_expr])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "num_expr ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "current.window": {
    "name": "current.window",
    "type": "function",
    "syntax": "function long current.window ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "data.input": {
    "name": "data.input",
    "type": "function",
    "syntax": "function void data.input (string options(.), ref string result(.), string default(.), ref long event(EVTMAXSIZE), ref long char_value)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "options(.)",
        "description": "This argument must either be empty or it must contain 5 parts separated by one or more spaces. If it is empty, the following input characteristics apply: no fill characters are displayed input starts at the current cursor position all characters are permitted the maximum number of characters that can be input is 132 If it is not empty, it must include the following five items: the starting column the starting row the minimum length of the string to be read the maximum length of the string to be read zero or more options The following options are available. You can specify them with or without separating spaces. +ABIDI"
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "del.window": {
    "name": "del.window",
    "type": "function",
    "syntax": "function void del.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "delch$": {
    "name": "delch$",
    "type": "function",
    "syntax": "function string delch$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "deleteln$": {
    "name": "deleteln$",
    "type": "function",
    "syntax": "function string deleteln$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "el$": {
    "name": "el$",
    "type": "function",
    "syntax": "function string el$ ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "es$": {
    "name": "es$",
    "type": "function",
    "syntax": "function string es$ ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "ff$": {
    "name": "ff$",
    "type": "function",
    "syntax": "function string ff$ ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "fg$": {
    "name": "fg$",
    "type": "function",
    "syntax": "function string fg$ (long color)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "color",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "first.window": {
    "name": "first.window",
    "type": "function",
    "syntax": "function void first.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "fs$": {
    "name": "fs$",
    "type": "function",
    "syntax": "function string fs$ ( [long num_expr])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "num_expr ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "get.col": {
    "name": "get.col",
    "type": "function",
    "syntax": "function long get.col ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "get.cp": {
    "name": "get.cp",
    "type": "function",
    "syntax": "function void get.cp (ref long x, ref long y)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "x",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "y",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "get.row": {
    "name": "get.row",
    "type": "function",
    "syntax": "function long get.row ()",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "get.window.attrs": {
    "name": "get.window.attrs",
    "type": "function",
    "syntax": "function long get.window.attrs (long wind_id, ref long attrs(WINMAXSIZE))",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "attrs(WINMAXSIZE)",
        "description": ""
      }
    ],
    "returnValue": "TRUE Success. FALSE Error.",
    "category": "functions_char_b_win"
  },
  "insch$": {
    "name": "insch$",
    "type": "function",
    "syntax": "function string insch$ (string attr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "attr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "insertln$": {
    "name": "insertln$",
    "type": "function",
    "syntax": "function string insertln$ (string string_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "keyin$": {
    "name": "keyin$",
    "type": "function",
    "syntax": "function string keyin$ ( [long flag])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "flag ]",
        "description": ""
      }
    ],
    "returnValue": "The character read from the event queue. If the returned string contains multiple bytes, the character is s multibyte character. If the character is a function that cannot be converted, the function returns an empty string.",
    "category": "functions_char_b_win"
  },
  "last.window": {
    "name": "last.window",
    "type": "function",
    "syntax": "function void last.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "lf$": {
    "name": "lf$",
    "type": "function",
    "syntax": "function string lf$ ( [long num_expr])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "num_expr ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "map.window": {
    "name": "map.window",
    "type": "function",
    "syntax": "function void map.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "mark.handler": {
    "name": "mark.handler",
    "type": "function",
    "syntax": "function long mark.handler (ref long mark.table())",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "mark.table()",
        "description": ""
      }
    ],
    "returnValue": "0 no records marked 1 one or more records marked",
    "category": "functions_char_b_win"
  },
  "move.window": {
    "name": "move.window",
    "type": "function",
    "syntax": "function void move.window (long col, long row)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "col",
        "description": ""
      },
      {
        "type": "long",
        "name": "row",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "new.window": {
    "name": "new.window",
    "type": "function",
    "syntax": "function long new.window (long height, long width, long row, long col)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "height",
        "description": "The height and width of the new window."
      },
      {
        "type": "long",
        "name": "width",
        "description": ""
      },
      {
        "type": "long",
        "name": "row",
        "description": "These indicate the position of the top left corner of the new window, relative to the top left corner of the parent window."
      },
      {
        "type": "long",
        "name": "col",
        "description": ""
      }
    ],
    "returnValue": "The window ID for the new window.",
    "category": "functions_char_b_win"
  },
  "no.scroll": {
    "name": "no.scroll",
    "type": "function",
    "syntax": "function void no.scroll (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "character-based windows - overview and synopsis": {
    "name": "Character-based windows - overview and synopsis",
    "type": "function",
    "syntax": "function Character-based windows - overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "pc$": {
    "name": "pc$",
    "type": "function",
    "syntax": "function string pc$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "pf$": {
    "name": "pf$",
    "type": "function",
    "syntax": "function string pf$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "refresh": {
    "name": "refresh",
    "type": "function",
    "syntax": "function void refresh ( [long wind_id])",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "wind_id ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "resize.window": {
    "name": "resize.window",
    "type": "function",
    "syntax": "function void resize.window (long width, long height)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "width",
        "description": ""
      },
      {
        "type": "long",
        "name": "height",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "scroll": {
    "name": "scroll",
    "type": "function",
    "syntax": "function void scroll (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "set.fg.color": {
    "name": "set.fg.color",
    "type": "function",
    "syntax": "function void set.fg.color (long wind_id, long color)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      },
      {
        "type": "long",
        "name": "color",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "set.refresh.rate": {
    "name": "set.refresh.rate",
    "type": "function",
    "syntax": "function long set.refresh.rate (long rateInSeconds [, long thresholdInSeconds])",
    "description": "With this function the refresh rate of the session will be overruled temporary.",
    "arguments": [
      {
        "type": "long",
        "name": "rateInSeconds",
        "description": "The refresh rate of the session. Special values: 0: the refresh rate of the session will be set to its original refreshing rate. -1: the refreshing of the session will be stopped."
      },
      {
        "type": "[long",
        "name": "thresholdInSeconds ]",
        "description": "The duration of the refresh rate: 0: The refresh rate does not have an end time (default) > 0: The refresh rate will be changed for thresholdInSeconds. After thresholdInSeconds, the original refresh rate is restored."
      }
    ],
    "returnValue": "Error Code: 0: Successful completion -1: Refresh rate must be greater than or equal to -1. -2: Threshold must be greater than or equal to zero. -3: No action on XML Response Node \"Session Refresh\" -4: Refresh interval not supported",
    "category": "functions_char_b_win"
  },
  "set.bg.color": {
    "name": "set.bg.color",
    "type": "function",
    "syntax": "function void set.bg.color (long wind_id, long color)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      },
      {
        "type": "long",
        "name": "color",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "sf$": {
    "name": "sf$",
    "type": "function",
    "syntax": "function void sf$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "sub.window": {
    "name": "sub.window",
    "type": "function",
    "syntax": "function long sub.window (long parent_wind, long height, long width, long row, long col)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "parent_wind",
        "description": "The ID of the parent window."
      },
      {
        "type": "long",
        "name": "height",
        "description": "The height and width of the new window."
      },
      {
        "type": "long",
        "name": "width",
        "description": ""
      },
      {
        "type": "long",
        "name": "row",
        "description": "These indicate the position of the top left corner of the new window, relative to the top left corner of the parent window."
      },
      {
        "type": "long",
        "name": "col",
        "description": ""
      }
    ],
    "returnValue": "The window ID for the new window.",
    "category": "functions_char_b_win"
  },
  "tab$": {
    "name": "tab$",
    "type": "function",
    "syntax": "function string tab$ (long num_expr)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "unmap.window": {
    "name": "unmap.window",
    "type": "function",
    "syntax": "function void unmap.window (long wind_id)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "wind_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "wrebuild": {
    "name": "wrebuild",
    "type": "function",
    "syntax": "function void wrebuild (long mode)",
    "description": "Deprecated. This function is only supported for character-based windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_char_b_win"
  },
  "chm.axis.in": {
    "name": "chm.axis.in",
    "type": "function",
    "syntax": "function long chm.axis.in (long axis_name, long logarithmic, long log_base, long divisions, double divisionstep, double intersection, string division_set(16))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "axis_name",
        "description": ""
      },
      {
        "type": "long",
        "name": "logarithmic",
        "description": "If logarithmic scaling is required, set this to true. For linear scaling, set it to false."
      },
      {
        "type": "long",
        "name": "log_base",
        "description": "For logarithmic scaling, this indicates the log base that must be used. The argument is ignored if logarithmic is set to false."
      },
      {
        "type": "long",
        "name": "divisions",
        "description": ""
      },
      {
        "type": "double",
        "name": "divisionstep",
        "description": "This specifies the interval between two divisions on the axis. You can use chm.scale.axis() to calculate the division step."
      },
      {
        "type": "double",
        "name": "intersection",
        "description": "This indicates the value on the data axis where the category and data axes intersect."
      },
      {
        "type": "string",
        "name": "division_set(16)",
        "description": "Normally, the values or labels from the associated domain are displayed on the axis. You can override this by specifying the name of a different set here. You create the set with chm.set.in() ."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.axis.out": {
    "name": "chm.axis.out",
    "type": "function",
    "syntax": "function long chm.axis.out (long axis_name, ref long logarithmic, ref long log_base, ref long divisions, ref double divisionstep, ref double intersection, ref string division_set())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "axis_name",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "logarithmic",
        "description": "This returns true if the axis uses logarithmic scaling, or false if it uses linear scaling."
      },
      {
        "type": "ref long",
        "name": "log_base",
        "description": "If logarithmic returns true, this argument returns the log base used."
      },
      {
        "type": "ref long",
        "name": "divisions",
        "description": "This returns the number of divisions into which the axis is divided."
      },
      {
        "type": "ref double",
        "name": "divisionstep",
        "description": "This returns the interval between two divisions on the axis."
      },
      {
        "type": "ref double",
        "name": "intersection",
        "description": "This returns the value on the data axis where the category and data axes intersect."
      },
      {
        "type": "ref string",
        "name": "division_set()",
        "description": "If the labels or values displayed on the axis are provided by a set created by chm.set.in() instead of by the domain associated with the axis, this argument returns the name of the set used."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.chartman": {
    "name": "chm.chartman",
    "type": "function",
    "syntax": "function long chm.chartman (long chart_manager(80), string title(80), string user(14), string owner(14) [, string version(4)] [, string release(2)] [, string cust(4)])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "chart_manager(80)",
        "description": ""
      },
      {
        "type": "string",
        "name": "title(80)",
        "description": "This specifies the window title."
      },
      {
        "type": "string",
        "name": "user(14)",
        "description": "This specifies the name of the relevant user."
      },
      {
        "type": "string",
        "name": "owner(14)",
        "description": "This specifies the name of the relevant owner."
      },
      {
        "type": "[string",
        "name": "version(4) ]",
        "description": "It is possible to assign a VRC code to a chart. These optional arguments specify the relevant VRC codes."
      },
      {
        "type": "[string",
        "name": "release(2) ]",
        "description": ""
      },
      {
        "type": "[string",
        "name": "cust(4) ]",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.check": {
    "name": "chm.check",
    "type": "function",
    "syntax": "function long chm.check (sting chart_manager(14), string user(14), string chart_type(16))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "sting",
        "name": "chart_manager(14)",
        "description": ""
      },
      {
        "type": "string",
        "name": "user(14)",
        "description": "The user name."
      },
      {
        "type": "string",
        "name": "chart_type(16)",
        "description": "The chart type."
      }
    ],
    "returnValue": "true The user can select the specified chart type. false The user cannot select the specified chart type",
    "category": "functions_chm"
  },
  "chm.data.in": {
    "name": "chm.data.in",
    "type": "function",
    "syntax": "function long chm.data.in (double series_value, double category_value, long data_number, double data_value, long footnote_no [, long duplicate_option])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "double",
        "name": "series_value",
        "description": "This specifies the series to which the data point belongs."
      },
      {
        "type": "double",
        "name": "category_value",
        "description": "This specifies the category to which the data point belongs."
      },
      {
        "type": "long",
        "name": "data_number",
        "description": "If there is more than one data point per category (a high-low graph, for example), this indicates the sequence number of the data point within the category. If there is only one data point per category, the sequence number is 1."
      },
      {
        "type": "double",
        "name": "data_value",
        "description": "The data value for the specified series and category. The data value must lie within the scope of the data domain."
      },
      {
        "type": "long",
        "name": "footnote_no",
        "description": "If you want to include a footnote for the data point, specify the number of the footnote here. Use chm.footnote.in() to create the footnote"
      },
      {
        "type": "[long",
        "name": "duplicate_option ]",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.data2domain.in": {
    "name": "chm.data2domain.in",
    "type": "function",
    "syntax": "function long chm.data2domain.in (double series_value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "double",
        "name": "series_value",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.delete.data": {
    "name": "chm.delete.data",
    "type": "function",
    "syntax": "function long chm.delete.data ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.delete.data2domains": {
    "name": "chm.delete.data2domains",
    "type": "function",
    "syntax": "function long chm.delete.data2domains (ref double series_value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref double",
        "name": "series_value",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.delete.footnotes": {
    "name": "chm.delete.footnotes",
    "type": "function",
    "syntax": "function long chm.delete.footnotes ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.delete.projections": {
    "name": "chm.delete.projections",
    "type": "function",
    "syntax": "function long chm.delete.projections ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.delete.sets": {
    "name": "chm.delete.sets",
    "type": "function",
    "syntax": "function long chm.delete.sets ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.disconnect": {
    "name": "chm.disconnect",
    "type": "function",
    "syntax": "function long chm.disconnect ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.domain.in": {
    "name": "chm.domain.in",
    "type": "function",
    "syntax": "function long chm.domain.in (long domain_name, long data_type, string set_name(16), string title(16), string unit_label(16), double from_value, double to_value, double interval, string display_format(80))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "domain_name",
        "description": "This specifies the name of the domain. The possible values are: CHM_SERIES_DOMAIN CHM_CATEGORY_DOMAIN CHM_DATA_DOMAIN CHM_DATA2_DOMAIN"
      },
      {
        "type": "long",
        "name": "data_type",
        "description": "This specifies the domain type. The possible values are: CHM_REAL real (the domain consists of integers and fractions) CHM_INTEGER integer (the domain consists of integers) CHM_SET enumerated set (the domain consists of a set of labels)"
      },
      {
        "type": "string",
        "name": "set_name(16)",
        "description": "When the domain type is CHM_SET, this specifies the name of the relevant set. For other domain types, specify an empty string [\"\"] here. Use chm.set.in() to define the set."
      },
      {
        "type": "string",
        "name": "title(16)",
        "description": "These specify the axis title and the unit of measurement that must be displayed in the chart to describe the corresponding axis."
      },
      {
        "type": "string",
        "name": "unit_label(16)",
        "description": ""
      },
      {
        "type": "double",
        "name": "from_value",
        "description": "These specify the start and end values of the domain. You can calculate these values with the function chm.scale.axis() ."
      },
      {
        "type": "double",
        "name": "to_value",
        "description": ""
      },
      {
        "type": "double",
        "name": "interval",
        "description": "This specifies the interval between domain values."
      },
      {
        "type": "string",
        "name": "display_format(80)",
        "description": "For domains of type CHM_REAL or CHM_INTEGER, you must specify a display format. See edit$() ."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.domain.out": {
    "name": "chm.domain.out",
    "type": "function",
    "syntax": "function long chm.domain.out (long domain_name, ref long data_type, ref string set_name(), ref string title(), ref string unit_label, ref double from value, ref double to_value, ref double interval, ref string display_format())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "domain_name",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "data_type",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "set_name()",
        "description": "When the domain type is CHM_SET, this returns the name of the relevant set. For other domain types, this returns an empty string [\"\"] here."
      },
      {
        "type": "ref string",
        "name": "title()",
        "description": "These return the axis title and the unit of measurement that are displayed in the chart to describe the corresponding axis."
      },
      {
        "type": "ref string",
        "name": "unit_label",
        "description": ""
      },
      {
        "type": "ref double",
        "name": "from value",
        "description": "These return the start and end values of the domain."
      },
      {
        "type": "ref double",
        "name": "to_value",
        "description": ""
      },
      {
        "type": "ref double",
        "name": "interval",
        "description": "This returns the interval between domain values."
      },
      {
        "type": "ref string",
        "name": "display_format()",
        "description": "For domains of type CHM_REAL or CHM_INTEGER, this returns the display format. See edit$() ."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.draw": {
    "name": "chm.draw",
    "type": "function",
    "syntax": "function long chm.draw ( [double cat_from_value])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[double",
        "name": "cat_from_value ]",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.first.data.out": {
    "name": "chm.first.data.out",
    "type": "function",
    "syntax": "function long chm.first.data.out (long option, ref double series_value, ref double category_value, ref long data_number, ref double data_value, ref long footnote_no)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "option",
        "description": "Use this argument to indicate whether the function retrieves data for the absolute first data point or for the first data point that has been modified. The possible values are: CHM_ALL_DATA CHM_CHANGED_DATA"
      },
      {
        "type": "ref double",
        "name": "series_value",
        "description": "This returns the series to which the data point belongs."
      },
      {
        "type": "ref double",
        "name": "category_value",
        "description": "This returns the category to which the data point belongs."
      },
      {
        "type": "ref long",
        "name": "data_number",
        "description": "If there is more than one data point per category (a high-low graph, for example), this returns the sequence number of the data point within the category. If there is only one data point per category, the sequence number is 1."
      },
      {
        "type": "ref double",
        "name": "data_value",
        "description": "This returns the value of the data point."
      },
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the number of the footnote (if any) associated with the data point."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.first.data2domain.out": {
    "name": "chm.first.data2domain.out",
    "type": "function",
    "syntax": "function long chm.first.data2domain.out (ref double series_value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref double",
        "name": "series_value",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.first.footnote.out": {
    "name": "chm.first.footnote.out",
    "type": "function",
    "syntax": "function long chm.first.footnote.out (ref long footnote_no, ref string footnote_text())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the footnote number."
      },
      {
        "type": "ref string",
        "name": "footnote_text()",
        "description": "This returns the footnote text."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.first.projection.out": {
    "name": "chm.first.projection.out",
    "type": "function",
    "syntax": "function long chm.first.projection.out (ref double projection_point, ref long footnote_no)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref double",
        "name": "projection_point",
        "description": "This returns the position on the category axis where the projection point occurs."
      },
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the number of the footnote associated with the projection point. It returns 0 if there is no footnote associated with the projection point."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.first.set.out": {
    "name": "chm.first.set.out",
    "type": "function",
    "syntax": "function long chm.first.set.out (string set_name(16), ref long element_number, ref string element_name())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "set_name(16)",
        "description": "The name of the set for which you want to retrieve information."
      },
      {
        "type": "ref long",
        "name": "element_number",
        "description": "This returns the number of the first element in the set."
      },
      {
        "type": "ref string",
        "name": "element_name()",
        "description": "This returns the name of the first element in the set."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.footnote.in": {
    "name": "chm.footnote.in",
    "type": "function",
    "syntax": "function long chm.footnote.in (long footnoote_no, string footnote_text(80))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "footnoote_no",
        "description": "The footnote number."
      },
      {
        "type": "string",
        "name": "footnote_text(80)",
        "description": "The footnote text."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.get.request": {
    "name": "chm.get.request",
    "type": "function",
    "syntax": "function long chm.get.request (long chart_no, ref double category_from_value, ref double category_to_value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "chart_no",
        "description": "This returns the ID of the relevant chart, as returned by chm.open() ."
      },
      {
        "type": "ref double",
        "name": "category_from_value",
        "description": "These indicate the range of data the Chart Manager is asking for. These arguments are relevant only when the return value is CHM_SOURCE_IN."
      },
      {
        "type": "ref double",
        "name": "category_to_value",
        "description": ""
      }
    ],
    "returnValue": "CHM_ABORT Quit the Business Chart Manager. CHM_SOURCE_IN Send data to the Chart Manager. This value is returned when the user chooses the IN command on the Chart Manager's File menu. CHM_SOURCE_OUT Retrieve data from the Chart Manager. This value is returned when the user chooses the OUT command on the Chart Manager's File menu. CHM_TIMER Execute actions after the interval set by chm.set.timer() . < value > This is the ID of an application option defined in the Application Options session (ttchm1120s000). When this value is returned, the application must execute the specific actions related to the particular application option.",
    "category": "functions_chm"
  },
  "chm.new": {
    "name": "chm.new",
    "type": "function",
    "syntax": "function long chm.new (string chart_name(16), ref string chart_type())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "chart_name(16)",
        "description": "The name of the new chart."
      },
      {
        "type": "ref string",
        "name": "chart_type()",
        "description": "The chart type. If you do not specify an existing chart type, the Chart Manager selects the default chart type, as defined in the Chart Manager Application session (ttchm1500m000)."
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_chm"
  },
  "chm.next.data.out": {
    "name": "chm.next.data.out",
    "type": "function",
    "syntax": "function long chm.next.data.out (long option, ref double series_value, ref double category_value, ref long data_number, ref double data_value, ref long footnote_no)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "option",
        "description": "Use this argument to indicate whether the function retrieves data for the absolute next data point or for the next data point that has been modified. The possible values are: CHM_ALL_DATA CHM_CHANGED_DATA"
      },
      {
        "type": "ref double",
        "name": "series_value",
        "description": "This returns the series to which the data point belongs."
      },
      {
        "type": "ref double",
        "name": "category_value",
        "description": "This returns the category to which the data point belongs."
      },
      {
        "type": "ref long",
        "name": "data_number",
        "description": "If there is more than one data point per category (a high-low graph, for example), this returns the sequence number of the data point within the category. If there is only one data point per category, the sequence number is 1."
      },
      {
        "type": "ref double",
        "name": "data_value",
        "description": "This returns the value of the data point."
      },
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the number of the footnote (if any) associated with the data point."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.next.data2domain.out": {
    "name": "chm.next.data2domain.out",
    "type": "function",
    "syntax": "function long chm.next.data2domain.out (ref double series_value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref double",
        "name": "series_value",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.next.footnote.out": {
    "name": "chm.next.footnote.out",
    "type": "function",
    "syntax": "function long chm.next.footnote.out (ref long footnote_no, ref string footnote_text())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the footnote number."
      },
      {
        "type": "ref string",
        "name": "footnote_text()",
        "description": "This returns the footnote text."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.next.projection.out": {
    "name": "chm.next.projection.out",
    "type": "function",
    "syntax": "function long chm.next.projection.out (ref double projeection_point, ref long footnote_no)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref double",
        "name": "projeection_point",
        "description": "This returns the position on the category axis where the projection point occurs"
      },
      {
        "type": "ref long",
        "name": "footnote_no",
        "description": "This returns the number of the footnote associated with the projection point. It returns 0 if there is no footnote associated with the projection point."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.next.set.out": {
    "name": "chm.next.set.out",
    "type": "function",
    "syntax": "function long chm.next.set.out (string set_name(16), ref long element_number, ref string element_name())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "set_name(16)",
        "description": "The name of the set for which you want to retrieve information."
      },
      {
        "type": "ref long",
        "name": "element_number",
        "description": "This returns the number of the next element in the set."
      },
      {
        "type": "ref string",
        "name": "element_name()",
        "description": "This returns the name of the next element in the set."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.open": {
    "name": "chm.open",
    "type": "function",
    "syntax": "function long chm.open (string chart_name(16))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "chart_name(16)",
        "description": ""
      }
    ],
    "returnValue": ">0 The ID of the opened chart. CHM_ERROR Error. The Business Chart Manager cannot find or cannot open the specified chart",
    "category": "functions_chm"
  },
  "chm.projection.in": {
    "name": "chm.projection.in",
    "type": "function",
    "syntax": "function long chm.projection.in (double projection_point, long footnote_no)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "double",
        "name": "projection_point",
        "description": "This specifies the position on the category axis where the projection point occurs."
      },
      {
        "type": "long",
        "name": "footnote_no",
        "description": "This specifies the number of the footnote (if any) associated with the projection point. Specify 0 here, if you do not want to associate a footnote with the point. You use chm.footnote.in() to create footnotes."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.remove": {
    "name": "chm.remove",
    "type": "function",
    "syntax": "function long chm.remove (string chart_manager(80), string owner_from(14), string ower_to(14))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "chart_manager(80)",
        "description": "This specifies the name of a relevant Business Chart Manager application. The name takes the following format: pp package code mmm module code xxx the name of the application"
      },
      {
        "type": "string",
        "name": "owner_from(14)",
        "description": "These specify the range of users for whom the charts are to be removed."
      },
      {
        "type": "string",
        "name": "ower_to(14)",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.scale.axis": {
    "name": "chm.scale.axis",
    "type": "function",
    "syntax": "function void chm.scale.axis (double from_value, double to_value, long divisions, double factor, ref double domain_from_value, ref double domain_to_value, ref double divisionstep)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "double",
        "name": "from_value",
        "description": "Use these to specify the minimum and maximum data values to be presented by the graph."
      },
      {
        "type": "double",
        "name": "to_value",
        "description": ""
      },
      {
        "type": "long",
        "name": "divisions",
        "description": "Use this to specify the number of divisions required. The axis will be divided into the specified number of divisions."
      },
      {
        "type": "double",
        "name": "factor",
        "description": ""
      },
      {
        "type": "ref double",
        "name": "domain_from_value",
        "description": "The function calculates and returns these values, which are the minimum and maximum values of the domain. These will be the start and end points of the axis."
      },
      {
        "type": "ref double",
        "name": "domain_to_value",
        "description": ""
      },
      {
        "type": "ref double",
        "name": "divisionstep",
        "description": "This returns the size of the steps that separate the divisions on the axis."
      }
    ],
    "returnValue": "",
    "category": "functions_chm"
  },
  "chm.select": {
    "name": "chm.select",
    "type": "function",
    "syntax": "function long chm.select (string chart_manager(80), string title(80), long mode, string user(14), string owner(14), ref string chart_name(16), ref string chart_type(16))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "chart_manager(80)",
        "description": "This specifies the name of a Business Chart Manager application. This corresponds to a particular record in the Chart Manager application data session (ttchm1500m000). The name takes the following format: pp package code mmm module code xxx the name of the application"
      },
      {
        "type": "string",
        "name": "title(80)",
        "description": "This specifies the window title."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "This specifies whether the session enables selection or creation of a chart or chart type. The possible values are: CHM_SELECT_CHARTTYPE select another chart type CHM_CREATE_CHART create another chart CHM_SELECT_CHART select another chart CHM_CREATESELECT_CHART create or select another chart"
      },
      {
        "type": "string",
        "name": "user(14)",
        "description": "This specifies the name of the user. The session is started with this user's option set."
      },
      {
        "type": "string",
        "name": "owner(14)",
        "description": "This specifies the name of the relevant owner. When a list of charts is called, the system displays the charts that this user owns."
      },
      {
        "type": "ref string",
        "name": "chart_name(16)",
        "description": "This returns the name of the selected chart."
      },
      {
        "type": "ref string",
        "name": "chart_type(16)",
        "description": "This returns the type of the selected chart."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.set.in": {
    "name": "chm.set.in",
    "type": "function",
    "syntax": "function long chm.set.in (string set_name(16), ref long element_number, string element_name(80))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "set_name(16)",
        "description": "The name of the set to which the element is to be added."
      },
      {
        "type": "ref long",
        "name": "element_number",
        "description": "The sequence number of the element within the set."
      },
      {
        "type": "string",
        "name": "element_name(80)",
        "description": "The description of the element."
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.set.option": {
    "name": "chm.set.option",
    "type": "function",
    "syntax": "function long chm.set.option (long option, long flag)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "option",
        "description": "The option that must be switched on or off."
      },
      {
        "type": "long",
        "name": "flag",
        "description": "This specifies whether the option is be switched on or off. The possible values are: true: option enabled false: option disabled"
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.set.timer": {
    "name": "chm.set.timer",
    "type": "function",
    "syntax": "function long chm.set.timer (long time)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "time",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.title.in": {
    "name": "chm.title.in",
    "type": "function",
    "syntax": "function long chm.title.in (string main_title(80), string sub_title(80))",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "main_title(80)",
        "description": ""
      },
      {
        "type": "string",
        "name": "sub_title(80)",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "chm.title.out": {
    "name": "chm.title.out",
    "type": "function",
    "syntax": "function long chm.title.out (ref string main_title(), ref string sub_title())",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref string",
        "name": "main_title()",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "sub_title()",
        "description": ""
      }
    ],
    "returnValue": "CHM_OK Success. CHM_ERROR Error.",
    "category": "functions_chm"
  },
  "creating a chart manager client application": {
    "name": "Creating a chart manager client application",
    "type": "function",
    "syntax": "function Creating a chart manager client application()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_chm"
  },
  "chart manager example": {
    "name": "Chart manager example",
    "type": "function",
    "syntax": "function Chart manager example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_chm"
  },
  "chart manager glossary": {
    "name": "Chart manager glossary",
    "type": "function",
    "syntax": "function Chart manager glossary()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_chm"
  },
  "chart manager overview": {
    "name": "Chart manager overview",
    "type": "function",
    "syntax": "function Chart manager overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_chm"
  },
  "chart manager synopsis": {
    "name": "Chart manager synopsis",
    "type": "function",
    "syntax": "function Chart manager synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_chm"
  },
  "cipher.decrypt.finalize": {
    "name": "cipher.decrypt.finalize",
    "type": "function",
    "syntax": "function long cipher.decrypt.finalize (long Handle, string data.out, long data.out.length)",
    "description": "Most cipher algorithms operate in block mode, which means the output is always a multiple of the block size. Because the input is not necessarily a multiple of that block size, this function returns the last (partial) block. It also frees up the resources that are used by the encryption and invalidates (closes) the handle",
    "arguments": [
      {
        "type": "long",
        "name": "Handle",
        "description": "A valid handle obtained from a previous call to cipher.decrypt.initialize() . Also, some data should have been decrypted using cipher.decrypt.update() ."
      },
      {
        "type": "string",
        "name": "data.out",
        "description": "The output buffer."
      },
      {
        "type": "long",
        "name": "data.out.length",
        "description": "The number of bytes written to the data.out buffer."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, an invalid buffer length or an invalid handle.",
    "category": "functions_cipher"
  },
  "cipher.decrypt.initialize": {
    "name": "cipher.decrypt.initialize",
    "type": "function",
    "syntax": "function long cipher.decrypt.initialize (long crypt.type, string key, string iv)",
    "description": "Initializes the state of the Decrypt Algorithm and selects the appropriate decryption algorithm.",
    "arguments": [
      {
        "type": "long",
        "name": "crypt.type",
        "description": "The name of the cipher algorithm. This must be one of: CIPHER_AES_128_ECB CIPHER_AES_128_CBC CIPHER_AES_128_CFB1 CIPHER_AES_128_CFB8 CIPHER_AES_128_CFB128 CIPHER_AES_128_OFB CIPHER_AES_128_CTR CIPHER_AES_128_XTS CIPHER_AES_192_ECB CIPHER_AES_192_CBC CIPHER_AES_192_CFB1 CIPHER_AES_192_CFB8 CIPHER_AES_192_CFB128 CIPHER_AES_192_OFB CIPHER_AES_192_CTR CIPHER_AES_256_ECB CIPHER_AES_256_CBC CIPHER_AES_256_CFB1 CIPHER_AES_256_CFB8 CIPHER_AES_256_CFB128 CIPHER_AES_256_OFB CIPHER_AES_256_CTR CIPHER_AES_256_XTS"
      },
      {
        "type": "string",
        "name": "key",
        "description": "The key with wich the data is to be decrypted. The key must be of the proper length as required by the algorithm (usually at least 16 bytes). The format is raw binary. The key must have exactly the same value as used during the encryption."
      },
      {
        "type": "string",
        "name": "iv",
        "description": "The initialization vector. This parameter is optional. When no initialization vector is given and the algorithm requires one, a default IV is used. When the data is decrypted, the same IV must be used. An IV is used as a starting vector for the feedback modes of the algorithm: the results of the previous block decryption are used as input for the next block decryption operation. The IV servers as input for the first such block. The IV must have exactly the same value as used during the encryption."
      }
    ],
    "returnValue": "A handle for this decrypt operation that must be used in subsequent calls to cipher.decrypt.update() and cipher.decrypt.finalize() . The returned Id can only be used in the original process where cipher.decrypt.initialize was called, and is useless in other processes in the same bshell. The allocated memory is freed explicitly by passing the Id to cipher.decrypt.finalize(). The allocated memory is freed implicitly when the process exits. Any number of Cipher Encrypt Algorithm ID's may be in use concurrently.",
    "category": "functions_cipher"
  },
  "cipher.decrypt.update": {
    "name": "cipher.decrypt.update",
    "type": "function",
    "syntax": "function long cipher.decrypt.update (long handle, string data.out, long data.out.size, string data.in, long data.in.size)",
    "description": "Feeds data to the decryption algorithm to be decrypted using the key (and optionally IV) given in cipher.decrypt.initialize() .",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "A (valid) handle obtained by a previous call to cipher.decrypt.initialize() ."
      },
      {
        "type": "string",
        "name": "data.out",
        "description": "The output buffer that will receive the result of the decryption operation. It is the responsibility of the programmer to make sure that the buffer is big enough."
      },
      {
        "type": "long",
        "name": "data.out.size",
        "description": "Receives the number of bytes written to the data.out buffer."
      },
      {
        "type": "string",
        "name": "data.in",
        "description": "The data that must be decrypted."
      },
      {
        "type": "long",
        "name": "data.in.size",
        "description": "The number of bytes in the data.in buffer that must be decrypted. When this parameter is omitted, the length(data.in) is assumed."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, an invalid buffer length or an invalid handle.",
    "category": "functions_cipher"
  },
  "cipher.encrypt.finalize": {
    "name": "cipher.encrypt.finalize",
    "type": "function",
    "syntax": "function long cipher.encrypt.finalize (long handle, string data.out, long data.out.length)",
    "description": "Most cipher algorithms operate in block mode, which means the output is always a multiple of the block size. Because the input is not necessarily a multiple of that block size, this function returns the last (partial) block. It also frees up the resources that are used by the encryption and invalidates (closes) the handle .",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "A valid handle obtained from a previous call to cipher.encrypt.initialize() . Also, some data should have been encrypted using cipher.encrypt.update() ."
      },
      {
        "type": "string",
        "name": "data.out",
        "description": "The output buffer. This buffer must be big enough to hold the result."
      },
      {
        "type": "long",
        "name": "data.out.length",
        "description": "The number of bytes written to the data.out buffer."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, an invalid buffer length or an invalid handle.",
    "category": "functions_cipher"
  },
  "cipher.encrypt.initialize": {
    "name": "cipher.encrypt.initialize",
    "type": "function",
    "syntax": "function long cipher.encrypt.initialize (long crypt.type, const string key, const string iv)",
    "description": "Initializes the state of the Encryption Algorithm and selects the appropriate encryption algorithm.",
    "arguments": [
      {
        "type": "long",
        "name": "crypt.type",
        "description": "The name of the cipher algorithm. This must be one of: CIPHER_AES_128_ECB CIPHER_AES_128_CBC CIPHER_AES_128_CFB1 CIPHER_AES_128_CFB8 CIPHER_AES_128_CFB128 CIPHER_AES_128_OFB CIPHER_AES_128_CTR CIPHER_AES_128_XTS CIPHER_AES_192_ECB CIPHER_AES_192_CBC CIPHER_AES_192_CFB1 CIPHER_AES_192_CFB8 CIPHER_AES_192_CFB128 CIPHER_AES_192_OFB CIPHER_AES_192_CTR CIPHER_AES_256_ECB CIPHER_AES_256_CBC CIPHER_AES_256_CFB1 CIPHER_AES_256_CFB8 CIPHER_AES_256_CFB128 CIPHER_AES_256_OFB CIPHER_AES_256_CTR CIPHER_AES_256_XTS"
      },
      {
        "type": "const string",
        "name": "key",
        "description": "The key with wich the data is to be encrypted. The key must be of the proper length as required by the cipher algorithm (usually at least 16 bytes). The format is raw binary."
      },
      {
        "type": "const string",
        "name": "iv",
        "description": "The initialization vector. This parameter is optional. When no initialization vector is given and the algorithm requires one, a default IV is used. When the data is decrypted, the same IV must be used. An IV is used as a starting vector for the feedback modes of the algorithm: the results of the previous block encryption are used as input for the next block encryption operation. The IV serves as input for the first such block."
      }
    ],
    "returnValue": "A handle for this encrypt operation that must be used in subsequent calls to cipher.encrypt.update() and cipher.encrypt.finalize() . The returned Id can only be used in the original process where cipher.encrypt.initialize was called, and is useless in other processes in the same bshell. The allocated memory is freed explicitly by passing the Id to cipher.encrypt.finalize(). The allocated memory is freed implicitly when the process exits. Any number of Cipher Encrypt Algorithm ID's may be in use concurrently.",
    "category": "functions_cipher"
  },
  "cipher.encrypt.update": {
    "name": "cipher.encrypt.update",
    "type": "function",
    "syntax": "function long cipher.encrypt.update (long handle, ref string data.out, ref long data.out.size, const string data.in, long data.in.size)",
    "description": "Feeds data to the encryption algorithm to be encrypted using the key (and optionally the IV) given in cipher.encrypt.initialize() .",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "A (valid) handle obtained by a previous call to cipher.encrypt.initialize() ."
      },
      {
        "type": "ref string",
        "name": "data.out",
        "description": "The output buffer that will receive the result of the encryption operation. It is the responsibility of the programmer to make sure that the buffer is big enough."
      },
      {
        "type": "ref long",
        "name": "data.out.size",
        "description": "Receives the number of bytes written to the data.out buffer."
      },
      {
        "type": "const string",
        "name": "data.in",
        "description": "The data that must be encrypted."
      },
      {
        "type": "long",
        "name": "data.in.size",
        "description": "The number of bytes in the data.in buffer that must be encrypted. When this parameter is omitted, the vvalue returned by len(data.in) is assumed."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, an invalid buffer length or an invalid handle.",
    "category": "functions_cipher"
  },
  "cipher functions overview": {
    "name": "Cipher Functions overview",
    "type": "function",
    "syntax": "function Cipher Functions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cipher"
  },
  "cipher function synopsis": {
    "name": "Cipher Function synopsis",
    "type": "function",
    "syntax": "function Cipher Function synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cipher"
  },
  "app_start": {
    "name": "app_start",
    "type": "function",
    "syntax": "function long app_start (string commandline, string directory, string stdin, string stdout, string stderr)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use function: start.application.local() .",
    "arguments": [
      {
        "type": "string",
        "name": "commandline",
        "description": "This specifies the command that starts the application. If commandline does not include a directory path, Windows searches for the executable file in the following directories, in the order shown below: The directory where BW is loaded. The Windows system directory. The Windows directory. The directories listed in the PATH environment variable."
      },
      {
        "type": "string",
        "name": "directory",
        "description": "The default working directory for the application. Some applications handle the default working directory themselves and are therefore not influenced by the setting of this argument."
      },
      {
        "type": "string",
        "name": "stdin",
        "description": "The standard input file name."
      },
      {
        "type": "string",
        "name": "stdout",
        "description": "The standard output file name."
      },
      {
        "type": "string",
        "name": "stderr",
        "description": "The standard error file name."
      }
    ],
    "returnValue": ">=0 Identification number of the started application is returned. <0 Error. The negative value of the system error",
    "category": "functions_client_file_access"
  },
  "app_status": {
    "name": "app_status",
    "type": "function",
    "syntax": "function long app_status (long app.id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use function: start.application.local() .",
    "arguments": [
      {
        "type": "long",
        "name": "app.id",
        "description": "The ID of the application for which you want to retrieve information, as returned by app_start() ."
      }
    ],
    "returnValue": "<>0 Application is running. 0 Error. Application is not running � probably crashed after activating.",
    "category": "functions_client_file_access"
  },
  "client.add.download.file": {
    "name": "client.add.download.file",
    "type": "function",
    "syntax": "function long client.add.download.file (long id, string source [, string mime.type] [, string target])",
    "description": "Add a file to the list of files to be downloaded to the client. The mime.type can be used to indicate the file type such that the browser has the option to start the client application which is associated with this mime.type. When the mime.type is not specified, the mime.type will be determined based on the file extension of the file specified in the optional target argument. When the optional target argument is also not specified, the mime.type will be determined based on the file extension of the file specified in the source argument Conversion of CRLF characters is only done for text files (file extension .txt or mime.type \"text/plain\"). All other file types are copied in binary mode. This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "the download structure which was created using function: client.prepare.download ."
      },
      {
        "type": "string",
        "name": "source",
        "description": "Specifies the file on the server."
      },
      {
        "type": "[string",
        "name": "mime.type ]",
        "description": "optional string representing the MIME Media type of the file. The official list can be found here: http://www.iana.org/assignments/media-types/index.html"
      },
      {
        "type": "[string",
        "name": "target ]",
        "description": "optional string representing the proposed file name on the client"
      }
    ],
    "returnValue": "0 success <0 when an error occurred (for instance invalid source path)",
    "category": "functions_client_file_access"
  },
  "client.delete.upload.file.object": {
    "name": "client.delete.upload.file.object",
    "type": "function",
    "syntax": "function void client.delete.upload.file.object (long id)",
    "description": "Delete the result object returned by client.upload.files . This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "the id of the result object returned by client.upload.files ."
      }
    ],
    "returnValue": "",
    "category": "functions_client_file_access"
  },
  "client.download.file": {
    "name": "client.download.file",
    "type": "function",
    "syntax": "function long client.download.file (const string source [, string mime.type] [, string target])",
    "description": "Download the server file passed in the source argument to the client. Calling this function will result in a download dialog in which the user can choose to select the file for download. This function will return when the user closes the download dialog. The mime.type can be used to indicate the file type such that the browser has the option to start the client application which is associated with this mime.type. When the mime.type is not specified, the mime.type will be determined based on the file extension of the file specified in the optional target argument. When the optional target argument is also not specified, the mime.type will be determined based on the file extension of the file specified in the source argument. Conversion of CRLF characters is only done for text files (file extension .txt or mime.type \"text/plain\"). All other file types are copied in binary mode. This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "source",
        "description": "Specifies the file on the server."
      },
      {
        "type": "[string",
        "name": "mime.type ]",
        "description": "optional string representing the MIME Media type of the file. The official list can be found here: http://www.iana.org/assignments/media-types/index.html."
      },
      {
        "type": "[string",
        "name": "target ]",
        "description": "optional string representing the proposed file name on the client"
      }
    ],
    "returnValue": "0 success <>0 when an error occurred (for instance invalid source path)",
    "category": "functions_client_file_access"
  },
  "client.get.media.type": {
    "name": "client.get.media.type",
    "type": "function",
    "syntax": "function string client.get.media.type (const string source)",
    "description": "Returns the MIME media type based on the extension of the filename.",
    "arguments": [
      {
        "type": "const string",
        "name": "source",
        "description": "Specifies the file for which to determine the MIME Media type based on its file extension."
      }
    ],
    "returnValue": "string representing the MIME Media type of the file. The official list can be found here: http://www.iana.org/assignments/media-types/index.html.",
    "category": "functions_client_file_access"
  },
  "client.get.upload.file": {
    "name": "client.get.upload.file",
    "type": "function",
    "syntax": "function string client.get.upload.file (long id, long index [, ref string client.filename] [, ref string mime.type])",
    "description": "Get the details about a file which is uploaded with function client.upload.files . This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "the id of the result object returned by client.upload.files ."
      },
      {
        "type": "long",
        "name": "index",
        "description": "one-based index of the uploaded file for which the information is requested."
      },
      {
        "type": "[ref string",
        "name": "client.filename ]",
        "description": "the original name of this file on the client."
      },
      {
        "type": "[ref string",
        "name": "mime.type ]",
        "description": "optional string representing the MIME Media type of the file. The official list can be found here: http://www.iana.org/assignments/media-types/index.html."
      }
    ],
    "returnValue": "The server path name of the uploaded file or empty when an error occurred",
    "category": "functions_client_file_access"
  },
  "client.get.upload.filecount": {
    "name": "client.get.upload.filecount",
    "type": "function",
    "syntax": "function long client.get.upload.filecount (long id)",
    "description": "Get the number of files which are uploaded with function client.upload.files . This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "the id of the result object returned by client.upload.files ."
      }
    ],
    "returnValue": ">0 the number of files uploaded <0 when id is not a valid object returned by client.upload.files",
    "category": "functions_client_file_access"
  },
  "client.prepare.download": {
    "name": "client.prepare.download",
    "type": "function",
    "syntax": "function long client.prepare.download ()",
    "description": "Prepare the download of one or more server files. This function is only supported for LN UI.",
    "arguments": [],
    "returnValue": "<>0 the id of the download structure which can be used by subsequent calls. This id can be passed to client.add.download.file function to add a file to the download or to the client.start.download function to start the download. 0 when an error occurred (for instance when using this function in WebUI or LN UI)",
    "category": "functions_client_file_access"
  },
  "client.show.file": {
    "name": "client.show.file",
    "type": "function",
    "syntax": "function long client.show.file (string source, boolean new.window, string title [, string mime.type] [, string target] [, boolean remove.after.download])",
    "description": "Show the server file passed in the source argument in the browser. The browser can show some file types natively in a browser window (like for example plain text and pdf files). For other file types, the browser will show a browser specific download dialog.",
    "arguments": [
      {
        "type": "string",
        "name": "source",
        "description": "Specifies the server file which must be shown in the browser."
      },
      {
        "type": "boolean",
        "name": "new.window",
        "description": "When this option is true, the server file is shown in a new browser window. Otherwise this file is shown in a frame embedded in the current browser window."
      },
      {
        "type": "string",
        "name": "title",
        "description": "Specifies the title for the browser window or frame."
      },
      {
        "type": "[string",
        "name": "mime.type ]",
        "description": "This optional argument can be used to indicate the file type such that the browser has the option to start the plugin which is associated with this mime.type. When the mime.type is not specified, the mime.type will be determined based on the file extension of the file specified in the source argument."
      },
      {
        "type": "[string",
        "name": "target ]",
        "description": "optional string representing the proposed file name on the client"
      },
      {
        "type": "[boolean",
        "name": "remove.after.download ]",
        "description": "When this optional argument is true, the file on the server is automatically removed after the file is downloaded by the client. The default value is false."
      }
    ],
    "returnValue": "0 success <0 when an error occured (for instance invalid source path)",
    "category": "functions_client_file_access"
  },
  "client.show.url": {
    "name": "client.show.url",
    "type": "function",
    "syntax": "function long client.show.url (string url)",
    "description": "This function opens a URL in a Document Viewer session. This function is only supported in the WebUI and LN UI.",
    "arguments": [
      {
        "type": "string",
        "name": "url",
        "description": "This specifies the URL that needs to be started."
      }
    ],
    "returnValue": "0 success <0 when an error occured (for instance invalid source path)",
    "category": "functions_client_file_access"
  },
  "client.start.download": {
    "name": "client.start.download",
    "type": "function",
    "syntax": "function long client.start.download (long id)",
    "description": "Start a download dialog showing a list of files constructed in advance with the functions client.prepare.download and client.add.download.file This function will return when the user closes the download dialog. This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "the download structure which was created using function: client.prepare.download ."
      }
    ],
    "returnValue": "0 success <0 when an error occurred (for instance invalid id)",
    "category": "functions_client_file_access"
  },
  "client.upload.file": {
    "name": "client.upload.file",
    "type": "function",
    "syntax": "function long client.upload.file (string destination [, ref string client.filename] [, ref string mime.type])",
    "description": "Upload a single file from the client and save this file on the server in the file location passed as the destination argument. Conversion of CRLF characters is only done for text files (file extension .txt or mime.type \"text/plain\"). All other file types are copied in binary mode. This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "string",
        "name": "destination",
        "description": "the file on the server to which the client file will be uploaded (user must have write permission)."
      },
      {
        "type": "[ref string",
        "name": "client.filename ]",
        "description": "the original name of this file on the client"
      },
      {
        "type": "[ref string",
        "name": "mime.type ]",
        "description": "optional string representing the MIME Media type of the file. The official list can be found here: http://www.iana.org/assignments/media-types/index.html."
      }
    ],
    "returnValue": "0 success <0 when an error occurred (for instance destination is a directory)",
    "category": "functions_client_file_access"
  },
  "client.upload.files": {
    "name": "client.upload.files",
    "type": "function",
    "syntax": "function long client.upload.files (string destination)",
    "description": "Upload one or more files from the client and save these files in a server directory. Conversion of CRLF characters is only done for text files (file extension .txt or mime.type \"text/plain\"). All other file types are copied in binary mode. This function returns an id that can be used in the function client.get.upload.file to obtain information of an uploaded file. This function is only supported for LN UI.",
    "arguments": [
      {
        "type": "string",
        "name": "destination",
        "description": "the file on the server to which the client file will be uploaded (user must have write permission)."
      }
    ],
    "returnValue": "<>0 the id of the result object to be used by subsequent functions. This result object must be deleted using the function: client.delete.upload.file.object 0 when an error occurred (for instance destination is a directory)",
    "category": "functions_client_file_access"
  },
  "client2server": {
    "name": "client2server",
    "type": "function",
    "syntax": "function long client2server (string source, string dest, boolean text.mode [, boolean rm.file] [, boolean progress.window])",
    "description": "Deprecated. This copies a specified file from the client to the server.",
    "arguments": [
      {
        "type": "string",
        "name": "source",
        "description": "The source file name, on the client. When this is an empty string, this function will show the file open dialog, through which the user can select an existing file on the client. The function get.local.filename() can be used afterwards to retrieve the actual filename on the client which was copied. The source parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "string",
        "name": "dest",
        "description": "The destination file name, on the server."
      },
      {
        "type": "boolean",
        "name": "text.mode",
        "description": "This is a boolean value that specifies whether the file is to be copied in text or binary mode: true text mode false binary mode"
      },
      {
        "type": "[boolean",
        "name": "rm.file ]",
        "description": "Use this optional argument to specify whether the source file must be deleted after it has been copied: true source file is deleted false source file is not deleted"
      },
      {
        "type": "[boolean",
        "name": "progress.window ]",
        "description": "Use this optional argument to specify whether a progress indicator must be displayed to indicate the progress of the copy action: true progress indicator is displayed false progress indicator is not displayed"
      }
    ],
    "returnValue": "0 File copy success. 1 Error. File copy canceled by the user. <0 Error. Source file not copied to the destination file.",
    "category": "functions_client_file_access"
  },
  "color.dialog": {
    "name": "color.dialog",
    "type": "function",
    "syntax": "function void color.dialog (ref long io.color)",
    "description": "This shows a color selection dialog, to allow the user to select a color. The selected color is then reported back to the application when the dialog box exits.",
    "arguments": [
      {
        "type": "ref long",
        "name": "io.color",
        "description": "Input/Output argument which contains the RGB value of the selected color."
      }
    ],
    "returnValue": "",
    "category": "functions_client_file_access"
  },
  "create.local.directory": {
    "name": "create.local.directory",
    "type": "function",
    "syntax": "function long create.local.directory (string dirent)",
    "description": "Deprecated. This creates a specified directory on a client system. You must have write permission in the parent directory to do this. Access permissions for the new directory are set to read and write for all users.",
    "arguments": [
      {
        "type": "string",
        "name": "dirent",
        "description": ""
      }
    ],
    "returnValue": "0 Success. <>0 Error. Probably no permission.",
    "category": "functions_client_file_access"
  },
  "create.local.file": {
    "name": "create.local.file",
    "type": "function",
    "syntax": "function long create.local.file (string filename)",
    "description": "Deprecated. This creates a specified file on a client system. You must have write permission in the parent directory to do this. Access permissions for the new file are set to read and write, for all users. When the file does already exist, it will be truncated.",
    "arguments": [
      {
        "type": "string",
        "name": "filename",
        "description": "The full path name of the file. For example: create.local.file(\"C:\\Program Files\\mydir\\myfile\") The filename parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      }
    ],
    "returnValue": "0 Success. <>0 Error. Probably no permission.",
    "category": "functions_client_file_access"
  },
  "dir.select.dialog.local": {
    "name": "dir.select.dialog.local",
    "type": "function",
    "syntax": "function long dir.select.dialog.local (ref string dirname)",
    "description": "Deprecated. This shows the Windows Browse For Folder dialog, to allow the user to select one new or existing folder (directory) on the client.",
    "arguments": [
      {
        "type": "ref string",
        "name": "dirname",
        "description": "Output argument which will contain the full path of the directory selected by the user."
      }
    ],
    "returnValue": "1 A directory selected by the user 0 No directory selected. Folder browser dialog canceled by the user. -1 Error occurred",
    "category": "functions_client_file_access"
  },
  "get.client.directory": {
    "name": "get.client.directory",
    "type": "function",
    "syntax": "function string get.client.directory (const string id)",
    "description": "Deprecated. This function returns the folder, on the local client, related to a given id. In case of Baan Windows this is the folder that is defined by the ${id} environment variable on the local client. In case of WebUI, this is a folder, on the client machine on which the Internet Browser is running, related to the id.",
    "arguments": [
      {
        "type": "const string",
        "name": "id",
        "description": "Input argument which will contain the id for which to determine the related client folder. In WebUI only the \"BSE_TMP\" id is supported."
      }
    ],
    "returnValue": "The folder related to the given id. In case of Baan Windows, the return value contains the value of the ${BSE_TMP} client environment variable. In case of WebUI, the return value contains the name of the default temporary folder on the client machine. The return value is empty when an id is used for which no folder was defined.",
    "category": "functions_client_file_access"
  },
  "get.client.hostname": {
    "name": "get.client.hostname",
    "type": "function",
    "syntax": "function long get.client.hostname (ref string hostname)",
    "description": "This returns the hostname of the local client (if available). In case of Baan Windows this is the client machine on which BW is running. In case of WebUI, this is the client machine on which the Internet Browser is running.",
    "arguments": [
      {
        "type": "ref string",
        "name": "hostname",
        "description": "Output argument which will contain the fully qualified hostname of the client on return of this function."
      }
    ],
    "returnValue": "true Function succeeded, hostname is filled. false Function failed, client hostname is unknown.",
    "category": "functions_client_file_access"
  },
  "get.client.ip.address": {
    "name": "get.client.ip.address",
    "type": "function",
    "syntax": "function long get.client.ip.address (ref string ip.address)",
    "description": "Get the IP address of the local client. In case of Baan Windows this is the client machine on which BW is running. In case of WebUI, this is the client machine on which the Internet Browser is running",
    "arguments": [
      {
        "type": "ref string",
        "name": "ip.address",
        "description": "Output argument which will contain the IP address of the client on return of this function."
      }
    ],
    "returnValue": "true Function succeeded, IP adress is filled. false Function failed, client IP address is unknown.",
    "category": "functions_client_file_access"
  },
  "get.client.timezone": {
    "name": "get.client.timezone",
    "type": "function",
    "syntax": "function string get.client.timezone ()",
    "description": "This returns the current Windows Timezone name of the local client (if available).",
    "arguments": [],
    "returnValue": "The current Windows Timezone name of the client. The maximum length is 32 characters.",
    "category": "functions_client_file_access"
  },
  "get.local.filename": {
    "name": "get.local.filename",
    "type": "function",
    "syntax": "function string get.local.filename ()",
    "description": "Deprecated. This function returns the last client filename used by the function server2client() or client2server() . When the last server2client() or client2server() function failed, this function will return an empty string.",
    "arguments": [],
    "returnValue": "The client filename or an empty string",
    "category": "functions_client_file_access"
  },
  "open.url.local": {
    "name": "open.url.local",
    "type": "function",
    "syntax": "function boolean open.url.local (string url, long mode [, string dialog.title] [, string dialog.message] [, string browser.title] [, string redir.param] [, ref long params.node])",
    "description": "This function opens a URL in an (embedded) browser. This function is only supported in WebUI and LN UI.",
    "arguments": [
      {
        "type": "string",
        "name": "url",
        "description": "This specifies the URL that needs to be started."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "Specifies the start mode of the browser. Possible values are: OPEN_URL_EXTERNAL: Open the URL in an new tab of the browser. OPEN_URL_INTERNAL: Open the URL embeded in the WebUI or LN UI. OPEN_URL_WAIT: Open the URL embeded in the WebUI or LN UI and block the current session till the browser window is closed."
      },
      {
        "type": "[string",
        "name": "dialog.title ]",
        "description": "When the browser is started in the mode OPEN_URL_WAIT a modal dialog is created for the session. If this dialog should have a title then the parameter dialog.title must be filled. This argument is optional and is only applicable for the OPEN_URL_WAIT mode."
      },
      {
        "type": "[string",
        "name": "dialog.message ]",
        "description": "When the browser is started in the mode OPEN_URL_WAIT a modal dialog is created for the session. If this dialog should have a message the parameter dialog.message must be filled. This argument is optional and is only applicable for the OPEN_URL_WAIT mode."
      },
      {
        "type": "[string",
        "name": "browser.title ]",
        "description": "When the browser is started in the mode OPEN_URL_WAIT or OPEN_URL_INTERNAL , this is the title of the new WebUI or LN UI Tab."
      },
      {
        "type": "[string",
        "name": "redir.param ]",
        "description": "The name of the URL parameter which must be added to the URL. The value of this URL parameter is set to a redirect URL which will close the embeded browser window. This parameter is only used when mode is OPEN_URL_WAIT."
      },
      {
        "type": "[ref long",
        "name": "params.node ]",
        "description": "This parameter is only used when mode is OPEN_URL_WAIT and redir.param is filled. When the open.url.local() function returns, this parameter might be filled with an XML node. The attributes in this XML node are the values returned by the web paged."
      }
    ],
    "returnValue": "true Browser application started successfully. false iBrowser application failed to start.",
    "category": "functions_client_file_access"
  },
  "client file access overview": {
    "name": "Client file access overview",
    "type": "function",
    "syntax": "function Client file access overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_client_file_access"
  },
  "remove.local.directory": {
    "name": "remove.local.directory",
    "type": "function",
    "syntax": "function long remove.local.directory (string dirent)",
    "description": "This deletes a specified directory on the client system.",
    "arguments": [
      {
        "type": "string",
        "name": "dirent",
        "description": "directory, including the drive name. For example: remove.local.directory(\"C:\\Program Files\\Mydir\") The directory will only be removed when the directory is empty. The dirent parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      }
    ],
    "returnValue": "0 Success. <>0 Error. Probably directory not empty or no permission.",
    "category": "functions_client_file_access"
  },
  "remove.local.file": {
    "name": "remove.local.file",
    "type": "function",
    "syntax": "function long remove.local.file (string filename)",
    "description": "Deprecated. This deletes a specified file on the client system.",
    "arguments": [
      {
        "type": "string",
        "name": "filename",
        "description": "The name of the file that must be deleted. The name must include the full path tot the file, including the drive. For example: remove.local.file(\"C:\\Program Files\\Mydir\\Myfile.txt\") The filename parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      }
    ],
    "returnValue": ">=0 Success. <0 Error; The negative value of the operating system error.",
    "category": "functions_client_file_access"
  },
  "seq.close.local": {
    "name": "seq.close.local",
    "type": "function",
    "syntax": "function void seq.close.local (long lfn)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use functions: server2client() or client2server() .",
    "arguments": [
      {
        "type": "long",
        "name": "lfn",
        "description": "The file pointer to the file that must be closed, as returned by seq.open.local() when the file was opened."
      }
    ],
    "returnValue": "",
    "category": "functions_client_file_access"
  },
  "seq.fstat.local": {
    "name": "seq.fstat.local",
    "type": "function",
    "syntax": "function long seq.fstat.local (string filename, ref long nr.bytes)",
    "description": "Deprecated. This retrieves information about a specified file on a client system.",
    "arguments": [
      {
        "type": "string",
        "name": "filename",
        "description": "The path argument must include the The full path to the file , including the drive name. This parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "ref long",
        "name": "nr.bytes",
        "description": "This returns the size of the file in bytes."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. Probably file does not exist. The number is operating system dependent and varies according to the type of filesystem and type of file that is queried. Common values are: -2: File not found -3: Path not found -5: Permission denied -32: Sharing violation See windows error codes (on MSDN, for example) for details on a specific error.",
    "category": "functions_client_file_access"
  },
  "seq.open.dialog.local": {
    "name": "seq.open.dialog.local",
    "type": "function",
    "syntax": "function long seq.open.dialog.local (boolean mselect, string defaultname, string directory, string filter, ref string filename)",
    "description": "Deprecated. This shows the Windows file-open dialog, to allow the user to select one or more local files.",
    "arguments": [
      {
        "type": "boolean",
        "name": "mselect",
        "description": "When true, multiple select is allowed by the user else only one file can be selected by the user."
      },
      {
        "type": "string",
        "name": "defaultname",
        "description": "The default filename shown in the file-open dialog."
      },
      {
        "type": "string",
        "name": "directory",
        "description": "The startup directory for this dialog. In case of an empty string the \"My Documents\" directory will be the default. This parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "string",
        "name": "filter",
        "description": "This argument specifies all possible file extensions for the file. The string must contain pairs of strings that are separated by a \"|\" character. The first string in each pair is a filter name (for example: \"Text Files\"). The second string must be a filter patern (for example: \"*.txt\"). Multiple filter patters can be specified by separating the filter patterns with a semicolon. Example: \"All Files(*.*)|*.*|Text Files(*.txt) Word documents(*.doc)|*.txt;*.doc\""
      },
      {
        "type": "ref string",
        "name": "filename",
        "description": "Output argument which will contain the full path of the file selected by the user. In case mselect is true possible other selected file names can be retrieved using function seq.open.dialog.next()"
      }
    ],
    "returnValue": ">0 Number of files selected by the user. 0 File open dialog canceled by the user. -1 Error occurred",
    "category": "functions_client_file_access"
  },
  "seq.open.dialog.next": {
    "name": "seq.open.dialog.next",
    "type": "function",
    "syntax": "function long seq.open.dialog.next (ref string filename)",
    "description": "Deprecated. Retrieve the next full pathname of the file selected by the user in a previous seq.open.dialog.local() function. This function should only be used when a previous call to seq.open.dialog.local() returned a value greater than 1.",
    "arguments": [
      {
        "type": "ref string",
        "name": "filename",
        "description": "Output argument which will contain the next full path of the file selected by the user."
      }
    ],
    "returnValue": "true Successfully retrieved next filename false No more filenames to be retrieved",
    "category": "functions_client_file_access"
  },
  "seq.open.local": {
    "name": "seq.open.local",
    "type": "function",
    "syntax": "function long seq.open.local (string filename, string mode(2) [, long remove.after.use])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use functions: server2client() or client2server() .",
    "arguments": [
      {
        "type": "string",
        "name": "filename",
        "description": "The name of the file that must be opened. If you do not specify a path name, the file is searched for in the directory where BW is loaded."
      },
      {
        "type": "string",
        "name": "mode(2)",
        "description": "The mode in which the file must be opened. This can be one of the following options: \"r\" Open for reading. w\" Create for writing. \"a\" Open for writing at end of file, or create for writing. In addition, you can add \"t\" to any of the above options if you want the file to be opened in text mode."
      },
      {
        "type": "[long",
        "name": "remove.after.use ]",
        "description": "Use this optional argument to specify whether or not the file must be removed after it has been closed by seq.close.local() : <>0 file is removed 0 file is not removed"
      }
    ],
    "returnValue": ">=0 Success. File pointer is returned. <0 Error. File could not be opened.",
    "category": "functions_client_file_access"
  },
  "seq.read.local": {
    "name": "seq.read.local",
    "type": "function",
    "syntax": "function long seq.read.local (ref string buf, ref long size, long lfn)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use function: client2server() .",
    "arguments": [
      {
        "type": "ref string",
        "name": "buf",
        "description": "This returns the data read from the file."
      },
      {
        "type": "ref long",
        "name": "size",
        "description": "This returns the number of bytes read from the file."
      },
      {
        "type": "long",
        "name": "lfn",
        "description": "The file pointer, as returned by seq.open.local() when the file was opened."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. Probably lfn not connected.",
    "category": "functions_client_file_access"
  },
  "seq.saveas.dialog.local": {
    "name": "seq.saveas.dialog.local",
    "type": "function",
    "syntax": "function long seq.saveas.dialog.local (string defaultname, string directory, string filter, ref string filename)",
    "description": "Deprecated. This shows the Windows file save-as dialog, to allow the user to select a new or existing local file to be saved.",
    "arguments": [
      {
        "type": "string",
        "name": "defaultname",
        "description": "The default filename shown in the file save-as dialog."
      },
      {
        "type": "string",
        "name": "directory",
        "description": "The startup directory for this dialog. In case of an empty string the \"My Documents\" directory will be the default. This parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "string",
        "name": "filter",
        "description": "This argument specifies all possible file extensions for the file. The string must contain pairs of strings that are separated by a \"|\" character. The first string in each pair is a filter name (for example: \"Text Files\"). The second string must be a filter patern (for example: \"*.txt\"). Multiple filter patters can be specified by separating the filter patterns with a semicolon. Example: \"All Files(*.*)|*.*|Text Files(*.txt) Word documents(*.doc)|*.txt;*.doc\""
      },
      {
        "type": "ref string",
        "name": "filename",
        "description": "Output argument which will contain the full path of the file selected by the user."
      }
    ],
    "returnValue": "1 One file selected by the user. 0 File save-as dialog canceled by the user. -1 Error occurred",
    "category": "functions_client_file_access"
  },
  "seq.write.local": {
    "name": "seq.write.local",
    "type": "function",
    "syntax": "function long seq.write.local (long buf, long size, long lfn)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated. Instead you should use function: server2client() .",
    "arguments": [
      {
        "type": "long",
        "name": "buf",
        "description": "The data that must be written to the file."
      },
      {
        "type": "long",
        "name": "size",
        "description": "The number of bytes that must be written to the file."
      },
      {
        "type": "long",
        "name": "lfn",
        "description": "The file pointer, as returned by seq.open.local() when the file was opened."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. Probably lfn not connected.",
    "category": "functions_client_file_access"
  },
  "server2client": {
    "name": "server2client",
    "type": "function",
    "syntax": "function long server2client (string source, string dest, boolean text.mode [, boolean progress.window] [, boolean read.only])",
    "description": "Deprecated. This copies a specified file from the server to the client.",
    "arguments": [
      {
        "type": "string",
        "name": "source",
        "description": "The source file name, on the server."
      },
      {
        "type": "string",
        "name": "dest",
        "description": "The destination file name, on the client. When this is an empty string, this function will show the file save-as dialog through which the user can select an existing file or enter the name of a new file on the client. The function get.local.filename() can be used afterwards to retrieve the actual filename on the client to which the file was copied. The dest parameter may include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "boolean",
        "name": "text.mode",
        "description": "This argument specifies whether the file is to be copied in text or binary mode: true text mode false binary mode"
      },
      {
        "type": "[boolean",
        "name": "progress.window ]",
        "description": "Use this optional argument to specify whether a progress indicator must be displayed to indicate the progress of the copy action: true progress indicator is displayed false progress indicator is not displayed this is the default"
      },
      {
        "type": "[boolean",
        "name": "read.only ]",
        "description": "When creating a file on the client side, this attribute can be used to set the file attributes to readonly mode after the file has been transferred. true file is set to readonly mode false file remains in read/write mode this is the default"
      }
    ],
    "returnValue": "0 File copy success. 1 Error. File copy canceled by the user. <0 Error. Source file not copied to the destination file.",
    "category": "functions_client_file_access"
  },
  "start.application.local": {
    "name": "start.application.local",
    "type": "function",
    "syntax": "function boolean start.application.local (string commandline, boolean waitFlag, ref long exitCode [, const string verb])",
    "description": "Deprecated. This starts the client application specified in the commandline argument.",
    "arguments": [
      {
        "type": "string",
        "name": "commandline",
        "description": "This specifies the command that starts the application. If commandline does not include a directory path, Windows searches for the executable file in the following directories, in the order shown below: The Windows system directory. The Windows directory. The directories listed in the PATH environment variable. This argument may also contain the full pathname of a local document. In this case the application associated with this document extension will be started. The commandline parameter may one or more times include the string ${BSE_TMP} which indicates the ${BSE}\\tmp directory in case of Baan Windows or Windows temp directory in case of WebUI."
      },
      {
        "type": "boolean",
        "name": "waitFlag",
        "description": "Indicates whether the application must wait for the local application to exit."
      },
      {
        "type": "ref long",
        "name": "exitCode",
        "description": "Exit code of local application. Only contains a valid exit code when the waitFlag attribute was true"
      },
      {
        "type": "[const string",
        "name": "verb ]",
        "description": "When the commandline argument contains a document pathname, the optional verb argument may contain the action to be performed on this document. The default action is \"open\" . Another useful verb is: \"print\" . In case this argument is supplied, the waitFlag argument will be ignored and the execution will always by asynchronous."
      }
    ],
    "returnValue": "true Application started successfully. false Application failed to start.",
    "category": "functions_client_file_access"
  },
  "client file access synopsis": {
    "name": "Client file access synopsis",
    "type": "function",
    "syntax": "function Client file access synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_client_file_access"
  },
  "blue.component, green.component, red.component": {
    "name": "blue.component, green.component, red.component",
    "type": "function",
    "syntax": "function long blue.component (long color)",
    "description": "These return the values of the blue, green, and red components respectively of an rgb color.",
    "arguments": [
      {
        "type": "long",
        "name": "color",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_color"
  },
  "colors overview": {
    "name": "Colors overview",
    "type": "function",
    "syntax": "function Colors overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_color"
  },
  "rgb": {
    "name": "rgb",
    "type": "function",
    "syntax": "function long rgb (long red, long green, long blue)",
    "description": "Use this to compose a color by specifying its red, green, and blue intensities. The intensities must be in the range 0 to 255.",
    "arguments": [
      {
        "type": "long",
        "name": "red",
        "description": ""
      },
      {
        "type": "long",
        "name": "green",
        "description": ""
      },
      {
        "type": "long",
        "name": "blue",
        "description": ""
      }
    ],
    "returnValue": "A long which can be used as a color in graphical contexts such as windows, user interface controls, and so on.",
    "category": "functions_color"
  },
  "colors synopsis": {
    "name": "Colors synopsis",
    "type": "function",
    "syntax": "function Colors synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_color"
  },
  "compnr.check": {
    "name": "compnr.check",
    "type": "function",
    "syntax": "function boolean compnr.check (long new_compnr)",
    "description": "This switches to another company and sets the read-only variable COMPNR to the specified company number. It checks whether the current session may be started in the specified company, and if so it switches.",
    "arguments": [
      {
        "type": "long",
        "name": "new_compnr",
        "description": ""
      }
    ],
    "returnValue": "true Session may be started in specified company; Company switched. false Session may not be started in specified company;; Company not switched.",
    "category": "functions_company_operations"
  },
  "get.appl.data.company": {
    "name": "get.appl.data.company",
    "type": "function",
    "syntax": "function long get.appl.data.company (string package(2), string application.id(30) Application Identifier see ttadv4589m000)",
    "description": "This function read the application data company for a user. First a search for the setting of the current user is done. If there is no setting for the current user available, the generic settings for the environment is read.",
    "arguments": [
      {
        "type": "string",
        "name": "package(2)",
        "description": ""
      },
      {
        "type": "string",
        "name": "application.id(30) Application Identifier see ttadv4589m000",
        "description": ""
      }
    ],
    "returnValue": "Company number Success. -1 Company not found for the package application ID.",
    "category": "functions_company_operations"
  },
  "get.company": {
    "name": "get.company",
    "type": "function",
    "syntax": "function string get.company ()",
    "description": "This returns the name of the current company.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_company_operations"
  },
  "get.compnr": {
    "name": "get.compnr",
    "type": "function",
    "syntax": "function long get.compnr ()",
    "description": "This returns the ID number of the current company.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_company_operations"
  },
  "get.financial.compnr": {
    "name": "get.financial.compnr",
    "type": "function",
    "syntax": "function long get.financial.compnr ()",
    "description": "This returns the ID number of the current financial company.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_company_operations"
  },
  "get.logistic.compnr": {
    "name": "get.logistic.compnr",
    "type": "function",
    "syntax": "function long get.logistic.compnr ()",
    "description": "This returns the ID number of the current logistic company.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_company_operations"
  },
  "company operations overview and synopsis": {
    "name": "Company operations overview and synopsis",
    "type": "function",
    "syntax": "function Company operations overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_company_operations"
  },
  "switch.to.company": {
    "name": "switch.to.company",
    "type": "function",
    "syntax": "function long switch.to.company (long new_compnr)",
    "description": "This switches to another company and sets the read-only variable COMPNR to the specified company number. It performs several checks before switching company and switches company only if the checks are successful. For example, it checks if the user is authorized to change to the new company, it checks if the package combination linked to the old company contains the same package VRC's as the package combination linked to the new company, and it checks if the old and new companies have the same first day of the week.",
    "arguments": [
      {
        "type": "long",
        "name": "new_compnr",
        "description": ""
      }
    ],
    "returnValue": "1 Success. -1 Company not available. -2 No permission to change to this company. -3 Package combination does not correspond with new company number. -4 First day of the week does not correspond to first day of the week of original company.",
    "category": "functions_company_operations"
  },
  "cps.add.child": {
    "name": "cps.add.child",
    "type": "function",
    "syntax": "function long cps.add.child (const string session.code, long bars, const string title, long splitpane)",
    "description": "Add a child session to this controller, which will be shown and started in the frame of the composite controller. This session will be shown in the passed split pane. To a split pane exactly two objects must be added: sessions and/or split panes. The order of adding these objects to the split pane determines the order on the screen (left/right or top/bottom).",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "The code of the child session"
      },
      {
        "type": "long",
        "name": "bars",
        "description": "Indicates which bars must be shown for this composite child. Possible values are:CPS.TOOLBAR and CPS.MENUBAR. These values can be combined for instance: CPS.TOOLBAR+CPS.MENUBAR"
      },
      {
        "type": "const string",
        "name": "title",
        "description": "Contains the title string for this child session. When empty, no title bar will be shown for this composite child session."
      },
      {
        "type": "long",
        "name": "splitpane",
        "description": "id of the split pane in which this session will be shown"
      }
    ],
    "returnValue": "0 on success -1 on failure",
    "category": "functions_composite_sessions"
  },
  "cps.create.splitpane": {
    "name": "cps.create.splitpane",
    "type": "function",
    "syntax": "function long cps.create.splitpane (long orientation, long divider [, long splitpane])",
    "description": "Create a split pane which can either hold another split pane or a child session. There can only be one top-level split pane created. This function may not be called before the call to cps.init()",
    "arguments": [
      {
        "type": "long",
        "name": "orientation",
        "description": "Specifies the splitter orientation: CPS.HORIZONTAL or CPS.VERTICAL"
      },
      {
        "type": "long",
        "name": "divider",
        "description": "Specifies the divider location as a percentage of the split panes total size. This must be a number between 0 and 100."
      },
      {
        "type": "[long",
        "name": "splitpane ]",
        "description": "optional id of the parent splitpane"
      }
    ],
    "returnValue": "<>0 The id of the created splitpane 0 When this funcion fails",
    "category": "functions_composite_sessions"
  },
  "cps.init": {
    "name": "cps.init",
    "type": "function",
    "syntax": "function long cps.init ()",
    "description": "Initialize the Composite Session Controller. This must be the first cps function called by the 3GL-Script. When this session was started from a parent session in modeless mode, this function will reactive the parent session. So any imports which must be done by this session from the parent should be done before this function is called.",
    "arguments": [],
    "returnValue": "0 on success -1 on failure",
    "category": "functions_composite_sessions"
  },
  "cps.start": {
    "name": "cps.start",
    "type": "function",
    "syntax": "function void cps.start ()",
    "description": "Activates the Composite Session Controller and the related child sessions. This function will only return when the user decides to close this composite session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "cps.status.mess": {
    "name": "cps.status.mess",
    "type": "function",
    "syntax": "function void cps.status.mess (const string message)",
    "description": "This function displays the specified message in the status bar of a composite session. To clear this message, an empty message string must be passed. This function can be called from composite child sessions (GBF or 4GL). When this function is called from other session types, it will do nothing.",
    "arguments": [
      {
        "type": "const string",
        "name": "message",
        "description": "The the message to be shown in the composite status bar"
      }
    ],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "enable.drag": {
    "name": "enable.drag",
    "type": "function",
    "syntax": "function void enable.drag ()",
    "description": "Enable dragging objects from this 4GL-session to other sessions. This function must be called from the before.program: section or from the after.form.read: section of a multi-occurrence 4GL-Session which runs as a composite child.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "enable.drop": {
    "name": "enable.drop",
    "type": "function",
    "syntax": "function void enable.drop (const string session.code, const string on.drop.function)",
    "description": "Allow drop operation onto this 4GL-Session from objects dragged from the indicated sessions. When an object from the indicated session is dropped, the function passed in string on.drop.function will be called. This function can be called more than once in order to allow drop operations from different sessions. This function must be called from the before.program: section or from the after.form.read: section of a multi-occurrence 4GL-Session which runs as a composite child.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "Code of the session from which objects can be dropped"
      },
      {
        "type": "const string",
        "name": "on.drop.function",
        "description": "The name of the function that will be called when a drop event occurs. This function must be declared as described here: on.drop() ."
      }
    ],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "composite sessions code examples": {
    "name": "Composite Sessions Code Examples",
    "type": "function",
    "syntax": "function Composite Sessions Code Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "is.composite.child": {
    "name": "is.composite.child",
    "type": "function",
    "syntax": "function boolean is.composite.child ()",
    "description": "This function checks whether the current session is running as a composite child session or not. This function can be useful when a session can be run in standalone mode and as a child within a composite session. This function can be called from a 4GL-Session or from a GBF session.",
    "arguments": [],
    "returnValue": "true this session is running as a composite child session false otherwise",
    "category": "functions_composite_sessions"
  },
  "on.drop": {
    "name": "on.drop",
    "type": "function",
    "syntax": "function void on.drop (long from.pid, long collection, boolean copy)",
    "description": "Call back function which is passed in function enable.drop() . This function will be called when a drop event from the associated session arrives. In this function the business logic related to the drop operation must be implemented. In case database table updates are done in this function, the function must also commit the transaction.",
    "arguments": [
      {
        "type": "long",
        "name": "from.pid",
        "description": "process id of the session from which the objects are dropped"
      },
      {
        "type": "long",
        "name": "collection",
        "description": "collection of keyfield objects which are dropped on this session"
      },
      {
        "type": "boolean",
        "name": "copy",
        "description": "when true, the user indicated that a copy operation is requested (CTRL key pressed during drop operation). Otherwise a move operation is required"
      }
    ],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "composite sessions overview": {
    "name": "Composite Sessions overview",
    "type": "function",
    "syntax": "function Composite Sessions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "composite sessions synopsis": {
    "name": "Composite Sessions synopsis",
    "type": "function",
    "syntax": "function Composite Sessions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_composite_sessions"
  },
  "curl.cleanup": {
    "name": "curl.cleanup",
    "type": "function",
    "syntax": "function void curl.cleanup ()",
    "description": "End cURL session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.create.oauth1.authorization.header": {
    "name": "curl.create.oauth1.authorization.header",
    "type": "function",
    "syntax": "function long curl.create.oauth1.authorization.header (const string method, const string url, const string consumer.key, const string consumer.secret, ref string header)",
    "description": "Creates an OAuth 1.0 authorization header. Note that this function returns the header value, it must added to the HTTP request with header name \"Authorization\".",
    "arguments": [
      {
        "type": "const string",
        "name": "method",
        "description": "the HTTP method, specify \"GET\" or \"POST\"."
      },
      {
        "type": "const string",
        "name": "url",
        "description": "the URL of the request."
      },
      {
        "type": "const string",
        "name": "consumer.key",
        "description": "the Consumer Key for OAuth 1.0."
      },
      {
        "type": "const string",
        "name": "consumer.secret",
        "description": "the Consumer Secret for OAuth 1.0."
      },
      {
        "type": "ref string",
        "name": "header",
        "description": "the created Authorization header"
      }
    ],
    "returnValue": "0 Ok > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.download.data": {
    "name": "curl.download.data",
    "type": "function",
    "syntax": "function long curl.download.data (const string url, ref string data, ref long data.size [, long header.list])",
    "description": "Downloads data from the specified url and writes it to the specified data buffer. Note that the buffer must be large enough to store all downloaded data.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url from where the data must be downloaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "ref string",
        "name": "data",
        "description": "the data buffer to write the downloaded data to"
      },
      {
        "type": "ref long",
        "name": "data.size",
        "description": "the number of bytes downloaded"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append()"
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.download.file": {
    "name": "curl.download.file",
    "type": "function",
    "syntax": "function long curl.download.file (const string url, const string file [, long header.list])",
    "description": "Downloads data from the specified url and writes it to the specified file.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url from where the data must be downloaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "const string",
        "name": "file",
        "description": "the name of the file to write the downloaded data to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append()"
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.download.stream": {
    "name": "curl.download.stream",
    "type": "function",
    "syntax": "function long curl.download.stream (const string url, long response.stream [, long header.list])",
    "description": "Downloads data from the specified url and writes it to the specified stream, which can be either a file or a memory stream.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url from where the data must be downloaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "long",
        "name": "response.stream",
        "description": "the stream to write the downloaded data to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append()"
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.download.string": {
    "name": "curl.download.string",
    "type": "function",
    "syntax": "function long curl.download.string (const string url, ref string data [, long header.list])",
    "description": "Downloads data from the specified url and writes it to the specified string buffer. Note that the string buffer must be large enough to store all data. The data will be null terminated, if possible.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url from where the data must be downloaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "ref string",
        "name": "data",
        "description": "the string buffer to write the downloaded data to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append()"
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.escape.decode$": {
    "name": "curl.escape.decode$",
    "type": "function",
    "syntax": "function string curl.escape.decode$ (const string SomeText)",
    "description": "curl.escape.decode$() offers the inverse functionality of curl.escape.encode$().",
    "arguments": [
      {
        "type": "const string",
        "name": "SomeText",
        "description": "Pass a string with escape sequences, which need to be replaced."
      }
    ],
    "returnValue": "Contains an string without escape sequences.",
    "category": "functions_cURL"
  },
  "curl.escape.encode$": {
    "name": "curl.escape.encode$",
    "type": "function",
    "syntax": "function string curl.escape.encode$ (const string SomeText)",
    "description": "Escape a string",
    "arguments": [
      {
        "type": "const string",
        "name": "SomeText",
        "description": "Pass a string with special characters, which need to be escaped."
      }
    ],
    "returnValue": "Contains an escaped string",
    "category": "functions_cURL"
  },
  "curl.escape.encode.ext$": {
    "name": "curl.escape.encode.ext$",
    "type": "function",
    "syntax": "function string curl.escape.encode.ext$ (const string(2,128) EscapeTable, const string SomeText)",
    "description": "Escape special characters",
    "arguments": [
      {
        "type": "const string(2,128)",
        "name": "EscapeTable",
        "description": "Two dimensional array with escape table to be used."
      },
      {
        "type": "const string",
        "name": "SomeText",
        "description": "String to be escaped"
      }
    ],
    "returnValue": "...",
    "category": "functions_cURL"
  },
  "curl.escape.gettable": {
    "name": "curl.escape.gettable",
    "type": "function",
    "syntax": "function void curl.escape.gettable (ref string(2,128) EscapeTable)",
    "description": "Returns a string array with an escapetable.",
    "arguments": [
      {
        "type": "ref string(2,128)",
        "name": "EscapeTable",
        "description": "Two dimensional array with escape table"
      }
    ],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl ftp example": {
    "name": "cURL FTP example",
    "type": "function",
    "syntax": "function cURL FTP example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.get.errorbuffer$": {
    "name": "curl.get.errorbuffer$",
    "type": "function",
    "syntax": "function string curl.get.errorbuffer$ ()",
    "description": "Descriptive message on result of previous action",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.getinfo": {
    "name": "curl.getinfo",
    "type": "function",
    "syntax": "function void curl.getinfo ()",
    "description": "This isn't the actual function. This help topic lists all curl.getinfo functions.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.http.status$": {
    "name": "curl.http.status$",
    "type": "function",
    "syntax": "function string curl.http.status$ (long http.status)",
    "description": "Returns a english descriptive text for a given HTTP Status Code. E.g. when 200 (HTTP_STATUS_OK) is passed \"OK\" is returned, or when 503 (HTTP_STATUS_SERVICE_UNAVAILABLE) is passed, \"Service Unavailable\" is returned.",
    "arguments": [
      {
        "type": "long",
        "name": "http.status",
        "description": "a HTTP Status code, like 200 (HTTP_STATUS_OK), 404 (HTTP_STATUS_NOT_FOUND), or 500 (HTTP_STATUS_INTERNAL_SERVER_ERROR)"
      }
    ],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl email example": {
    "name": "cURL email example",
    "type": "function",
    "syntax": "function cURL email example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl mime example": {
    "name": "cURL MIME example",
    "type": "function",
    "syntax": "function cURL MIME example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.perform": {
    "name": "curl.perform",
    "type": "function",
    "syntax": "function long curl.perform ()",
    "description": "Execute the action.",
    "arguments": [],
    "returnValue": "0 OK <> 0 An error occured",
    "category": "functions_cURL"
  },
  "curl.reset.errorbuffer": {
    "name": "curl.reset.errorbuffer",
    "type": "function",
    "syntax": "function void curl.reset.errorbuffer ()",
    "description": "Clear the error buffer.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.reset": {
    "name": "curl.reset",
    "type": "function",
    "syntax": "function void curl.reset ()",
    "description": "Resets all options.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.setopt": {
    "name": "curl.setopt",
    "type": "function",
    "syntax": "function long curl.setopt ()",
    "description": "This is not an actual function. This help topic lists all curl.setopt functions.",
    "arguments": [],
    "returnValue": "0 Option set 1 Illegal option value",
    "category": "functions_cURL"
  },
  "curl.slist.append": {
    "name": "curl.slist.append",
    "type": "function",
    "syntax": "function long curl.slist.append (ref long listId, const string text)",
    "description": "curl.slist.append() appends a specified string to a linked list of strings. This linked list can be used in some curl.setopt functions. The allowed value(s) of the passed string depend on the context where it is used. If the listId is zero, then a new list is created. The listId should be passed as the first argument if the string need to be appended to an existing list. The specified string has been added to the list when this function returns. The return value is the listId upon success or 0 upon error. The list should be freed after usage with curl.slist.free.all() .",
    "arguments": [
      {
        "type": "ref long",
        "name": "listId",
        "description": "A new (= value zero) or existing list ID."
      },
      {
        "type": "const string",
        "name": "text",
        "description": "A text that can be interpreted by cURL."
      }
    ],
    "returnValue": "A list ID upon success or zero upon error.",
    "category": "functions_cURL"
  },
  "curl.slist.free.all": {
    "name": "curl.slist.free.all",
    "type": "function",
    "syntax": "function void curl.slist.free.all (ref long listId)",
    "description": "curl.slist.free.all() frees a linked list of strings. The listId will be reset to zero after completion.",
    "arguments": [
      {
        "type": "ref long",
        "name": "listId",
        "description": "A list ID, created with curl.slist.append()"
      }
    ],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.sso.user.encode$": {
    "name": "curl.sso.user.encode$",
    "type": "function",
    "syntax": "function string curl.sso.user.encode$ (const string User)",
    "description": "...",
    "arguments": [
      {
        "type": "const string",
        "name": "User",
        "description": "Name of the SSO user"
      }
    ],
    "returnValue": "Contains an escaped SSO user string",
    "category": "functions_cURL"
  },
  "curl.sso.user.gettable": {
    "name": "curl.sso.user.gettable",
    "type": "function",
    "syntax": "function void curl.sso.user.gettable (ref string(2,128) EscapeTable)",
    "description": "Returns a string array with an escapetable.",
    "arguments": [
      {
        "type": "ref string(2,128)",
        "name": "EscapeTable",
        "description": "Two dimensional array with escape table"
      }
    ],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl.strerror$": {
    "name": "curl.strerror$",
    "type": "function",
    "syntax": "function string curl.strerror$ (long CurlCode)",
    "description": "Descriptive message on result of previous action",
    "arguments": [
      {
        "type": "long",
        "name": "CurlCode",
        "description": "..."
      }
    ],
    "returnValue": "Description of the error",
    "category": "functions_cURL"
  },
  "curl.upload.data": {
    "name": "curl.upload.data",
    "type": "function",
    "syntax": "function long curl.upload.data (const string url, const string data, long data.size, long response.stream [, long header.list] [, const string method])",
    "description": "Uploads binary data to the specified url.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url to where the data must be uploaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "const string",
        "name": "data",
        "description": "the data to upload"
      },
      {
        "type": "long",
        "name": "data.size",
        "description": "the size of the data to upload, in bytes"
      },
      {
        "type": "long",
        "name": "response.stream",
        "description": "the stream (file or memory stream) to which the response of the upload must be written to; do not forget to rewind the stream before accessing it"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append() . Specify 0 if no headers must be sent."
      },
      {
        "type": "[const string",
        "name": "method ]",
        "description": "optional HTTP method, specify \"PUT\" or \"POST\". \"POST\" is the default method."
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.upload.file": {
    "name": "curl.upload.file",
    "type": "function",
    "syntax": "function long curl.upload.file (const string url, const string file, long response.stream [, long header.list] [, const string method])",
    "description": "Uploads a file to the specified url.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url to where the file must be uploaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "const string",
        "name": "file",
        "description": "the name of the file to upload"
      },
      {
        "type": "long",
        "name": "response.stream",
        "description": "the stream (file or memory) to which the response of the upload must be written to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append() . Specify 0 if no headers must be sent."
      },
      {
        "type": "[const string",
        "name": "method ]",
        "description": "optional HTTP method, specify \"PUT\" or \"POST\". \"POST\" is the default method."
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.upload.stream": {
    "name": "curl.upload.stream",
    "type": "function",
    "syntax": "function long curl.upload.stream (const string url, long request.stream, long data.size, long response.stream [, long header.list] [, const string method])",
    "description": "Uploads data from a stream (a file or a memory stream) to the specified url.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url to where the data must be uploaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "long",
        "name": "request.stream",
        "description": "the stream data to upload"
      },
      {
        "type": "long",
        "name": "data.size",
        "description": "the size of the data to upload, in bytes; specify -1 to enforce sending the request in chunks"
      },
      {
        "type": "long",
        "name": "response.stream",
        "description": "the stream (file or memory stream) to which the response of the upload must be written to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append() . Specify 0 if no headers must be sent."
      },
      {
        "type": "[const string",
        "name": "method ]",
        "description": "optional HTTP method, specify \"PUT\" or \"POST\". \"POST\" is the default method."
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.upload.string": {
    "name": "curl.upload.string",
    "type": "function",
    "syntax": "function long curl.upload.string (const string url, const string data, long response.stream [, long header.list] [, const string method])",
    "description": "Uploads a (null terminated) string to the specified url.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the url to where the string must be uploaded; this can be an http(s) or an ftp(s) address."
      },
      {
        "type": "const string",
        "name": "data",
        "description": "the (null terminated) string to upload"
      },
      {
        "type": "long",
        "name": "response.stream",
        "description": "the stream (file or memory stream) to which the response of the upload must be written to"
      },
      {
        "type": "[long",
        "name": "header.list ]",
        "description": "optional cURL slist handle containing HTTP headers; this can be created by curl.slist.append() . Specify 0 if no headers must be sent."
      },
      {
        "type": "[const string",
        "name": "method ]",
        "description": "optional HTTP method, specify \"PUT\" or \"POST\". \"POST\" is the default method."
      }
    ],
    "returnValue": "0 Ok < 0 Stream IO error > 0 A cURL code; use curl.strerror$() to get a descriptive message",
    "category": "functions_cURL"
  },
  "curl.version": {
    "name": "curl.version",
    "type": "function",
    "syntax": "function string curl.version ()",
    "description": "Retrieves the current version of the cURL library that is being used and the versions of the other major components (like OpenSSL), as space-separated strings. This can be used to easily verify the level of support offered by the current bshell. The website of cURL lists the \"available from version\" for every feature and option.",
    "arguments": [],
    "returnValue": "Example: libcurl/7.57.0 OpenSSL/1.1.0g",
    "category": "functions_cURL"
  },
  "curl.xml.get.error$": {
    "name": "curl.xml.get.error$",
    "type": "function",
    "syntax": "function string curl.xml.get.error$ ()",
    "description": "...",
    "arguments": [],
    "returnValue": "Returns the errors in XML format.",
    "category": "functions_cURL"
  },
  "curl.xml.set.whitespacehandling": {
    "name": "curl.xml.set.whitespacehandling",
    "type": "function",
    "syntax": "function void curl.xml.set.whitespacehandling (long WhiteSpaceHandling)",
    "description": "...",
    "arguments": [
      {
        "type": "long",
        "name": "WhiteSpaceHandling",
        "description": "Method to use"
      }
    ],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl examples": {
    "name": "cURL Examples",
    "type": "function",
    "syntax": "function cURL Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "curl handling overview": {
    "name": "cURL handling overview",
    "type": "function",
    "syntax": "function cURL handling overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_cURL"
  },
  "currency tables overview and synopsis": {
    "name": "Currency tables overview and synopsis",
    "type": "function",
    "syntax": "function Currency tables overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_currency_tables"
  },
  "set.currencies": {
    "name": "set.currencies",
    "type": "function",
    "syntax": "function void set.currencies (long seqno, string currency(3) [, string currency.desc mb])",
    "description": "Use this function to create and fill the multicurrency table. The function inserts a single entry in the table. Currency rotation is based on the order of currencies in this table. Make sure that all the indices of the table (seqno) form a consecutive range, starting at 1",
    "arguments": [
      {
        "type": "long",
        "name": "seqno",
        "description": "sequence of currency when rotating"
      },
      {
        "type": "string",
        "name": "currency(3)",
        "description": "currency that is assigned to attr.currency$"
      },
      {
        "type": "[string",
        "name": "currency.desc mb ]",
        "description": "Label referring to currency description or currency description itself. In the latter case, the currency description must start with the at sign [@]. Note that using a literal string makes the script language dependent."
      }
    ],
    "returnValue": "",
    "category": "functions_currency_tables"
  },
  "after.abort.transaction": {
    "name": "after.abort.transaction",
    "type": "function",
    "syntax": "function void after.abort.transaction ()",
    "description": "This hook is called after the application did an abort.io() in the UI script from the after.choice of the choice.update.db section",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "after.change.object": {
    "name": "after.change.object",
    "type": "function",
    "syntax": "function long after.change.object ()",
    "description": "This hook is called after the current record has been changed, but not yet updated in the database. It marks the end of changing the current record.",
    "arguments": [],
    "returnValue": "The hook normally returns 0. Do not return DALHOOKERROR to prevent the current record to be updated in the database. Only return DALHOOKERROR in case of unusual errors, like a data set-up problem.",
    "category": "functions_dal"
  },
  "after.commit.transaction": {
    "name": "after.commit.transaction",
    "type": "function",
    "syntax": "function void after.commit.transaction ()",
    "description": "Use this to update other database tables after an update of the current table has been committed to the database.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "after.destroy.object": {
    "name": "after.destroy.object",
    "type": "function",
    "syntax": "function long after.destroy.object ()",
    "description": "Use this to update referenced tables after the current object has been deleted.",
    "arguments": [],
    "returnValue": "The hook returns 0 if successful. If the hook returns a negative value (DALHOOKERROR), the transaction is aborted.",
    "category": "functions_dal"
  },
  "after.get.object": {
    "name": "after.get.object",
    "type": "function",
    "syntax": "function extern long after.get.object (long direction)",
    "description": "Use this, to program checks that determine whether reading a record is permitted. The checks are performed after the record has been retrieved from the database. The dir argument is set by the STP and specifies the object being read. The possible values are:",
    "arguments": [
      {
        "type": "long",
        "name": "direction",
        "description": ""
      }
    ],
    "returnValue": "The hook returns 0 if reading of the record is permitted. If the hook returns a negative value (DALHOOKERROR), the object is skipped.",
    "category": "functions_dal"
  },
  "after.new.object": {
    "name": "after.new.object",
    "type": "function",
    "syntax": "function long after.new.object ()",
    "description": "This hook is called after a new record has been created, but not yet saved in the database. It marks the end of creating a new record.",
    "arguments": [],
    "returnValue": "The hook normally returns 0. Do not return DALHOOKERROR to prevent a new record to be created. Only return DALHOOKERROR in case of unusual errors, like a data set-up problem.",
    "category": "functions_dal"
  },
  "after.save.object": {
    "name": "after.save.object",
    "type": "function",
    "syntax": "function long after.save.object (long mode)",
    "description": "Use this to update referenced tables after a record has been added or updated. The mode argument is set by the 4GL engine . The possible values are:",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "The hook returns 0 if successful. If the hook returns a negative value (DALHOOKERROR), the transaction should be canceled. If the hook was called directly by the 4GL engine , the transaction is canceled automatically. If the hook was not called by the 4GL engine , the transaction must be canceled by calling abort.transaction() or abort.io() , typically in the UI script.",
    "category": "functions_dal"
  },
  "before.change.object": {
    "name": "before.change.object",
    "type": "function",
    "syntax": "function long before.change.object ()",
    "description": "This hook is called when the current record is about to be changed/modified. It marks the start of modifying the record.",
    "arguments": [],
    "returnValue": "The hook normally returns 0. Do not return DALHOOKERROR to prevent the current record to be updated. Only return DALHOOKERROR in case of unusual errors, like a data set-up problem.",
    "category": "functions_dal"
  },
  "before.destroy.object": {
    "name": "before.destroy.object",
    "type": "function",
    "syntax": "function function extern long before.destroy.object ()",
    "description": "Use this to program checks that determine whether deleting a record is permitted.",
    "arguments": [],
    "returnValue": "The hook returns 0 if deleting the record is permitted. If the hook returns a negative value (DALHOOKERROR), the transaction is aborted.",
    "category": "functions_dal"
  },
  "before.get.object": {
    "name": "before.get.object",
    "type": "function",
    "syntax": "function function extern long before.get.object (long direction)",
    "description": "Use this to program checks that determine whether reading a record is permitted. The argument is set by the STP or CDAS and specifies the object being read. The possible values are:",
    "arguments": [
      {
        "type": "long",
        "name": "direction",
        "description": ""
      }
    ],
    "returnValue": "The hook returns 0 if reading of the record is permitted. Negative return values (DALHOOKERROR) are ignored by the calling program.",
    "category": "functions_dal"
  },
  "before.new.object": {
    "name": "before.new.object",
    "type": "function",
    "syntax": "function long before.new.object ()",
    "description": "This hook is called when a new record is about to be created. It marks the start of creating a new record.",
    "arguments": [],
    "returnValue": "The hook normally returns 0. Do not return DALHOOKERROR to prevent a new record to be created. Only return DALHOOKERROR in case of unusual errors, like a data set-up problem.",
    "category": "functions_dal"
  },
  "before.open.object.set": {
    "name": "before.open.object.set",
    "type": "function",
    "syntax": "function long before.open.object.set ()",
    "description": "Use this to program checks that determine whether opening of the object set is permitted.",
    "arguments": [],
    "returnValue": "The hook returns 0 if opening of the object set is permitted. If the hook returns a negative value (DALHOOKERROR), the session is aborted (if the hook is called by the STP) or the method returns an error (if the hook is called by a DAM or a business method).",
    "category": "functions_dal"
  },
  "before.save.object": {
    "name": "before.save.object",
    "type": "function",
    "syntax": "function function extern long before.save.object (long mode)",
    "description": "Use this to program checks that determine whether saving a record is permitted. The mode argument is set by the 4GL engine . The possible values are:",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "The hook returns 0 if saving the record is permitted. If the hook returns a negative value (DALHOOKERROR), the transaction should be canceled. If the hook was called directly by the 4GL engine , the transaction is canceled automatically. If the hook was not called by the 4GL engine , the transaction must be canceled by calling abort.transaction() or abort.io() , typically in the UI script.",
    "category": "functions_dal"
  },
  "business.method.is.allowed": {
    "name": "business.method.is.allowed",
    "type": "function",
    "syntax": "function boolean business.method.is.allowed ()",
    "description": "Use this hook to check if the business method may be executed. If the business method may not be executed, then the 4GL engine will disable the corresponding form command on the UI.",
    "arguments": [],
    "returnValue": "The hook should return False if the business method may not be executed. It should return True in case it is allowed to execute the business method.",
    "category": "functions_dal"
  },
  "business.method.is.never.allowed": {
    "name": "business.method.is.never.allowed",
    "type": "function",
    "syntax": "function boolean business.method.is.never.allowed ()",
    "description": "Use this hook to check if the business method may never be executed. If the business method may never be executed, then the 4GL engine will remove the corresponding form command from the UI.",
    "arguments": [],
    "returnValue": "The hook should return True if the business method may never be executed. It should return False in any other case.",
    "category": "functions_dal"
  },
  "dal change management hooks": {
    "name": "DAL Change Management hooks",
    "type": "function",
    "syntax": "function DAL Change Management hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "communication with stp and cdas": {
    "name": "Communication with STP and CDAS",
    "type": "function",
    "syntax": "function Communication with STP and CDAS()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal.any.parent.changed": {
    "name": "dal.any.parent.changed",
    "type": "function",
    "syntax": "function boolean dal.any.parent.changed ()",
    "description": "The function dal.any.parent.changed() determines whether any of the fields, from which the current field depends, is changed. This function can only be used in combination with dal.require.field() .",
    "arguments": [],
    "returnValue": "true one or more parent fields have changed false no parent field has changed",
    "category": "functions_dal"
  },
  "dal.field.depends.on": {
    "name": "dal.field.depends.on",
    "type": "function",
    "syntax": "function void dal.field.depends.on (const string fieldname, long hook.list, const string parent.fld.name, ... [, long hook.list] [, const string parent.fieldname, ...])",
    "description": "Use this to define that a field depends on one or more other fields. Dependencies are defined in terms of field hooks.",
    "arguments": [
      {
        "type": "const string",
        "name": "fieldname",
        "description": "the field that depends on other fields"
      }
    ],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal.require.field": {
    "name": "dal.require.field",
    "type": "function",
    "syntax": "function void dal.require.field (const string fieldname [, long element] [, ref boolean field.changed])",
    "description": "This function can be used to determine a specific order for the calls to the update hooks. The function only works properly if update hooks are triggered by the 4GL engine (amdll), and not called from the application itself.",
    "arguments": [
      {
        "type": "const string",
        "name": "fieldname",
        "description": ""
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": ""
      },
      {
        "type": "[ref boolean",
        "name": "field.changed ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 and the 4gl engine": {
    "name": "DAL2 and the 4GL Engine",
    "type": "function",
    "syntax": "function DAL2 and the 4GL Engine()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 business method hooks": {
    "name": "DAL2 Business method hooks",
    "type": "function",
    "syntax": "function DAL2 Business method hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 field dependencies": {
    "name": "DAL2 Field dependencies",
    "type": "function",
    "syntax": "function DAL2 Field dependencies()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 field hooks": {
    "name": "DAL2 Field hooks",
    "type": "function",
    "syntax": "function DAL2 Field hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 flow of field hooks": {
    "name": "DAL2 Flow of field hooks",
    "type": "function",
    "syntax": "function DAL2 Flow of field hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "extended dal (dal2)": {
    "name": "Extended DAL (DAL2)",
    "type": "function",
    "syntax": "function Extended DAL (DAL2)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal2 test mode": {
    "name": "DAL2 Test Mode",
    "type": "function",
    "syntax": "function DAL2 Test Mode()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal context": {
    "name": "DAL Context",
    "type": "function",
    "syntax": "function DAL Context()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal terminology": {
    "name": "DAL terminology",
    "type": "function",
    "syntax": "function DAL terminology()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "dal hooks": {
    "name": "DAL hooks",
    "type": "function",
    "syntax": "function DAL hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "ui, dal, and stp interaction": {
    "name": "UI, DAL, and STP interaction",
    "type": "function",
    "syntax": "function UI, DAL, and STP interaction()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "data access methods (dam)": {
    "name": "Data Access Methods (DAM)",
    "type": "function",
    "syntax": "function Data Access Methods (DAM)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "field.enum.is.applicable": {
    "name": "field.enum.is.applicable",
    "type": "function",
    "syntax": "function boolean field.enum.is.applicable ( [long mode] [, long element])",
    "description": "Use this hook to indicate whether a certain enum constant is applicable. In case the enum constant is not applicable the 4GL engine will not show it in the field's list box, so the end-user cannot select it.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element number in case the field is an element of an array (for non array fields this value is 1)"
      }
    ],
    "returnValue": "The hook should return True in case the enum constant is applicable. In case the enum constant is not applicable it should return False.",
    "category": "functions_dal"
  },
  "field.is.applicable": {
    "name": "field.is.applicable",
    "type": "function",
    "syntax": "function boolean field.is.applicable ( [long mode] [, long element])",
    "description": "Use this hook to indicate whether the field is applicable. If a field is not applicable then the 4GL Engine disables the field and the field will be cleared. Depending on the data type of the field the field's value then becomes:",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element number in case the field is an element of an array (for non array fields this value is 1)"
      }
    ],
    "returnValue": "The hook should return False in case the field is not applicable. In that case the 4GL engine will disable the field in the UI and the field will be cleared. In any other case the hook should return True (i.e. the field is applicable).",
    "category": "functions_dal"
  },
  "field.is.derived": {
    "name": "field.is.derived",
    "type": "function",
    "syntax": "function boolean field.is.derived ( [long mode] [, long element])",
    "description": "Use this hook to indicate whether the field is derived. If a field is derived then the 4GL engine makes the field readonly in the UI. The field however, still can have a value.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element number in case the field is an element of an array (for non array fields this value is 1)"
      }
    ],
    "returnValue": "The hook should return True in case the field is derived. In that case the 4GL engine will make the field appear readonly on the UI. In any other case the hook should return False (i.e. the field is not derived).",
    "category": "functions_dal"
  },
  "field.is.mandatory": {
    "name": "field.is.mandatory",
    "type": "function",
    "syntax": "function boolean field.is.mandatory ( [long mode] [, long element])",
    "description": "Use this hook to indicate whether the field is mandatory. If a field is mandatory then it should have a value other than \"\", 0.0, 0 or empty.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element number in case the field is an element of an array (for non array fields this value is 1)"
      }
    ],
    "returnValue": "The hook should return True in case the field is mandatory. In any other case the hook should return False (i.e. the field is not mandatory).",
    "category": "functions_dal"
  },
  "field.is.never.applicable": {
    "name": "field.is.never.applicable",
    "type": "function",
    "syntax": "function boolean field.is.never.applicable ( [long mode] [, long element])",
    "description": "Use this hook to indicate if the field is never applicable. If a field is never applicable then the 4GL engine will not display the field in the UI (it is made invisible at start up of a session). A field can become never applicable based on a static constraint, like a parameter setting.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element number in case the field is an element of an array (for non array fields this value is 1)"
      }
    ],
    "returnValue": "The hook should return true in case the field is never applicable. In that case the 4GL engine will remove the field from the UI. In any other case the hook should return False.",
    "category": "functions_dal"
  },
  "field.is.readonly": {
    "name": "field.is.readonly",
    "type": "function",
    "syntax": "function boolean field.is.readonly (UI template) ()",
    "description": "You can use this hook in your UI script to define the conditions under which the field should become readonly in the UI. The 4GL engine uses this hook to determine whether the field must be enabled or made readonly.",
    "arguments": [],
    "returnValue": "The hook should return TRUE in case the field is readonly. In that case the 4GL engine will make the field appear readonly on the UI. In any other case the hook should return FALSE (i.e. the field is not readonly).",
    "category": "functions_ui_template"
  },
  "field.is.valid": {
    "name": "field.is.valid",
    "type": "function",
    "syntax": "function boolean field.is.valid ( [long mode] [, long element])",
    "description": "Use this hook to perform any checks not already defined in one of the other field hooks. Some examples:",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": ""
      }
    ],
    "returnValue": "The hook should return True in case the field is valid. In case the field is not valid it should return False.",
    "category": "functions_dal"
  },
  "field.update": {
    "name": "field.update",
    "type": "function",
    "syntax": "function [void|long] field.update ( [long mode] [, long element])",
    "description": "Use this hook to (re) determine the value of the field based on the current record values. Think of determining defaults and calculating derived values. When using this hook you don't have to use the when.field.changes section in the UI script to update fields.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "optional mode flag, one of { 0, DAL_NEW, DAL_UPDATE }"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_dal"
  },
  "fieldname.check": {
    "name": "fieldname.check",
    "type": "function",
    "syntax": "function long field.check (long has_changed [, long element])",
    "description": "Use this hook to program logical integrity rules for a specified field. The function name is ppmmmvss.bbbb .check(), where pp is the package code, mmm is the module code, vss is the table number, and bbbb is the field name.",
    "arguments": [
      {
        "type": "long",
        "name": "has_changed",
        "description": ""
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "This is set for array fields only. It indicates the index of the array element that must be checked."
      }
    ],
    "returnValue": "This hook returns 0 if the value of the field is accepted. It returns a negative value (DALHOOKERROR) if the value is not accepted.",
    "category": "functions_dal"
  },
  "fieldname.make.valid": {
    "name": "fieldname.make.valid",
    "type": "function",
    "syntax": "function long field.make.valid (long mode [, long element])",
    "description": "This hook is meant to adjust the field's value before it is checked. You can use it for example to round a field's value.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": ""
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "This is set for array fields only. It indicates the index of the array element that must be checked."
      }
    ],
    "returnValue": "This hook returns 0 if no errors occurred. It returns DALHOOKERROR if the field cannot be made valid.",
    "category": "functions_dal"
  },
  "fieldname.set.defaults": {
    "name": "fieldname.set.defaults",
    "type": "function",
    "syntax": "function long field.set.defaults (long has_changed)",
    "description": "Use this hook to set defaults based on a specified field. The function name is ppmmmvss.bbbb.check(), where pp is the package code, mmm is the module code, vss is the table number, and bbbb is the field name.",
    "arguments": [
      {
        "type": "long",
        "name": "has_changed",
        "description": ""
      }
    ],
    "returnValue": "This hook returns 0 if the value of the field is accepted. It returns a negative value (DALHOOKERROR) if the value is not accepted.",
    "category": "functions_dal"
  },
  "method.is.allowed": {
    "name": "method.is.allowed",
    "type": "function",
    "syntax": "function boolean method.is.allowed (long method)",
    "description": "This is a special hook for handling centralized authorizations. Use it to perform checks that determine whether certain Data Access Methods are permitted for an object. The method argument specifies the method to check.",
    "arguments": [
      {
        "type": "long",
        "name": "method",
        "description": ""
      }
    ],
    "returnValue": "TRUE if the method is permitted FALSE if the method is not permitted",
    "category": "functions_dal"
  },
  "object hooks": {
    "name": "Object hooks",
    "type": "function",
    "syntax": "function Object hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "on.recall": {
    "name": "on.recall",
    "type": "function",
    "syntax": "function long on.recall ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL, is the root table, as defined in the OCM Workflow Model. In case any changes made to the Business Object must be recalled, the DBCM layer will execute this hook. This hook must then publish a Workflow BOD to ION with a request to recall a previous request for approval.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "on.reject": {
    "name": "on.reject",
    "type": "function",
    "syntax": "function long on.reject ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL is the root table, as defined in the OCM Workflow Model. In case any submitted changes made to the Business Object have been rejected in ION, the DBCM layer will execute this hook.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "on.set.approved": {
    "name": "on.set.approved",
    "type": "function",
    "syntax": "function long on.set.approved ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL is the root table, as defined in the OCM Workflow Model. In case any submitted changes made to the Business Object have been approved in ION, the DBCM layer will execute this hook.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "on.set.draft": {
    "name": "on.set.draft",
    "type": "function",
    "syntax": "function long on.set.draft ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL is the root table, as defined in the OCM Workflow Model. In case any submitted changes made to the Business Object have been approved in ION, the DBCM layer will execute this hook.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "on.set.recalled": {
    "name": "on.set.recalled",
    "type": "function",
    "syntax": "function long on.set.recalled ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL is the root table, as defined in the OCM Workflow Model. In case a previous request to recall a started Workflow in ION is confirmed, the DBCM layer will execute this hook.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "on.submit": {
    "name": "on.submit",
    "type": "function",
    "syntax": "function long on.submit ()",
    "description": "This hook is executed in case Workflow Document Authorization is active for the Business Object of which the table of this DAL, is the root table, as defined in the OCM Workflow Model. In case any changes made to the Business Object are submitted, the DBCM layer will execute this hook. This hook must then publish a Workflow BOD to ION with a request for approval.",
    "arguments": [],
    "returnValue": "0 In case of success. DALHOOKERROR In case of a failure.",
    "category": "functions_dal"
  },
  "data access layer": {
    "name": "Data Access Layer",
    "type": "function",
    "syntax": "function Data Access Layer()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "property hooks": {
    "name": "Property hooks",
    "type": "function",
    "syntax": "function Property hooks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "property methods": {
    "name": "Property methods",
    "type": "function",
    "syntax": "function Property methods()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "query extensions": {
    "name": "Query extensions",
    "type": "function",
    "syntax": "function Query extensions()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "set.object.defaults": {
    "name": "set.object.defaults",
    "type": "function",
    "syntax": "function long set.object.defaults ()",
    "description": "Use this hook to fill a new record with defaults.",
    "arguments": [],
    "returnValue": "The hook returns 0 if the hook has been executed successfully.",
    "category": "functions_dal"
  },
  "transition issues (baan iv to infor erp enterprise)": {
    "name": "Transition issues (BAAN IV to Infor ERP Enterprise)",
    "type": "function",
    "syntax": "function Transition issues (BAAN IV to Infor ERP Enterprise)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dal"
  },
  "and boolean operator": {
    "name": "AND boolean operator",
    "type": "function",
    "syntax": "function AND boolean operator()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "infor erp enterprise sql": {
    "name": "Infor ERP Enterprise SQL",
    "type": "function",
    "syntax": "function Infor ERP Enterprise SQL()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "between predicate": {
    "name": "BETWEEN predicate",
    "type": "function",
    "syntax": "function BETWEEN predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "cast expression": {
    "name": "CAST expression",
    "type": "function",
    "syntax": "function CAST expression()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "column reference": {
    "name": "Column reference",
    "type": "function",
    "syntax": "function Column reference()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "donotfindthispage!": {
    "name": "DoNotFindThisPage!",
    "type": "function",
    "syntax": "function DoNotFindThisPage!()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "company numbers": {
    "name": "Company numbers",
    "type": "function",
    "syntax": "function Company numbers()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "comparable data types in infor erp enterprise sql": {
    "name": "Comparable data types in Infor ERP Enterprise SQL",
    "type": "function",
    "syntax": "function Comparable data types in Infor ERP Enterprise SQL()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "comparison predicate": {
    "name": "Comparison predicate",
    "type": "function",
    "syntax": "function Comparison predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "_compnr predicate": {
    "name": "_compnr predicate",
    "type": "function",
    "syntax": "function _compnr predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "current_date": {
    "name": "CURRENT_DATE",
    "type": "function",
    "syntax": "function CURRENT_DATE()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "current_timestamp": {
    "name": "CURRENT_TIMESTAMP",
    "type": "function",
    "syntax": "function CURRENT_TIMESTAMP()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "date constant": {
    "name": "Date constant",
    "type": "function",
    "syntax": "function Date constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "dynamic sql": {
    "name": "Dynamic SQL",
    "type": "function",
    "syntax": "function Dynamic SQL()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "embedded sql": {
    "name": "Embedded SQL",
    "type": "function",
    "syntax": "function Embedded SQL()",
    "description": "Data is selected on the basis of the condition specified in the SELECT statement. The operations between SELECTDO and ENDSELECT are performed on each record from the selected set. The loop ends either when the program has handled the entire set or the program encounters a BREAK command.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "empty constant": {
    "name": "EMPTY constant",
    "type": "function",
    "syntax": "function EMPTY constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "enumerate constant": {
    "name": "Enumerate constant",
    "type": "function",
    "syntax": "function Enumerate constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "enum_description function": {
    "name": "ENUM_DESCRIPTION function",
    "type": "function",
    "syntax": "function ENUM_DESCRIPTION function()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "error handling": {
    "name": "Error handling",
    "type": "function",
    "syntax": "function Error handling()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "exists predicate": {
    "name": "EXISTS predicate",
    "type": "function",
    "syntax": "function EXISTS predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "from clause": {
    "name": "FROM clause",
    "type": "function",
    "syntax": "function FROM clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "group by clause": {
    "name": "GROUP BY clause",
    "type": "function",
    "syntax": "function GROUP BY clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "having clause": {
    "name": "HAVING clause",
    "type": "function",
    "syntax": "function HAVING clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "hints for using db.retry.point": {
    "name": "Hints for using db.retry.point",
    "type": "function",
    "syntax": "function Hints for using db.retry.point()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "hints for using sql": {
    "name": "Hints for using SQL",
    "type": "function",
    "syntax": "function Hints for using SQL()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "identifier": {
    "name": "Identifier",
    "type": "function",
    "syntax": "function Identifier()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "inrange predicate": {
    "name": "INRANGE predicate",
    "type": "function",
    "syntax": "function INRANGE predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "integer constant": {
    "name": "Integer constant",
    "type": "function",
    "syntax": "function Integer constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "in predicate": {
    "name": "IN predicate",
    "type": "function",
    "syntax": "function IN predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "is null predicate": {
    "name": "IS NULL predicate",
    "type": "function",
    "syntax": "function IS NULL predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "like predicate": {
    "name": "LIKE predicate",
    "type": "function",
    "syntax": "function LIKE predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "locking": {
    "name": "Locking",
    "type": "function",
    "syntax": "function Locking()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "ml_one_lang function": {
    "name": "ml_one_lang function",
    "type": "function",
    "syntax": "function ml_one_lang function()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "multi language data": {
    "name": "Multi Language Data",
    "type": "function",
    "syntax": "function Multi Language Data()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "not boolean operator": {
    "name": "NOT boolean operator",
    "type": "function",
    "syntax": "function NOT boolean operator()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "order by clause": {
    "name": "ORDER BY clause",
    "type": "function",
    "syntax": "function ORDER BY clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "or boolean operator": {
    "name": "OR boolean operator",
    "type": "function",
    "syntax": "function OR boolean operator()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "database handling overview": {
    "name": "Database handling overview",
    "type": "function",
    "syntax": "function Database handling overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "parameter": {
    "name": "Parameter",
    "type": "function",
    "syntax": "function Parameter()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "query expression": {
    "name": "Query expression",
    "type": "function",
    "syntax": "function Query expression()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "query specification": {
    "name": "Query specification",
    "type": "function",
    "syntax": "function Query specification()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "raw constant": {
    "name": "Raw constant",
    "type": "function",
    "syntax": "function Raw constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "real constant": {
    "name": "Real constant",
    "type": "function",
    "syntax": "function Real constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "references": {
    "name": "References",
    "type": "function",
    "syntax": "function References()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "refers to predicate": {
    "name": "REFERS TO predicate",
    "type": "function",
    "syntax": "function REFERS TO predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "retry points": {
    "name": "Retry points",
    "type": "function",
    "syntax": "function Retry points()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "row value constructor": {
    "name": "Row value constructor",
    "type": "function",
    "syntax": "function Row value constructor()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "case expression (searched)": {
    "name": "CASE expression (searched)",
    "type": "function",
    "syntax": "function CASE expression (searched)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "search condition": {
    "name": "Search condition",
    "type": "function",
    "syntax": "function Search condition()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "select clause": {
    "name": "SELECT clause",
    "type": "function",
    "syntax": "function SELECT clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "select statement": {
    "name": "SELECT statement",
    "type": "function",
    "syntax": "function SELECT statement()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "set function specification": {
    "name": "Set function specification",
    "type": "function",
    "syntax": "function Set function specification()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "set specification": {
    "name": "SET specification",
    "type": "function",
    "syntax": "function SET specification()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "simplest comparison predicate": {
    "name": "Simplest comparison predicate",
    "type": "function",
    "syntax": "function Simplest comparison predicate()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "case expression (simple)": {
    "name": "CASE expression (simple)",
    "type": "function",
    "syntax": "function CASE expression (simple)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql and combined fields": {
    "name": "SQL and combined fields",
    "type": "function",
    "syntax": "function SQL and combined fields()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql and delayed locks": {
    "name": "SQL and delayed locks",
    "type": "function",
    "syntax": "function SQL and delayed locks()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql data types": {
    "name": "SQL data types",
    "type": "function",
    "syntax": "function SQL data types()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql glossary": {
    "name": "SQL glossary",
    "type": "function",
    "syntax": "function SQL glossary()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql programming": {
    "name": "SQL programming",
    "type": "function",
    "syntax": "function SQL programming()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql reserved words": {
    "name": "SQL reserved words",
    "type": "function",
    "syntax": "function SQL reserved words()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql subqueries": {
    "name": "SQL subqueries",
    "type": "function",
    "syntax": "function SQL subqueries()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sql trace options": {
    "name": "SQL trace options",
    "type": "function",
    "syntax": "function SQL trace options()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "string constant": {
    "name": "String constant",
    "type": "function",
    "syntax": "function String constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "substring and array indexing": {
    "name": "Substring and array indexing",
    "type": "function",
    "syntax": "function Substring and array indexing()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "sub query": {
    "name": "Sub query",
    "type": "function",
    "syntax": "function Sub query()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "text_content function": {
    "name": "TEXT_CONTENT function",
    "type": "function",
    "syntax": "function TEXT_CONTENT function()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "timestamp constant": {
    "name": "Timestamp constant",
    "type": "function",
    "syntax": "function Timestamp constant()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "transaction handling": {
    "name": "Transaction handling",
    "type": "function",
    "syntax": "function Transaction handling()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "trim function": {
    "name": "TRIM function",
    "type": "function",
    "syntax": "function TRIM function()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "union operator": {
    "name": "UNION operator",
    "type": "function",
    "syntax": "function UNION operator()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "using program variables": {
    "name": "Using program variables",
    "type": "function",
    "syntax": "function Using program variables()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "value expression": {
    "name": "Value expression",
    "type": "function",
    "syntax": "function Value expression()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator + (add)": {
    "name": "Operator + (add)",
    "type": "function",
    "syntax": "function Operator + (add)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator &amp; (concatenation)": {
    "name": "Operator &amp; (concatenation)",
    "type": "function",
    "syntax": "function Operator &amp; (concatenation)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator / (divide)": {
    "name": "Operator / (divide)",
    "type": "function",
    "syntax": "function Operator / (divide)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator \\ (modulo)": {
    "name": "Operator \\ (modulo)",
    "type": "function",
    "syntax": "function Operator \\ (modulo)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator * (multiply)": {
    "name": "Operator * (multiply)",
    "type": "function",
    "syntax": "function Operator * (multiply)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "operator - (subtract)": {
    "name": "Operator - (subtract)",
    "type": "function",
    "syntax": "function Operator - (subtract)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "where clause": {
    "name": "WHERE clause",
    "type": "function",
    "syntax": "function WHERE clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "with retry clause": {
    "name": "WITH RETRY clause",
    "type": "function",
    "syntax": "function WITH RETRY clause()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_database_handling"
  },
  "choose.time.zone.from.list": {
    "name": "choose.time.zone.from.list",
    "type": "function",
    "syntax": "function long choose.time.zone.from.list (ref string new.timezone)",
    "description": "This starts a session where the user can choose a time zone from a list. The function then calls set.timezone() with the time zone selected by the user.",
    "arguments": [
      {
        "type": "ref string",
        "name": "new.timezone",
        "description": "This argument is used to return the set timezone to the caller."
      }
    ],
    "returnValue": "0 New time zone set. -1 User aborted operation; time zone not set .",
    "category": "functions_date_time_zones"
  },
  "date.num": {
    "name": "date.num",
    "type": "function",
    "syntax": "function long date.num ()",
    "description": "This returns the number of days from 01-01-0001 to the system date.",
    "arguments": [],
    "returnValue": ">=0 The number of days from 01-01-0001 to the system date. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "date.to.date": {
    "name": "date.to.date",
    "type": "function",
    "syntax": "function long date.to.date (long in_date, long in_time, const string in_zone, const string out_zone, ref long out_date, ref long out_time)",
    "description": "This converts a date and time in one time zone to the corresponding date and time in a different time zone.",
    "arguments": [
      {
        "type": "long",
        "name": "in_date",
        "description": "The date in the source time zone, specified as the number of days since 01-01-0001."
      },
      {
        "type": "long",
        "name": "in_time",
        "description": "The time in the source time zone, specified as the number of seconds since 00:00 hour."
      },
      {
        "type": "const string",
        "name": "in_zone",
        "description": "The source time zone."
      },
      {
        "type": "const string",
        "name": "out_zone",
        "description": "The time zone to which the source date and time must be converted."
      },
      {
        "type": "ref long",
        "name": "out_date",
        "description": "The number of days since 01-01-0001 in the target time zone."
      },
      {
        "type": "ref long",
        "name": "out_time",
        "description": "The number of seconds since 00:00 hour in the target time zone."
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "date.to.inputstr$": {
    "name": "date.to.inputstr$",
    "type": "function",
    "syntax": "function string date.to.inputstr$ (long dayno, string format(7), long length)",
    "description": "This converts a specified number of days since 01-01-0001 to a date input string.",
    "arguments": [
      {
        "type": "long",
        "name": "dayno",
        "description": "A number of days since 01-01-0001."
      },
      {
        "type": "string",
        "name": "format(7)",
        "description": "The format for the date string, specified by using the substitution symbols %Dxxx[,lang]"
      },
      {
        "type": "long",
        "name": "length",
        "description": "The length of the date string: 6: year represented by 2 characters (century not included) 8: year represented by 4 characters (century included)"
      }
    ],
    "returnValue": "The formatted input string. An empty string if an error occurs.",
    "category": "functions_date_time_zones"
  },
  "date.to.num": {
    "name": "date.to.num",
    "type": "function",
    "syntax": "function long date.to.num (long yearno, long monthno, long month_dayno)",
    "description": "This returns the number of days since 01-01-0001 for a specified year, month, and day of the month.",
    "arguments": [
      {
        "type": "long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "long",
        "name": "month_dayno",
        "description": ""
      }
    ],
    "returnValue": "0 The number of days since 01-01-0001. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "date.to.utc": {
    "name": "date.to.utc",
    "type": "function",
    "syntax": "function domain ttutc date.to.utc (long yearno, long monthno, long month_dayno, long hours, long minutes, long seconds)",
    "description": "This converts the specified local date and time to UTC long format. Input values must be in the signed 32-bit value range.",
    "arguments": [
      {
        "type": "long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "long",
        "name": "month_dayno",
        "description": ""
      },
      {
        "type": "long",
        "name": "hours",
        "description": ""
      },
      {
        "type": "long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "long",
        "name": "seconds",
        "description": ""
      }
    ],
    "returnValue": "&#8805; 0 The UTC long format value. -1 Error. The exact result is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range.",
    "category": "functions_date_time_zones"
  },
  "date.with.timezone.info.to.utc": {
    "name": "date.with.timezone.info.to.utc",
    "type": "function",
    "syntax": "function domain ttutc date.with.timezone.info.to.utc (long yearno, long monthno, long month_dayno, long hours, long minutes, long seconds, long utcdiff)",
    "description": "This converts the specified local date and time to UTC long format. For this conversion it will NOT use the timezone of the user, but the difference in seconds to UTC as supplied in the variable utcdiff. Input values must be in the signed 32-bit value range.",
    "arguments": [
      {
        "type": "long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "long",
        "name": "month_dayno",
        "description": ""
      },
      {
        "type": "long",
        "name": "hours",
        "description": ""
      },
      {
        "type": "long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "long",
        "name": "seconds",
        "description": ""
      },
      {
        "type": "long",
        "name": "utcdiff",
        "description": ""
      }
    ],
    "returnValue": "&#8805; 0 The UTC long format value. -1 Error. The exact result is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range.",
    "category": "functions_date_time_zones"
  },
  "dte$": {
    "name": "dte$",
    "type": "function",
    "syntax": "function string dte$ ()",
    "description": "This returns the current date and time in the format MMDDYYHHMMSS",
    "arguments": [],
    "returnValue": "A string containing the current date and time.",
    "category": "functions_date_time_zones"
  },
  "get.time.zone": {
    "name": "get.time.zone",
    "type": "function",
    "syntax": "function long get.time.zone (ref string time_zone())",
    "description": "Returns the current time zone. The program must supply a buffer of at least a size of 50 to store the result, otherwise the result is truncated.",
    "arguments": [
      {
        "type": "ref string",
        "name": "time_zone()",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "input.to.utc": {
    "name": "input.to.utc",
    "type": "function",
    "syntax": "function domain ttutc input.to.utc (const string value(), const string format())",
    "description": "This converts a string to a local date or local time based on a format.",
    "arguments": [
      {
        "type": "const string",
        "name": "value()",
        "description": "A date string or a time string (in local time)."
      },
      {
        "type": "const string",
        "name": "format()",
        "description": "Indicates the format of the input string. For a date string, use the substitution symbols %u xxx [, lang ] . For a time string, use the substitution symbols %U xxx [, lang ] ."
      }
    ],
    "returnValue": "the local date as the number of days since 01-01-0001 or the local time as the number of seconds since 00:00 hour depending on the format string. -1 Error. The exact result is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range.",
    "category": "functions_date_time_zones"
  },
  "inputstr.to.date": {
    "name": "inputstr.to.date",
    "type": "function",
    "syntax": "function long inputstr.to.date (string inputstr(.), string format(7))",
    "description": "This converts a date input string to the number of days since 01-01-0001.",
    "arguments": [
      {
        "type": "string",
        "name": "inputstr(.)",
        "description": "The date input string, possibly input by the user and retrieved using the function data.input() ."
      },
      {
        "type": "string",
        "name": "format(7)",
        "description": "Indicates the format of the input string, specified by using the substitution symbols %D xxx [, lang ]."
      }
    ],
    "returnValue": "The number of days from 01-01-0001 to the date specified in the input string. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "inputstr.to.utc": {
    "name": "inputstr.to.utc",
    "type": "function",
    "syntax": "function domain ttutc inputstr.to.utc (const string date.inputstr(), string date.format(7), const string time.inputstr(), string time.format(7))",
    "description": "This converts the specified local date and time input strings to UTC long format.",
    "arguments": [
      {
        "type": "const string",
        "name": "date.inputstr()",
        "description": "A date string (in local time)."
      },
      {
        "type": "string",
        "name": "date.format(7)",
        "description": "Indicates the format of the date string, by using the substitution symbols %D xxx [, lang ] ."
      },
      {
        "type": "const string",
        "name": "time.inputstr()",
        "description": "A time string (in local time)."
      },
      {
        "type": "string",
        "name": "time.format(7)",
        "description": "Indicates the format of the time string, by using the substitution symbols %U xxx [, lang ]."
      }
    ],
    "returnValue": "The UTC long format value. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "iso.to.utc": {
    "name": "iso.to.utc",
    "type": "function",
    "syntax": "function domain ttutc iso.to.utc (const string iso.string)",
    "description": "This converts a string, representing a time in ISO-8601 format into a utc.",
    "arguments": [
      {
        "type": "const string",
        "name": "iso.string",
        "description": ""
      }
    ],
    "returnValue": ">0 The UTC long format value. <0 Error.",
    "category": "functions_date_time_zones"
  },
  "local.to.utc": {
    "name": "local.to.utc",
    "type": "function",
    "syntax": "function long local.to.utc (long local_days, long local_time, ref long utc [, string local_dst])",
    "description": "This converts a local date and time to UTC long format. Input values for local date and time must be in the signed 32-bit value range.",
    "arguments": [
      {
        "type": "long",
        "name": "local_days",
        "description": "A number of days since 01-01-0001."
      },
      {
        "type": "long",
        "name": "local_time",
        "description": "A number of seconds since 00:00 hours."
      },
      {
        "type": "ref long",
        "name": "utc",
        "description": "The UTC long format value corresponding to the specified local date and time."
      },
      {
        "type": "[string",
        "name": "local_dst ]",
        "description": "Optional argument for specifying whether Daylight Saving Time (DST) must be considered as on or off. When omitted, the current timezone rule (expressing local legislation) determines whether DST is considered as switched on or off for the supplied ( local_days , local_time ) combination. DST_ON: The supplied ( local_days , local_time ) combination must be considered as local time with DST on. DST_OFF: The supplied ( local_days , local_time ) combination must be considered as local time with DST off. DST_ON and DST_OFF are predefined literal strings of length 6 and 7 respectively."
      }
    ],
    "returnValue": "0 Success. The supplied reference argument utc now contains the UTC value of the supplied local date and time. -1 Error. The supplied reference argument utc is unchanged. The cause of the error may be one of the following. The exact result is negative. The exact result is greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range. The optional argument local_dst is not supplied and the ( local_days , local_time ) combination is in the skipped range at the begin of a DST period. See the Daylight Saving Time handling section and the examples below.",
    "category": "functions_date_time_zones"
  },
  "local.with.timezone.info.to.utc": {
    "name": "local.with.timezone.info.to.utc",
    "type": "function",
    "syntax": "function domain ttutc local.with.timezone.info.to.utc (long local_days, long local_time, long utcdiff, ref domain ttutc utc)",
    "description": "This converts a local date and time to UTC long format. For the conversion, it will NOT use the timezone of the user, but the difference in seconds to UTC as supplied in the variable utcdiff. Input values for local date and time must be in the signed 32-bit value range.",
    "arguments": [
      {
        "type": "long",
        "name": "local_days",
        "description": "A number of days since 01-01-0001."
      },
      {
        "type": "long",
        "name": "local_time",
        "description": "A number of seconds since 00:00 hours."
      },
      {
        "type": "long",
        "name": "utcdiff",
        "description": "The number of seconds this timezone should be considered away from UTC."
      },
      {
        "type": "ref domain ttutc",
        "name": "utc",
        "description": "The UTC long format value corresponding to the specified local date and time."
      }
    ],
    "returnValue": "0 Success. The supplied reference argument utc now contains the UTC value of the supplied local date and time. -1 Error. The exact result is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range. The supplied reference argument utc is unchanged.",
    "category": "functions_date_time_zones"
  },
  "num.to.date": {
    "name": "num.to.date",
    "type": "function",
    "syntax": "function long num.to.date (long dayno, ref long yearno, ref long monthno, ref long month_dayno)",
    "description": "This converts a specified number of days since 01-01-0001 to the corresponding year, month, and day of the month.",
    "arguments": [
      {
        "type": "long",
        "name": "dayno",
        "description": "A number of days since 01-01-0001. This value must be at least 1 (corresponding to January 1 of the year 1) and less than 3,652,060 (corresponding to January 1 of the year 10,000). Other values lead to an error."
      },
      {
        "type": "ref long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "month_dayno",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "num.to.date$": {
    "name": "num.to.date$",
    "type": "function",
    "syntax": "function string num.to.date$ (long dayno, long mode)",
    "description": "This converts a specified number of days since 01-01-0001 to the corresponding date, formatted as a date string. The sequence of day, month, and year in the string depends on the user data settings defined in the data dictionary (default is \"YYMMDD\"). The separator character used is also defined in the data dictionary (default is '/').",
    "arguments": [
      {
        "type": "long",
        "name": "dayno",
        "description": "A number of days since 01-01-0001. This value must be at least 1 (corresponding to January 1 of the year 1) and less than 3,652,060 (corresponding to January 1 of the year 10,000). Other values lead to an error."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "Specifies certain characteristics of the date string format: 0: Date like YYMMDD without separators (for example, \"011231\") 1: Date like YY/MM/DD with separators (for example,\"01/12/31\") 2: Date like YYYYMMDD without separators (for example, \"20101231\") 3: Date like YYYY/MM/DD with separators (for example,\"2010/12/31\")."
      }
    ],
    "returnValue": "The formatted date string. Or an empty string if an error occurs.",
    "category": "functions_date_time_zones"
  },
  "num.to.week": {
    "name": "num.to.week",
    "type": "function",
    "syntax": "function long num.to.week (long dayno, ref long week_dayno, ref long year_dayno, ref long weekno [, ref long yearno])",
    "description": "This converts a specified number of days since 01-01-0001 to the corresponding day of the week, day of the year, and week number of the year.",
    "arguments": [
      {
        "type": "long",
        "name": "dayno",
        "description": "A number of days since 01-01-0001. This value must be at least 1 (corresponding to January 1 of the year 1) and less than 3,652,060 (corresponding to January 1 of the year 10,000). Other values lead to an error."
      },
      {
        "type": "ref long",
        "name": "week_dayno",
        "description": "The day of the week. This depends on which day is defined as the first day of the week in the user data settings in the data dictionary."
      },
      {
        "type": "ref long",
        "name": "year_dayno",
        "description": "The day number in the year."
      },
      {
        "type": "ref long",
        "name": "weekno",
        "description": "The week number in the year. See Week handling ."
      },
      {
        "type": "[ref long",
        "name": "yearno ]",
        "description": "The year number. This argument is optional."
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "dates, times, time zones overview": {
    "name": "Dates, times, time zones overview",
    "type": "function",
    "syntax": "function Dates, times, time zones overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_date_time_zones"
  },
  "set.time.zone": {
    "name": "set.time.zone",
    "type": "function",
    "syntax": "function long set.time.zone (string time_zone(50))",
    "description": "This sets the local time zone at run time.",
    "arguments": [
      {
        "type": "string",
        "name": "time_zone(50)",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "dates, times, time zones synopsis": {
    "name": "Dates, times, time zones synopsis",
    "type": "function",
    "syntax": "function Dates, times, time zones synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_date_time_zones"
  },
  "time.num": {
    "name": "time.num",
    "type": "function",
    "syntax": "function long time.num ()",
    "description": "This returns the current time as the number of seconds since 00:00.",
    "arguments": [],
    "returnValue": "The current time as the number of seconds since 00:00.",
    "category": "functions_date_time_zones"
  },
  "timezone.exists": {
    "name": "timezone.exists",
    "type": "function",
    "syntax": "function boolean timezone.exists (string time_zone(50))",
    "description": "This checks that the input argument contains the name of a valid time zone.",
    "arguments": [
      {
        "type": "string",
        "name": "time_zone(50)",
        "description": ""
      }
    ],
    "returnValue": "true Success. false Error.",
    "category": "functions_date_time_zones"
  },
  "utc.add": {
    "name": "utc.add",
    "type": "function",
    "syntax": "function long utc.add (long i.utc, long year, long month, long day, long hour, long minute, long second, long o.utc)",
    "description": "This adds years, months, days, hours, minutes, seconds to the input UTC value and makes corrections if necessary.",
    "arguments": [
      {
        "type": "long",
        "name": "i.utc",
        "description": ""
      },
      {
        "type": "long",
        "name": "year",
        "description": ""
      },
      {
        "type": "long",
        "name": "month",
        "description": ""
      },
      {
        "type": "long",
        "name": "day",
        "description": ""
      },
      {
        "type": "long",
        "name": "hour",
        "description": ""
      },
      {
        "type": "long",
        "name": "minute",
        "description": ""
      },
      {
        "type": "long",
        "name": "second",
        "description": ""
      },
      {
        "type": "long",
        "name": "o.utc",
        "description": ""
      }
    ],
    "returnValue": "0 Success. 1 Best guess. 2 Failure. For example: Any intermediate result involves a date before the year 1 or past the year 9999. Any intermediate result or the final result of the addition is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range.",
    "category": "functions_date_time_zones"
  },
  "utc.num": {
    "name": "utc.num",
    "type": "function",
    "syntax": "function long utc.num ()",
    "description": "This returns the current local date and time in UTC long format.",
    "arguments": [],
    "returnValue": "The UTC long format value. -1 Error.",
    "category": "functions_date_time_zones"
  },
  "utc.to.date": {
    "name": "utc.to.date",
    "type": "function",
    "syntax": "function long utc.to.date (domain ttutc utc, ref long yearno, ref long monthno, ref long month_dayno, ref long hours, ref long minutes, ref long seconds)",
    "description": "This converts a UTC long format value to the corresponding year, month, day, and so on, in local time.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "month_dayno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "hours",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "seconds",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "utc.to.date.with.timezone.info": {
    "name": "utc.to.date.with.timezone.info",
    "type": "function",
    "syntax": "function long utc.to.date.with.timezone.info (domain ttutc utc, ref long yearno, ref long monthno, ref long month_dayno, ref long hours, ref long minutes, ref long seconds, ref long utcdiff)",
    "description": "This converts a UTC long format value to the corresponding year, month, day, and so on, in local time. The difference in seconds to UTC is returned in the variable utcdiff.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "monthno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "month_dayno",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "hours",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "seconds",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "utcdiff",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "utc.to.input": {
    "name": "utc.to.input",
    "type": "function",
    "syntax": "function string utc.to.input (domain ttutc lvalue, const string format())",
    "description": "This converts a UTC long format value to an input date string or an input time string (in local time). The format specified determines whether the function returns a date string or a time string.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "lvalue",
        "description": "A UTC long format value."
      },
      {
        "type": "const string",
        "name": "format()",
        "description": ""
      }
    ],
    "returnValue": "The representation of lvalue in the given format.",
    "category": "functions_date_time_zones"
  },
  "utc.to.inputstr$": {
    "name": "utc.to.inputstr$",
    "type": "function",
    "syntax": "function long utc.to.inputstr$ (domain ttutc utc, string date.format(7), string time.format(7), ref string local.date(), ref string local.time())",
    "description": "This converts a UTC long format value to a local date string and a local time string.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": "A UTC long format value."
      },
      {
        "type": "string",
        "name": "date.format(7)",
        "description": "Indicates the format for the returned date string, by using the substitution symbols %u xxx [, lang ] ."
      },
      {
        "type": "string",
        "name": "time.format(7)",
        "description": "Indicates the format for the returned time string, by using the substitution symbols %U xxx [, lang ] ."
      },
      {
        "type": "ref string",
        "name": "local.date()",
        "description": "The returned local date string."
      },
      {
        "type": "ref string",
        "name": "local.time()",
        "description": "The returned local time string."
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: An illegal format is specified.",
    "category": "functions_date_time_zones"
  },
  "utc.to.iso": {
    "name": "utc.to.iso",
    "type": "function",
    "syntax": "function string utc.to.iso (domain ttutc utc, long format)",
    "description": "This converts a UTC into a string representation of the UTC in ISO8601 format.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": "A UTC long format value."
      },
      {
        "type": "long",
        "name": "format",
        "description": "Can be one of the following constants: UTC_ISO_DIFF with time-zone"
      }
    ],
    "returnValue": "The string representation of the UTC in ISO-8601 format.",
    "category": "functions_date_time_zones"
  },
  "utc.to.local": {
    "name": "utc.to.local",
    "type": "function",
    "syntax": "function long utc.to.local (long utc, ref long local_days, ref long local_time [, ref string local_dst])",
    "description": "This converts a UTC long format value to local date and time.",
    "arguments": [
      {
        "type": "long",
        "name": "utc",
        "description": "The UTC long format value."
      },
      {
        "type": "ref long",
        "name": "local_days",
        "description": "The local date as the number of days since 01-01-0001."
      },
      {
        "type": "ref long",
        "name": "local_time",
        "description": "The local time as the number of seconds since 00:00 hour."
      },
      {
        "type": "[ref string",
        "name": "local_dst ]",
        "description": "Optional reference argument for receiving whether Daylight Saving Time (DST) is on or off, according to the current timezone rule (expressing local legislation). DST_ON: DST is on at the moment determined by the supplied utc value, DST_OFF: DST is off at the moment determined by the supplied utc value, DST_ON and DST_OFF are predefined literal strings of length 6 and 7 respectively."
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "utc.to.local.with.timezone.info": {
    "name": "utc.to.local.with.timezone.info",
    "type": "function",
    "syntax": "function long utc.to.local.with.timezone.info (domain ttutc utc, ref long local_days, ref long local_time, ref long utcdiff)",
    "description": "This converts a UTC long format value to local date and time. The difference in seconds to UTC is returned in the variable utcdiff.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": "The UTC long format value."
      },
      {
        "type": "ref long",
        "name": "local_days",
        "description": "The local date as the number of days since 01-01-0001."
      },
      {
        "type": "ref long",
        "name": "local_time",
        "description": "The local time as the number of seconds since 00:00 hour."
      },
      {
        "type": "ref long",
        "name": "utcdiff",
        "description": "The number of seconds the current timezone of the user is away from UTC."
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "utc.to.week": {
    "name": "utc.to.week",
    "type": "function",
    "syntax": "function long utc.to.week (domain ttutc utc, ref long week_dayno, ref long year_dayno, ref long weekno, ref long hours, ref long minutes, ref long seconds [, ref long yearno])",
    "description": "This converts a UTC long format value to the corresponding day of the week, day of the year, week of the year, and so on, in local time.",
    "arguments": [
      {
        "type": "domain ttutc",
        "name": "utc",
        "description": "The UTC long format value."
      },
      {
        "type": "ref long",
        "name": "week_dayno",
        "description": "The day of the week. This depends on which day is defined as the first day of the week in the user data settings in the data dictionary."
      },
      {
        "type": "ref long",
        "name": "year_dayno",
        "description": "The day number in the year."
      },
      {
        "type": "ref long",
        "name": "weekno",
        "description": "The week number in the year. See Week handling ."
      },
      {
        "type": "ref long",
        "name": "hours",
        "description": "The time of day."
      },
      {
        "type": "ref long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "seconds",
        "description": ""
      },
      {
        "type": "[ref long",
        "name": "yearno ]",
        "description": "The year number. This argument is optional."
      }
    ],
    "returnValue": "0 Success. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "week.to.num": {
    "name": "week.to.num",
    "type": "function",
    "syntax": "function long week.to.num (long weekno, long yearno, long week_dayno)",
    "description": "This returns the number of days since 01-01-0001 for a specified week number, year number, and day of the week. The day of the week is interpreted by using the day defined as the first day of the week in the user data settings in the data dictionary (see Week handling ).",
    "arguments": [
      {
        "type": "long",
        "name": "weekno",
        "description": ""
      },
      {
        "type": "long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "long",
        "name": "week_dayno",
        "description": ""
      }
    ],
    "returnValue": "The number of days since 01-01-0001. -1 Error. For example, the date is before the year 1 or past the year 9999.",
    "category": "functions_date_time_zones"
  },
  "week.to.utc": {
    "name": "week.to.utc",
    "type": "function",
    "syntax": "function domain ttutc week.to.utc (long weekno, long yearno, long week_dayno, long hours, long minutes, long seconds)",
    "description": "This converts a specified week number, year number, day number in week, and so on, in local time, to UTC long format. For information on week numbering, see Week handling . Input values must be in the signed 32-bit value range.",
    "arguments": [
      {
        "type": "long",
        "name": "weekno",
        "description": ""
      },
      {
        "type": "long",
        "name": "yearno",
        "description": ""
      },
      {
        "type": "long",
        "name": "week_dayno",
        "description": ""
      },
      {
        "type": "long",
        "name": "hours",
        "description": ""
      },
      {
        "type": "long",
        "name": "minutes",
        "description": ""
      },
      {
        "type": "long",
        "name": "seconds",
        "description": ""
      }
    ],
    "returnValue": "&#8805; 0 The UTC long format value. -1 Error. For example: Any intermediate result involves a date before the year 1 or past the year 9999. The exact result is negative or greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range.",
    "category": "functions_date_time_zones"
  },
  "dbcm.checked.out.objects.present": {
    "name": "dbcm.checked.out.objects.present",
    "type": "function",
    "syntax": "function boolean dbcm.checked.out.objects.present (long comp [, string tbl.name$])",
    "description": "Checks if checked-out objects exist in given company and (if provided) given table.",
    "arguments": [
      {
        "type": "long",
        "name": "comp",
        "description": "Company number."
      },
      {
        "type": "[string",
        "name": "tbl.name$ ]",
        "description": "A table code, like \"tdsls400\", if not specified, tables are not checked."
      }
    ],
    "returnValue": "true Checked out objects are present in given company (and table). false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.find.object.by.workflow.id": {
    "name": "dbcm.find.object.by.workflow.id",
    "type": "function",
    "syntax": "function long dbcm.find.object.by.workflow.id (const string wf.id$, ref string toid$)",
    "description": "Finds a checked-out business object using the given workflow instance id. When the object is found, the Typed Object Id is returned.",
    "arguments": [
      {
        "type": "const string",
        "name": "wf.id$",
        "description": "A Workflow instance id."
      },
      {
        "type": "ref string",
        "name": "toid$",
        "description": "The returned Typed Object Id (only filled when the object was found)."
      }
    ],
    "returnValue": "0 The object was found succesfully. ENOREC (111) The object was not found; probably the object is not checked out. <> 0 Another database error.",
    "category": "functions_dbcm"
  },
  "dbcm.get.cm.action$": {
    "name": "dbcm.get.cm.action$",
    "type": "function",
    "syntax": "function string dbcm.get.cm.action$ (const string toid$)",
    "description": "Retrieves the Change Management action id of the Object that is identified by the given Typed Object Id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id; this is a string of 34 characters identifying a business object."
      }
    ],
    "returnValue": "The action id of the Object as string; or an empty string in case the Object is not checked-out. For the standard actions UI Create, UI Change and UI Delete, the action ids are predefined: DBCM_ACTION_CREATE DBCM_ACTION_CHANGE DBCM_ACTION_DELETE",
    "category": "functions_dbcm"
  },
  "dbcm.get.cm.status": {
    "name": "dbcm.get.cm.status",
    "type": "function",
    "syntax": "function enum dbcm.get.cm.status (const string toid$)",
    "description": "Retrieves the Change Management status of the Object that is identified by the given Typed Object Id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id; this is a string of 34 characters identifying a business object."
      }
    ],
    "returnValue": "Constant Value Description DBCM_STATUS_DRAFT 1 The Object is in the Draft state; it is checked-out, it can be modified and any changes can be submitted, or any changes can be undone by doing a Revert to Approved. DBCM_STATUS_DRAFT_REV 2 The Object is in the Draft state, for a second time; this state is equal to the DBCM_STATUS_DRAFT state, except that an Object can only enter this state after a Recall of any submitted changes was successful. DBCM_STATUS_PENDING 3 The Object is in the Pending state; this means any changes to the Object have been submitted and the user must wait until the changes are Approved or Rejected. The Object cannot be modified. DBCM_STATUS_RECALL_REQ 4 The Object is in the Recall Requested state; the user made a request to ignore any submitted changes, as he e.g. wants to make more changes to the Object. The Object cannot be modified. DBCM_STATUS_REJECTED 5 The Object is in the Rejected state; any submitted changes were not approved. The user must either make other changes and re-submit them, or perform a Revert to Approved. The Object can be modified. DBCM_STATUS_APPR_RECVD 6 The Object is in the Approval Received state; usually this state will not be visible to the user. It can only be visible if somehow, after receiving an Approval, the Object cannot be checked-in. In this situation an Admin must be involved in order to force a check-in, or to discard any changes and perform a Revert to Approved. The Object can be modified. DBCM_STATUS_APPROVED 7 The Object is in the Approved state; any submitted changes have been Approved, and the Object has been checked-in. The Object can be modified.",
    "category": "functions_dbcm"
  },
  "dbcm.get.functional.id$": {
    "name": "dbcm.get.functional.id$",
    "type": "function",
    "syntax": "function string dbcm.get.functional.id$ (const string toid$ [, long comp])",
    "description": "Retrieves the functional object id for a checked-out object.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      },
      {
        "type": "[long",
        "name": "comp ]",
        "description": "A company number to retrieve the functional id from."
      }
    ],
    "returnValue": "The functional id as string (key parts are concatenated using commas); or an empty string in case of an error.",
    "category": "functions_dbcm"
  },
  "dbcm.get.object.action$": {
    "name": "dbcm.get.object.action$",
    "type": "function",
    "syntax": "function string dbcm.get.object.action$ ()",
    "description": "Returns the currently selected object action (as selected with dbcm.select.object.action() ), or an empty string in case no object action has been selected.",
    "arguments": [],
    "returnValue": "The currently selected object action, or an empty string in case no object action is set.",
    "category": "functions_dbcm"
  },
  "dbcm.get.object.id$": {
    "name": "dbcm.get.object.id$",
    "type": "function",
    "syntax": "function string dbcm.get.object.id$ ()",
    "description": "Returns the id of the currently selected object instance (as selected with dbcm.select.object.instance() ), or an empty string in case no object instance is selected or if a previously selected object instance is out of scope.",
    "arguments": [],
    "returnValue": "The id of the currently selected object instance, or an empty string in case no object instance is set.",
    "category": "functions_dbcm"
  },
  "dbcm.get.object.type$": {
    "name": "dbcm.get.object.type$",
    "type": "function",
    "syntax": "function string dbcm.get.object.type$ ()",
    "description": "Returns the currently selected object type (as selected with dbcm.select.object.type() ), or an empty string in case no object type is selected or if the previously selected object type is out of scope.",
    "arguments": [],
    "returnValue": "The currently selected object type, or an empty string in case no object type is set.",
    "category": "functions_dbcm"
  },
  "dbcm.get.rcd.action": {
    "name": "dbcm.get.rcd.action",
    "type": "function",
    "syntax": "function long dbcm.get.rcd.action (long tbl.id)",
    "description": "Retrieves the CM Action of the current record of the given table id.",
    "arguments": [
      {
        "type": "long",
        "name": "tbl.id",
        "description": "A table id as returned by db.bind() , or a standard table id, like ttdsls400."
      }
    ],
    "returnValue": "CMAC_NONE (0) There is no checked-out version of this record. Note that this particular may still be part of a checked-out business object. Conceptually, the complete business object is checked-out, however on individual record level, some records may still be unchanged, compared to the checked-in version. CMAC_INSERT (1) The record has been inserted. This means that there is only a checked-out version of this record and no checked-in version. CMAC_UPDATE (2) The record has been updated. This means that there two versions of this record, a checked-in and a checked-out one, which differ from each other. CMAC_DELETE (3) The record has been deleted. This means that physically there are two versions of this record, a checked-in and a checked-out one. However, the checked-out one cannot be retrieved from the database with a query. So conceptually, this record has been deleted from the checked-out business object. CMAC_GHOST (11) Very short lived value that can be visible using a dirty read database",
    "category": "functions_dbcm"
  },
  "dbcm.get.rcd.prst": {
    "name": "dbcm.get.rcd.prst",
    "type": "function",
    "syntax": "function enum dbcm.get.rcd.prst (long tbl.id)",
    "description": "Retrieves the checked-in value of the workflow application status field (identified by dbcm.get.app.status.field() )of business object related to the current record buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "tbl.id",
        "description": "A table id as returned by db.bind() , or a standard table id, like ttdsls400."
      }
    ],
    "returnValue": "empty The current record buffer is not a record of the root table of any object type or the object type does not have workflow application status field or no checked-in version of the business object related to this current record buffer. <> empty the current record buffer is a record of the root table and the related object type has a workflow application status field.",
    "category": "functions_dbcm"
  },
  "dbcm.get.rcd.toid$": {
    "name": "dbcm.get.rcd.toid$",
    "type": "function",
    "syntax": "function string dbcm.get.rcd.toid$ (long tbl.id)",
    "description": "Retrieves the Typed Object ID of the current record of the given table id.",
    "arguments": [
      {
        "type": "long",
        "name": "tbl.id",
        "description": "A table id as returned by db.bind() , or a standard table id, like ttdsls400."
      }
    ],
    "returnValue": "The Typed Object ID, or an empty string in case no Typed Object ID could be found.",
    "category": "functions_dbcm"
  },
  "dbcm.get.root.table$": {
    "name": "dbcm.get.root.table$",
    "type": "function",
    "syntax": "function string dbcm.get.root.table$ (const string toid.or.obj.type$)",
    "description": "Returns the root table of an either an Object or an Object Type.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid.or.obj.type$",
        "description": "A Typed Object Id, or an Object Type. A Typed Object Id is a string of 34 characters identifying a checked-out business object. An Object Type is a string of 6 characters identifying a business object type."
      }
    ],
    "returnValue": "The root table code, or an empty string in case of an error.",
    "category": "functions_dbcm"
  },
  "dbcm.get.type.name": {
    "name": "dbcm.get.type.name",
    "type": "function",
    "syntax": "function long dbcm.get.type.name (const string tbl.name$, ref string obj.type$)",
    "description": "Returns the object type for the given table, as defined in the Object Configuration Management model for the current package combination.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name$",
        "description": "A table code, e.g. \"tdsls400\"."
      },
      {
        "type": "ref string",
        "name": "obj.type$",
        "description": "The returned object type as defined in the Object Configuration Management model. This is a string of max 6 characters. In case no object type is defined for the given table, an empty string is returned. In case multiple object types are defined for the given table, this value is undefined."
      }
    ],
    "returnValue": "0 In case of success. -1 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning. 1 The given table occurs in more than one object type (ie. the table is a shared table); an example of this may be table tcibd420.",
    "category": "functions_dbcm"
  },
  "dbcm.get.user": {
    "name": "dbcm.get.user",
    "type": "function",
    "syntax": "function long dbcm.get.user (const string toid$, ref string user$)",
    "description": "Retrieves the user who last 'touched' the Business object which is identified by the specified type object id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      },
      {
        "type": "ref string",
        "name": "user$",
        "description": "The returned user code. In case of an error this parameter is not reset."
      }
    ],
    "returnValue": "0 The user code is retrieved successfully. ENOREC The object cannot be found; probably the object is not checked-out. <> 0 Any other database error.",
    "category": "functions_dbcm"
  },
  "dbcm.get.workflow.definition": {
    "name": "dbcm.get.workflow.definition",
    "type": "function",
    "syntax": "function long dbcm.get.workflow.definition (const string toid$, ref string wf.def$)",
    "description": "Retrieves the workflow definition id of the checked-out business object which is identified by the specified Typed Object Id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      },
      {
        "type": "ref string",
        "name": "wf.def$",
        "description": "The returned workflow definition id as string. In case of an error this parameter is not reset."
      }
    ],
    "returnValue": "0 The workflow definition id is retrieved successfully. ENOREC The object cannot be found; probably the object is not checked-out. <> 0 Any other database error.",
    "category": "functions_dbcm"
  },
  "dbcm.get.workflow.id": {
    "name": "dbcm.get.workflow.id",
    "type": "function",
    "syntax": "function long dbcm.get.workflow.id (const string toid$, ref string wf.id$)",
    "description": "Retrieves the workflow instance id of the checked-out business object which is identified by the specified Typed Object Id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      },
      {
        "type": "ref string",
        "name": "wf.id$",
        "description": "The returned workflow instance id as string. In case of an error this parameter is not reset."
      }
    ],
    "returnValue": "0 The workflow definition id is retrieved successfully. ENOREC The object cannot be found; probably the object is not checked-out. <> 0 Any other database error.",
    "category": "functions_dbcm"
  },
  "dbcm.is.action.active": {
    "name": "dbcm.is.action.active",
    "type": "function",
    "syntax": "function boolean dbcm.is.action.active ()",
    "description": "Tests whether the currently selected object action (as selected with dbcm.select.object.action() ) is active according to the Object Configuration Management deployment.",
    "arguments": [],
    "returnValue": "true The currently selected object action is active. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.is.cm.active": {
    "name": "dbcm.is.cm.active",
    "type": "function",
    "syntax": "function boolean dbcm.is.cm.active (const string tbl.name$ [, long comp])",
    "description": "Tests whether Change Management is active for the given table (and optionally the company number), as defined in the Object Configuration Management deployment for the current package combination.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name$",
        "description": "A table code, like \"tdsls400\"."
      },
      {
        "type": "[long",
        "name": "comp ]",
        "description": "The company number in which the perform the test. If not specified, the test is done in the current company."
      }
    ],
    "returnValue": "true In case Change Management is active for the given table (and company). false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.is.root.table": {
    "name": "dbcm.is.root.table",
    "type": "function",
    "syntax": "function boolean dbcm.is.root.table (const string tbl.name$)",
    "description": "Tests whether the given table is an Object Type root table, as defined in the Object Configuration Management model for the current package combination.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name$",
        "description": "A table code, like \"tdsls400\"."
      }
    ],
    "returnValue": "true In case the given table is a root table. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.object.check.out.is.being.undone": {
    "name": "dbcm.object.check.out.is.being.undone",
    "type": "function",
    "syntax": "function boolean dbcm.object.check.out.is.being.undone (const string toid$)",
    "description": "Checks if the check-out of the specified object is being undone. That is, if the dbcm.undo.check.out.object() function is in progress.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      }
    ],
    "returnValue": "true The check-out is being undone. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.object.is.being.checked.in": {
    "name": "dbcm.object.is.being.checked.in",
    "type": "function",
    "syntax": "function boolean dbcm.object.is.being.checked.in (const string toid$)",
    "description": "Tests whether the business object identified by the specified Typed Object Id is being checked-in.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      }
    ],
    "returnValue": "true The business object is being checked-in. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.object.is.checked.in": {
    "name": "dbcm.object.is.checked.in",
    "type": "function",
    "syntax": "function boolean dbcm.object.is.checked.in (const string toid$)",
    "description": "Tests whether the business object identified by the specified Typed Object Id is checked-in.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      }
    ],
    "returnValue": "true The business object is checked-in. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.object.is.checked.out": {
    "name": "dbcm.object.is.checked.out",
    "type": "function",
    "syntax": "function boolean dbcm.object.is.checked.out (const string toid$)",
    "description": "Tests whether the business object identified by the specified Typed Object Id is checked-out.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id. A Typed Object Id is a string of 34 characters identifying a checked-out business object."
      }
    ],
    "returnValue": "true The business object is checked-out. false In any other case.",
    "category": "functions_dbcm"
  },
  "dbcm.object.remains.checked.in": {
    "name": "dbcm.object.remains.checked.in",
    "type": "function",
    "syntax": "function long dbcm.object.remains.checked.in (ref long tbl.id, long cmac, ref boolean b.eval)",
    "description": "Tests whether the business object related to the current record buffer remains checked in.",
    "arguments": [
      {
        "type": "ref long",
        "name": "tbl.id",
        "description": "A table id as returned by db.bind() , or a standard table id, like ttdsls400."
      },
      {
        "type": "long",
        "name": "cmac",
        "description": "An CM Action type. Parameter cmac should be one of the following values: CMAC_INSERT, CMAC_UPDATE, CMAC_DELETE ."
      },
      {
        "type": "ref boolean",
        "name": "b.eval",
        "description": "Indicates whether the business object related to the current record buffer will be checked out ('false') or remains checked in ('true')."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case an error occurred such as: table id is invalid, object could not be determined or CheckOutCondition could not be evaluated.",
    "category": "functions_dbcm"
  },
  "dbcm.read.object": {
    "name": "dbcm.read.object",
    "type": "function",
    "syntax": "function long dbcm.read.object (const string toid$ [, long comp])",
    "description": "Reads and makes the business object current, based on the the given typed object id. In case the business object consists of multiple tables, the root table is accessed.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      },
      {
        "type": "[long",
        "name": "comp ]",
        "description": "The company to read in. If not specified, reading is done in the current company."
      }
    ],
    "returnValue": "0 The database read was successful. <> 0 An error occurred. cDbcm_UnknownTable (7) is returned in case no root table can be determined, or in case Change Management is not active for the root table. ENOREC (111) is returned in case no record can be found.",
    "category": "functions_dbcm"
  },
  "dbcm.reject": {
    "name": "dbcm.reject",
    "type": "function",
    "syntax": "function long dbcm.reject (const string toid$, const string reason$)",
    "description": "Rejects any changes and/or actions done to the checked-out business object that is identified by the given Typed Object Id and sets the given reason for rejecting.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      },
      {
        "type": "const string",
        "name": "reason$",
        "description": "A text stating the reason for rejecting the previous changes and/or actions made on the object."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform a reject. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.select.checked.in.mode": {
    "name": "dbcm.select.checked.in.mode",
    "type": "function",
    "syntax": "function long dbcm.select.checked.in.mode (boolean value)",
    "description": "Sets the checked in mode",
    "arguments": [
      {
        "type": "boolean",
        "name": "value",
        "description": "specify 'true' to select the checked in mode. specify 'false' to deselect the checked in mode."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning.",
    "category": "functions_dbcm"
  },
  "dbcm.select.object.action": {
    "name": "dbcm.select.object.action",
    "type": "function",
    "syntax": "function long dbcm.select.object.action (const string action.id$)",
    "description": "Selects the specified object action.",
    "arguments": [
      {
        "type": "const string",
        "name": "action.id$",
        "description": "An id which identifies a specific action, as defined in the Object Configuration Management model. This is a string of max 6 characters."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning.",
    "category": "functions_dbcm"
  },
  "dbcm.select.object.instance": {
    "name": "dbcm.select.object.instance",
    "type": "function",
    "syntax": "function long dbcm.select.object.instance (const string toid$)",
    "description": "Selects the specified Object instance.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id, which identifies a specific checked-out business object."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning.",
    "category": "functions_dbcm"
  },
  "dbcm.select.object.type": {
    "name": "dbcm.select.object.type",
    "type": "function",
    "syntax": "function long dbcm.select.object.type (const string obj.type$)",
    "description": "Selects the specified Object Type.",
    "arguments": [
      {
        "type": "const string",
        "name": "obj.type$",
        "description": "An object type code as defined in the Object Configuration Management model. This is a string of max 6 characters."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning.",
    "category": "functions_dbcm"
  },
  "dbcm.set.approved": {
    "name": "dbcm.set.approved",
    "type": "function",
    "syntax": "function long dbcm.set.approved (const string toid$)",
    "description": "Assigns the Approval Received status to the checked-out Business Object that is identified by the given Typed Object Id. Afterwards the business object will be checked-in.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.set.draft": {
    "name": "dbcm.set.draft",
    "type": "function",
    "syntax": "function long dbcm.set.draft (const string toid$)",
    "description": "Assigns the Draft status to the checked-out Business Object that is identified by the given Typed Object Id.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.set.not.started": {
    "name": "dbcm.set.not.started",
    "type": "function",
    "syntax": "function long dbcm.set.not.started (const string toid$)",
    "description": "Assigns the Not Started status to the checked-in Business Object that is identified by the given Typed Object Id and has the Approved status. This indicates that a previous request to recall the already started workflow process has been processed and acknowledged.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.set.object.type": {
    "name": "dbcm.set.object.type",
    "type": "function",
    "syntax": "function long dbcm.set.object.type (const string obj.type$)",
    "description": "Sets the specified Object Type in a 4GL session.",
    "arguments": [
      {
        "type": "const string",
        "name": "obj.type$",
        "description": "An object type code as defined in the Object Configuration Management model. This is a string of max 6 characters."
      }
    ],
    "returnValue": "0 In case of success. <> 0 In case of an error; variable e contains the error code. See Database Change Management (DBCM) error codes for more information about the error codes and their meaning.",
    "category": "functions_dbcm"
  },
  "dbcm.set.rcd.toid": {
    "name": "dbcm.set.rcd.toid",
    "type": "function",
    "syntax": "function void dbcm.set.rcd.toid (long tbl.id, const string toid$)",
    "description": "Sets the given Typed Object ID in the (default) record buffer the given table.",
    "arguments": [
      {
        "type": "long",
        "name": "tbl.id",
        "description": "A table id as returned by db.bind() , or a standard table id, like ttdsls400."
      },
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object ID."
      }
    ],
    "returnValue": "",
    "category": "functions_dbcm"
  },
  "dbcm.set.recalled": {
    "name": "dbcm.set.recalled",
    "type": "function",
    "syntax": "function long dbcm.set.recalled (const string toid$)",
    "description": "Assigns the Draft (Revision) status to the checked-out Business Object that is identified by the given Typed Object Id. This indicates that a previous request to recall the already started workflow process has been processed and acknowledged.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.set.submitted": {
    "name": "dbcm.set.submitted",
    "type": "function",
    "syntax": "function long dbcm.set.submitted (const string toid$, const string wf.id$)",
    "description": "Sets the workflow instance id of the checked-out business object that is identified by the given Typed Object Id. This indicates that a previous submit has been confirmed and that the Workflow has been started.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      },
      {
        "type": "const string",
        "name": "wf.id$",
        "description": "A workflow instance id as received from ION Workflow. This is a reference to the Workflow Process that has been started in ION."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "dbcm.set.workflow.definition": {
    "name": "dbcm.set.workflow.definition",
    "type": "function",
    "syntax": "function long dbcm.set.workflow.definition (const string toid$, const string wf.def$)",
    "description": "Sets the workflow definition id of the checked-out business object that is identified by the given Typed Object Id. This id is a reference to a Workflow Process Definition in ION Workflow. On submit (and in case ION Workflow should be involved), an instance of this process will be started in ION Workflow.",
    "arguments": [
      {
        "type": "const string",
        "name": "toid$",
        "description": "A Typed Object Id."
      },
      {
        "type": "const string",
        "name": "wf.def$",
        "description": "A workflow definition id. This is a reference to a Workflow Process definition in ION Workflow."
      }
    ],
    "returnValue": "0 In case of success. DBCM_INVALID_STATE (-1) The object is in a state in which it is not allowed to perform this function. > 0 A database error occurred.",
    "category": "functions_dbcm"
  },
  "database change management (dbcm) error codes": {
    "name": "Database Change Management (DBCM) error codes",
    "type": "function",
    "syntax": "function Database Change Management (DBCM) error codes()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbcm"
  },
  "database change management (dbcm) overview": {
    "name": "Database Change Management (DBCM) overview",
    "type": "function",
    "syntax": "function Database Change Management (DBCM) overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbcm"
  },
  "database change management operations synopsis": {
    "name": "Database Change Management operations synopsis",
    "type": "function",
    "syntax": "function Database Change Management operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbcm"
  },
  "db.after.delete": {
    "name": "db.after.delete",
    "type": "function",
    "syntax": "function extern long db.after.delete ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "db.after.insert": {
    "name": "db.after.insert",
    "type": "function",
    "syntax": "function extern long db.after.insert ()",
    "description": "This hook is called in case data is inserted, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.new.object() or dal.new() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "db.after.update": {
    "name": "db.after.update",
    "type": "function",
    "syntax": "function extern long db.after.update ()",
    "description": "This hook is called in case data is updated, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.save.object() or dal.update() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "db.before.delete": {
    "name": "db.before.delete",
    "type": "function",
    "syntax": "function extern long db.before.delete ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "db.before.insert": {
    "name": "db.before.insert",
    "type": "function",
    "syntax": "function extern long db.before.insert ()",
    "description": "This hook is called in case data is inserted, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.new.object() or dal.new() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "db.before.update": {
    "name": "db.before.update",
    "type": "function",
    "syntax": "function extern long db.before.update ()",
    "description": "This hook is called in case data is updated, either by the user pressing the save button on the UI, or programmatically when one of the function dal.update() .",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_dbdll"
  },
  "disable.db.dll": {
    "name": "disable.db.dll",
    "type": "function",
    "syntax": "function void disable.db.dll ()",
    "description": "This disables the call of the db hooks in the db dll. (db.before.insert, db.before.update, db.before.delete, db.after.insert, db.after.update, db.after.delete)",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbdll"
  },
  "enable.db.dll": {
    "name": "enable.db.dll",
    "type": "function",
    "syntax": "function void enable.db.dll ()",
    "description": "This enables the call of the db hooks in the db dll. (db.before.insert, db.before.update, db.before.delete, db.after.insert, db.after.update, db.after.delete)",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbdll"
  },
  "db dll overview": {
    "name": "DB DLL Overview",
    "type": "function",
    "syntax": "function DB DLL Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dbdll"
  },
  "abort.io": {
    "name": "abort.io",
    "type": "function",
    "syntax": "function void abort.io (string mesg(14) [, ...])",
    "description": "This cancels the current database transaction.",
    "arguments": [
      {
        "type": "string",
        "name": "mesg(14)",
        "description": "This specifies a message defined in the data dictionary. The message is displayed on screen when abort.io() is called. If you specify an empty string here, the 4GL engine displays a default message. The argument can contain substitution symbols such as %d or face= %s (see sprintf$() . The values that must be substituted are specified in the second, third, etc. arguments of the function. The number of arguments is variable."
      },
      {
        "type": "[",
        "name": "... ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "abort.transaction": {
    "name": "abort.transaction",
    "type": "function",
    "syntax": "function long abort.transaction ()",
    "description": "This cancels the current database transaction. No changes are stored in the database.",
    "arguments": [],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "activate.search": {
    "name": "activate.search",
    "type": "function",
    "syntax": "function void activate.search ()",
    "description": "This forces a random search action on the main table. You call the function immediately after input to a field during insertion of a new record (standard command ADD.SET or DUPL.OCCUR) or during MODIFY.SET (if the predefined variable modify.prim.key is set to TRUE).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "commit.transaction": {
    "name": "commit.transaction",
    "type": "function",
    "syntax": "function long commit.transaction ()",
    "description": "This ends the current transaction. All changes made during the transaction are stored in the database.",
    "arguments": [],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "count.records.in.view": {
    "name": "count.records.in.view",
    "type": "function",
    "syntax": "function long count.records.in.view ()",
    "description": "Counts the number of records that exist in the maintable for the current view. Any filter or query extension that has been set is taken into account.",
    "arguments": [],
    "returnValue": "The number of records that are exists in the maintable for the current view.",
    "category": "functions_db_operations"
  },
  "dal.change.object": {
    "name": "dal.change.object",
    "type": "function",
    "syntax": "function long dal.change.object (string dal_name)",
    "description": "Use this to indicate the DAL that the current record is about to be changed. After this call, fields can be changed with dal.set.field() . And after that, the record can be saved with dal.save.object() .",
    "arguments": [
      {
        "type": "string",
        "name": "dal_name",
        "description": "A string containing the name of the DAL."
      }
    ],
    "returnValue": "0 OK DALHOOKERROR The DAL could not be opened",
    "category": "functions_db_operations"
  },
  "dal.check.field": {
    "name": "dal.check.field",
    "type": "function",
    "syntax": "function long dal.check.field (string fld.name [, long element] [, long mode])",
    "description": "Checks whether the given field has a valid value. This performs the DAL check hooks in the given mode (default is DAL_UPDATE).",
    "arguments": [
      {
        "type": "string",
        "name": "fld.name",
        "description": "the name of the field"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element of the field in case of array fields (default is 1)"
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "mode for the check (default is DAL_UPDATE)"
      }
    ],
    "returnValue": "0 Field is valid DALHOOKERROR Field is invalid",
    "category": "functions_db_operations"
  },
  "dal.copy.object": {
    "name": "dal.copy.object",
    "type": "function",
    "syntax": "function long dal.copy.object (string dal_name)",
    "description": "Use this to indicate the DAL that a record is about to be copied. In contrary to dal.new.object() , this function does not call the set.object.defaults() hook!",
    "arguments": [
      {
        "type": "string",
        "name": "dal_name",
        "description": "A string containing the name of the DAL."
      }
    ],
    "returnValue": "0 OK DALHOOKERROR The DAL could not be opened",
    "category": "functions_db_operations"
  },
  "dal.destroy": {
    "name": "dal.destroy",
    "type": "function",
    "syntax": "function void dal.destroy (string dal.name, long object_set, ref long retval, long prop_check [, long mode] [, long eflag])",
    "description": "Use this to delete a database record. The function encapsulates the db.delete() function with the DAL hooks of the object set. If the before.destroy.object() hook fails, the database operation is cancelled.",
    "arguments": [
      {
        "type": "string",
        "name": "dal.name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "ref long",
        "name": "retval",
        "description": "The return value of the object hooks (<0), of the db.delete() function (>0), or 0 if the function is successful."
      },
      {
        "type": "long",
        "name": "prop_check",
        "description": "A boolean value that indicates whether or not the method.is.allowed() hook must be executed. If set to TRUE, the method.is.allowed() hook is executed immediately before the before.destroy.object() hook. If set to FALSE, the method.is.allowed() hook is not executed."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Set this to DB.RETRY if retry points and the SELECT FOR UPDATE statement are being used. The actual database action is postponed until the transaction is committed."
      },
      {
        "type": "[long",
        "name": "eflag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.destroy.object": {
    "name": "dal.destroy.object",
    "type": "function",
    "syntax": "function long dal.destroy.object (string tbl.name [, long error.flag])",
    "description": "Deletes a record of the given table. The record must have been locked for update. This function does the same as dal.destroy() , however it does more detailed permission checking. Further, the method.is.allowed() hook is always called ( dal.destroy() allows you to skip this hook by passing FALSE to the prop_check parameter).",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "The table name of the DAL."
      },
      {
        "type": "[long",
        "name": "error.flag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling ."
      }
    ],
    "returnValue": "0 Record is deleted DALHOOKERROR One of the hooks blocked the delete action DALNOSETPERM No table level permission DALNOOBJPERM No record level permission >0 The error code of the db.delete() action",
    "category": "functions_db_operations"
  },
  "dal.get.field.mode": {
    "name": "dal.get.field.mode",
    "type": "function",
    "syntax": "function long dal.get.field.mode (string tbl.name [, long element])",
    "description": "Returns the mode of the given field. The mode indicates if the field has changed.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "the name of the field"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element of the field in case of arrays (default is 1)"
      }
    ],
    "returnValue": "0 Field is not changed DAL_NEW Field has changed during insert of a record DAL_UPDATE Field has changed during update of a record",
    "category": "functions_db_operations"
  },
  "dal.get.object": {
    "name": "dal.get.object",
    "type": "function",
    "syntax": "function long dal.get.object (string tbl.name, long lock [, string key_field1] [, string key_value1], ...)",
    "description": "Reads a record of the given table. In case the lock parameter is set to true, the record is locked for update. This function accepts a list of primary key field/value pairs.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "the table name of the DAL."
      },
      {
        "type": "long",
        "name": "lock",
        "description": "if true the record is locked for update"
      },
      {
        "type": "[string",
        "name": "key_field1 ]",
        "description": ""
      },
      {
        "type": "[string",
        "name": "key_value1 ]",
        "description": ""
      },
      {
        "type": "",
        "name": "...",
        "description": "List of primary key field / value pairs in the format \"ppmmm999.ffff\", value. In case of array elements, specify the field as \"ppmmm999.ffff(element)\""
      }
    ],
    "returnValue": "0 Record is read or locked for update DALHOOKERROR One of the hooks blocked the read action DALNOOBJPERM No record level permission >0 The error code of the read action in case this failed (e.g. ENOREC). For a list of possible errormessages see the list of db-errormessages .",
    "category": "functions_db_operations"
  },
  "dal.get.property.flag": {
    "name": "dal.get.property.flag",
    "type": "function",
    "syntax": "function long dal.get.property.flag (string tbl.name, long object_set, string prop_name)",
    "description": "Use this to retrieve the value of the has_changed flag (see Property hooks ) for any database property dat.get.property.flag. The property must have been changed by the dal.set.property() function.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "string",
        "name": "prop_name",
        "description": "A string containing the name of the field for which the has_changed value must be returned."
      }
    ],
    "returnValue": "The function returns the value of the has_changed flag of the specified property. The possible values are: 0 Property not changed. DAL_NEW Change caused by inserting a new object. DAL_UPDATE Change caused by updating an existing object. Properties with no check function in the DAL always return 0.",
    "category": "functions_db_operations"
  },
  "dal.is.copy.active": {
    "name": "dal.is.copy.active",
    "type": "function",
    "syntax": "function boolean dal.is.copy.active ()",
    "description": "You can use this in the before.save.object() and after.save.object() hooks in DAL_NEW mode, to test whether the current record is being inserted, or being copied.",
    "arguments": [],
    "returnValue": "true when the current record is being copied, false in any other case.",
    "category": "functions_db_operations"
  },
  "dal.is.field.changed": {
    "name": "dal.is.field.changed",
    "type": "function",
    "syntax": "function boolean dal.is.field.changed (string fld.name [, long element])",
    "description": "Use this to test whether a field has changed. It is equivalent to:",
    "arguments": [
      {
        "type": "string",
        "name": "fld.name",
        "description": "A string containing the field name"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "Optional element, use this in case of array elements"
      }
    ],
    "returnValue": "TRUE in case the field has changed, FALSE in case the field has not changed.",
    "category": "functions_db_operations"
  },
  "dal.new": {
    "name": "dal.new",
    "type": "function",
    "syntax": "function void dal.new (string tbl.name, long object_set, ref long retval, long prop_check [, long mode] [, long eflag])",
    "description": "Use this to add a new record to the database. The function encapsulates the db.insert() function with the DAL hooks of the object set. If the before.save.object() hook fails, the database operation is cancelled.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "ref long",
        "name": "retval",
        "description": "The return value of the object hooks (<0), of the db.insert() function (> 0), or 0 if the function is successful."
      },
      {
        "type": "long",
        "name": "prop_check",
        "description": "A boolean value that indicates whether or not property checks must be executed. If set to TRUE, the property checks are executed immediately before the before.save.object() hook. If set to FALSE, the property checks are not executed."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Set this to DB.RETRY if retry points and the SELECT FOR UPDATE statement are being used. The actual database action is postponed until the transaction is committed."
      },
      {
        "type": "[long",
        "name": "eflag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.new.object": {
    "name": "dal.new.object",
    "type": "function",
    "syntax": "function long dal.new.object (string tbl.name)",
    "description": "Use this to indicate the DAL that a new record is about to be inserted. This function set record defaults, by calling db.set.to.default() and the set.object.defaults() hook.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "A string containing the name of the DAL."
      }
    ],
    "returnValue": "0 OK DALHOOKERROR The DAL could not be opened",
    "category": "functions_db_operations"
  },
  "dal.parent.caused.update": {
    "name": "dal.parent.caused.update",
    "type": "function",
    "syntax": "function boolean dal.parent.caused.update (string fld.name [, long element])",
    "description": "This function may only be called within an .update() hook. It checks whether this call to this hook was triggered by a change in field fld.name .",
    "arguments": [
      {
        "type": "string",
        "name": "fld.name",
        "description": "A string containing the name of the field (e.g., \"whinh312.lsta\"). The current field must depend directly on fld.name for HOOK_UPDATE."
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element of the field in case of array fields (default is 1)"
      }
    ],
    "returnValue": "true or false",
    "category": "functions_db_operations"
  },
  "dal.recall": {
    "name": "dal.recall",
    "type": "function",
    "syntax": "function long dal.recall (const string tbl.name)",
    "description": "Makes a request to recall the checked-out business object that is identified by the current record.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name",
        "description": "A table code."
      }
    ],
    "returnValue": "0 The request for recall was successfully made. <> 0 An error occurred.",
    "category": "functions_db_operations"
  },
  "dal.reject": {
    "name": "dal.reject",
    "type": "function",
    "syntax": "function long dal.reject (const string tbl.name, const string reason$)",
    "description": "Rejects any changes and/or actions done to the current checked-out Business Object and sets the given reason for rejecting.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name",
        "description": "A table code like \"tdsls400\"."
      },
      {
        "type": "const string",
        "name": "reason$",
        "description": "A reason for the rejection."
      }
    ],
    "returnValue": "0 The request for reject was successfully made. <> 0 An error occurred.",
    "category": "functions_db_operations"
  },
  "dal.save.object": {
    "name": "dal.save.object",
    "type": "function",
    "syntax": "function long dal.save.object (string tbl.name [, long error.flag])",
    "description": "Saves a record of the given table. In case a dal.new.object() or a dal.copy.object() was done, the record is inserted in the database. In case a dal.change.object() was done, the record is updated in the database.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "the table name of the DAL."
      },
      {
        "type": "[long",
        "name": "error.flag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling"
      }
    ],
    "returnValue": "0 Record is saved DALHOOKERROR One of the hooks blocked the save action DALDBERROR A domain or reference error occurred (only in Integration context (e.g. via a BOL)) DALNOSETPERM No table level permission DALNOOBJPERM No record level permission >0 The error code of the db.insert() or db.update() function",
    "category": "functions_db_operations"
  },
  "dal.set.array.field": {
    "name": "dal.set.array.field",
    "type": "function",
    "syntax": "function void dal.set.array.field (string fld.name, void value)",
    "description": "Sets the value of the given array field and informs the DAL that the field is changed. This function assigns a complete array at once. If you want to set only one or a few array elements, use function dal.set.field() .",
    "arguments": [
      {
        "type": "string",
        "name": "fld.name",
        "description": "the name of the array field"
      },
      {
        "type": "void",
        "name": "value",
        "description": "an array containing the new values for the field"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.set.field": {
    "name": "dal.set.field",
    "type": "function",
    "syntax": "function void dal.set.field (string fld.name, void value [, long element])",
    "description": "Sets the value of the given field and informs the DAL that the field is changed.",
    "arguments": [
      {
        "type": "string",
        "name": "fld.name",
        "description": "the name of the field"
      },
      {
        "type": "void",
        "name": "value",
        "description": "the new value of the field"
      },
      {
        "type": "[long",
        "name": "element ]",
        "description": "optional element of the field in case of array fields (default is 1)"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.set.property": {
    "name": "dal.set.property",
    "type": "function",
    "syntax": "function long dal.set.property (string tbl.name, long object_set, string prop_name, void value, long mode)",
    "description": "In order to notify the DAL about a change to the value of a property, you must use this function to change the value. Using this function ensures that the relevant property hooks are executed when the value is changed. If you use an assignment or the db.* functions to change a property value, the DAL is not notified of the change. Consequently, the property checks in the DAL are not executed.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "string",
        "name": "prop_name",
        "description": "The name of the property whose value must be changed."
      },
      {
        "type": "void",
        "name": "value",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": "Use this to indicate the value for the has_changed flag of the property. The possible values are DAL_NEW or DAL_UPDATE."
      }
    ],
    "returnValue": "Always 0",
    "category": "functions_db_operations"
  },
  "dal.set.property.with.check": {
    "name": "dal.set.property.with.check",
    "type": "function",
    "syntax": "function long dal.set.property.with.check (string tbl.name, long object_set, const string proper_name, void value)",
    "description": "In order to notify the DAL about a change to the value of a property, you must use this function to change the value. Using this function ensures that the relevant property hooks are executed when the value is changed. If you use an assignment or the db.* functions to change a property value, the DAL is not notified of the change. Consequently, the property checks in the DAL are not executed.",
    "arguments": [
      {
        "type": "string",
        "name": "tbl.name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "const string",
        "name": "proper_name",
        "description": "The name of the property whose value must be changed."
      },
      {
        "type": "void",
        "name": "value",
        "description": ""
      }
    ],
    "returnValue": "The return value of the property check.",
    "category": "functions_db_operations"
  },
  "dal.skip.never.applicable.checks": {
    "name": "dal.skip.never.applicable.checks",
    "type": "function",
    "syntax": "function void dal.skip.never.applicable.checks ( [boolean keep_old_data])",
    "description": "By default, the 4GL engine will check fields that are defined as never applicable. You can skip these checks by calling this function in the before.open.object.set() hook in the DAL.",
    "arguments": [
      {
        "type": "[boolean",
        "name": "keep_old_data ]",
        "description": "if this argument is KEEP_OLD_DATA (define for true) then the data of never applicable fields will stay unchanged. This argument is only available for dal with TIV LEVEL >= 2140"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.start.business.method": {
    "name": "dal.start.business.method",
    "type": "function",
    "syntax": "function void dal.start.business.method (string set_id, string name, ref long retval [, ...])",
    "description": "This starts a specified business method.",
    "arguments": [
      {
        "type": "string",
        "name": "set_id",
        "description": "Indicates the name of the DAL that implements the business method."
      },
      {
        "type": "string",
        "name": "name",
        "description": "The name of the business method."
      },
      {
        "type": "ref long",
        "name": "retval",
        "description": "The return value of the business method. Negative values are reserved for the calling mechanism. For example: -1 DALNOOBJSET -2 DALNOMETHOD The business method may return only DALHOOKERROR, 0, or positive numbers."
      },
      {
        "type": "[",
        "name": "... ]",
        "description": "Use these optional arguments to pass arguments to the business method."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "dal.submit": {
    "name": "dal.submit",
    "type": "function",
    "syntax": "function long dal.submit (const string tbl.name)",
    "description": "Assigns the Pending status to the checked-out Business Object that is identified by the current record.",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name",
        "description": "A table code."
      }
    ],
    "returnValue": "0 The submit was successful. <> 0 An error occurred.",
    "category": "functions_db_operations"
  },
  "dal.undo.check.out": {
    "name": "dal.undo.check.out",
    "type": "function",
    "syntax": "function long dal.undo.check.out (const string tbl.name)",
    "description": "Undoes a check-out of the business object to which the active record belongs. The undo check-out fails in case the business object is not checked-out, or if the state of the object is other than DBCM_STATUS_DRAFT , DBCM_STATUS_DRAFT_REV , or DBCM_STATUS_REJECTED .",
    "arguments": [
      {
        "type": "const string",
        "name": "tbl.name",
        "description": "A table code."
      }
    ],
    "returnValue": "0 In case of success. <> 0 An error occurred.",
    "category": "functions_db_operations"
  },
  "dal.update": {
    "name": "dal.update",
    "type": "function",
    "syntax": "function void dal.update (string class_name, long object_set, ref long retval, long prop_check [, long mode] [, long eflag])",
    "description": "Use this to update an existing database record. The function encapsulates the db.update() function with the DAL hooks of the object set. If the before.save.object() hook fails, the database operation is cancelled.",
    "arguments": [
      {
        "type": "string",
        "name": "class_name",
        "description": "A string containing the name of the DAL."
      },
      {
        "type": "long",
        "name": "object_set",
        "description": "The ID of an open object set (if this ID is not known, use the table ID)."
      },
      {
        "type": "ref long",
        "name": "retval",
        "description": "The return value of the object hooks (<0), of the db.insert() function (>0), or 0 if the function is successful."
      },
      {
        "type": "long",
        "name": "prop_check",
        "description": "A boolean value that indicates whether or not property checks must be executed. If set to TRUE, the property checks are executed immediately before the before.save.object() hook. If set to FALSE, the property checks are not executed."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Set this to DB.RETRY if retry points and the SELECT FOR UPDATE statement are being used. The actual database action is postponed until the transaction is committed."
      },
      {
        "type": "[long",
        "name": "eflag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling ."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.bind": {
    "name": "db.bind",
    "type": "function",
    "syntax": "function long db.bind (string table_name(9) [, ref string buffer(.)] [, long comp_nr])",
    "description": "This creates a pointer to a specified table. It returns a table ID that you use in other database calls to identify the table. The pointer is to a table with a particular company number and record buffer. You can create additional pointers to the same table by calling the function with a different company number and/or record buffer.",
    "arguments": [
      {
        "type": "string",
        "name": "table_name(9)",
        "description": "The table name."
      },
      {
        "type": "[ref string",
        "name": "buffer(.) ]",
        "description": "This optional argument specifies the record buffer to be used for the table. If you omit this argument, or if you specify an empty string, the default record buffer is used (that is, rcd.tppmmmxxx ). When the default record buffer is used, the contents of the buffer are automatically copied to the table fields in your program script. This does not happen when you specify a record buffer other than the default buffer. Therefore, when a record buffer is used which is not the default record buffer, you must call db.record.to.columns() to copy the field values from the record buffer to the table fields after using calls which change the record buffer, such as db.set.to.default() or db.eq() . Also use the function db.columns.to.record() to copy the field values from the table fields to the record buffer before using calls which use the record buffer, such as db.update() or (again) db.eq() ."
      },
      {
        "type": "[long",
        "name": "comp_nr ]",
        "description": "This optional argument specifies a company number for the table. The default company is the company of the user. If you include this argument, you must also include the buffer argument. So, if you want to specify a company other than the default company but want to use the default record buffer, specify the default buffer or an empty string in the buffer argument."
      }
    ],
    "returnValue": "0 Error. >0 Success; pointer is returned.",
    "category": "functions_db_operations"
  },
  "db.change.order": {
    "name": "db.change.order",
    "type": "function",
    "syntax": "function long db.change.order (long table_id, long index_nr [, long compnr])",
    "description": "This makes a specified index the current index. After this action, the record pointer is undefined.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "long",
        "name": "index_nr",
        "description": "The number of the index that you want to become the current index. The index must exist."
      },
      {
        "type": "[long",
        "name": "compnr ]",
        "description": "This optional argument specifies a company number for the table. The default company is the company of the user."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.check.restricted": {
    "name": "db.check.restricted",
    "type": "function",
    "syntax": "function long db.check.restricted (long table_id, long mode, ref string message(256))",
    "description": "In a table definition, it is possible to set restrictions on update and/or delete actions for records that are referenced by other tables. These restrictions mean that you cannot delete and/or update the primary key that is referenced by another table. This function checks whether there are references to the current record with delete and/or update restrictions. This function can take a long time to complete if no reference counter is kept (lookup mode).",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "Use to specify whether you want to check for delete or update restrictions. Possible values are: 1 delete mode 2 update mode"
      },
      {
        "type": "ref string",
        "name": "message(256)",
        "description": "This returns the reference message of the table. This message is defined in the data dictionary."
      }
    ],
    "returnValue": "0 No reference found. 1 One or more references found. -1 Error.",
    "category": "functions_db_operations"
  },
  "db.check.row.changed": {
    "name": "db.check.row.changed",
    "type": "function",
    "syntax": "function long db.check.row.changed (long table_id)",
    "description": "This function checks whether a record that has been delayed locked and changed by the current process has been changed by another process (\"user\"). It does not check whether the row has been modified in the current process. In a way it answers the question: \"If I would update the current record now, would I get the infamous EROWCHANGED error?\"",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Record has not been changed by another process. <>0 Error. EROWCHANGED Record has been changed by another process. ENOCURR No current record set. The db-call interface (e.g. db.eq( ..., db.delayed)) must be used to set a current record, before calling the db.check.row.changed() function. ENOTLOCKED Record has not been (delayed) locked.",
    "category": "functions_db_operations"
  },
  "db.check.row.dlocked": {
    "name": "db.check.row.dlocked",
    "type": "function",
    "syntax": "function long db.check.row.dlocked (long table_id)",
    "description": "This checks whether the row, identified by its primary key columns is delayed locked or not. If the row is already locked, the function returns the dlock number of the row. This function can result in a considerable performance gain as it eradicates the need for multiple reads of the same record.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Row is not locked n The dlock number, implying that row is locked <0 Error.",
    "category": "functions_db_operations"
  },
  "db.check.row.domains": {
    "name": "db.check.row.domains",
    "type": "function",
    "syntax": "function long db.check.row.domains (long table_id, ref string fld_name)",
    "description": "This checks whether the current record of a specified table conforms to the domain definitions in the data dictionary. All fields of the record are checked in turn until an error occurs. The function returns when the first error is encountered.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "ref string",
        "name": "fld_name",
        "description": "This returns the name of the first incorrect field."
      }
    ],
    "returnValue": "0 No errors. -1 Invalid table ID. ENOTINRANGE Error in a field. If an error is returned, you can retrieve information about the specific error using db.error.message() .",
    "category": "functions_db_operations"
  },
  "db.clear.table": {
    "name": "db.clear.table",
    "type": "function",
    "syntax": "function long db.clear.table (long table_id [, long flag] [, long comp_nr])",
    "description": "This deletes all data from a specified table. Reference counters are automatically updated.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "flag ]",
        "description": "Use this optional argument to indicate whether the delete operation must be performed as a single transaction or as multiple transactions. The possible values are: 0 WITH.ROLLBACK"
      }
    ],
    "returnValue": "0 success <>0 error",
    "category": "functions_db_operations"
  },
  "db.columns.to.record": {
    "name": "db.columns.to.record",
    "type": "function",
    "syntax": "function long db.columns.to.record (long table_id)",
    "description": "The record buffer of a table is used for reading records from, or writing records to, that table. When you bind to a table (see db.bind() ) and specify that the default record buffer is to be used, the contents of the table fields are automatically copied to the buffer. This does not happen when you specify a record buffer other than the default buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.create.table": {
    "name": "db.create.table",
    "type": "function",
    "syntax": "function long db.create.table (long table_id, long compnr)",
    "description": "This creates a new database table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table identifier (tppmmm999) for the new table."
      },
      {
        "type": "long",
        "name": "compnr",
        "description": "This optional argument specifies a company number for the table. The default company is the company of the user."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.curr": {
    "name": "db.curr",
    "type": "function",
    "syntax": "function long db.curr (long table_id [, long lock])",
    "description": "This reads the current record from a specified table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.delete": {
    "name": "db.delete",
    "type": "function",
    "syntax": "function long db.delete (long table_id [, long mode] [, long eflag])",
    "description": "This deletes the current record. The record pointer is not changed, so the current record is undefined after the record has been deleted.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Set this to DB.RETRY if retry points and the SELECT FOR UPDATE statement are being used. The actual database action is postponed until the transaction is committed."
      },
      {
        "type": "[long",
        "name": "eflag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.drop.table": {
    "name": "db.drop.table",
    "type": "function",
    "syntax": "function long db.drop.table (long table_id [, long flag] [, long comp_nr])",
    "description": "This deletes a specified table. Data and indices associated with the table are also deleted. Reference counters are automatically updated.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "flag ]",
        "description": "If you set this optional argument to DB.IGNORE.ALL.REFS, the data is deleted regardless of whether it is referenced by other tables. WARNING: if you don't need this behaviour, please leave out the argument completetly. Never supply another value than DB.IGNORE.ALL.REFS to this argument."
      },
      {
        "type": "[long",
        "name": "comp_nr ]",
        "description": "This optional argument specifies a company number for the table. The default company is the company of the user."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.eq": {
    "name": "db.eq",
    "type": "function",
    "syntax": "function long db.eq (long table_id [, long lock])",
    "description": "This reads from a specified table the record whose key value equals a certain predefined value. Before calling db.eq() , you must assign the required value to the key field. For example, the following code retrieves the item with item number 001 from the items table:",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.error": {
    "name": "db.error",
    "type": "function",
    "syntax": "function long db.error ( [long table_id])",
    "description": "Use this to retrieve the error code returned by the most recent database action. If you specify a table ID, the function retrieves the most recent error code returned by an action on that table.",
    "arguments": [
      {
        "type": "[long",
        "name": "table_id ]",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.error.message": {
    "name": "db.error.message",
    "type": "function",
    "syntax": "function string db.error.message ()",
    "description": "Some errors returned by a database action have an associated error message. This message provides additional information about the error. Use the db.error.message() function to retrieve the error message (if any) associated with the most recent error code returned by a database action.",
    "arguments": [],
    "returnValue": "The error message associated with the most recent error that occurred. Or an empty string if no message is associated with the error.",
    "category": "functions_db_operations"
  },
  "db.first": {
    "name": "db.first",
    "type": "function",
    "syntax": "function long db.first (long table_id [, long lock])",
    "description": "This reads the first record from a specified table. It uses the current index to search the table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.flush": {
    "name": "db.flush",
    "type": "function",
    "syntax": "function long db.flush ()",
    "description": "All buffered actions are flushed to the database.",
    "arguments": [],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.ge": {
    "name": "db.ge",
    "type": "function",
    "syntax": "function long db.ge (long table_id [, long lock])",
    "description": "This reads from a specified table the record whose key value is greater than or equal to a certain predefined value. Before calling db.ge() , you must assign the required value to the key field. For example:",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.get.error.bypass": {
    "name": "db.get.error.bypass",
    "type": "function",
    "syntax": "function boolean db.get.error.bypass ( [ref boolean with.retry])",
    "description": "This function returns the current value of error.bypass and, optionally, the current value of error.bypass.with.retry. It is allowed to call this function without having called the db.set.error.bypass.on() function.",
    "arguments": [
      {
        "type": "[ref boolean",
        "name": "with.retry ]",
        "description": "The current value of error.bypass.with.retry."
      }
    ],
    "returnValue": "The current value of error.bypass.",
    "category": "functions_db_operations"
  },
  "db.get.physical.compnr": {
    "name": "db.get.physical.compnr",
    "type": "function",
    "syntax": "function long db.get.physical.compnr (string tblname, long logical.compnr)",
    "description": "Use this to retrieve the physical company number for the specified table ( tblname ) and logical company number ( logical.compnr ).",
    "arguments": [
      {
        "type": "string",
        "name": "tblname",
        "description": "The name of the table.db.bind"
      },
      {
        "type": "long",
        "name": "logical.compnr",
        "description": "The name of the logical company."
      }
    ],
    "returnValue": ">= 0 Success: the company number. -1 Error. The tblname or the logical.compnr is not correct. (e is set to E_BADARG)",
    "category": "functions_db_operations"
  },
  "db.gt": {
    "name": "db.gt",
    "type": "function",
    "syntax": "function long db.gt (long table_id, long lock)",
    "description": "This reads from a specified table the record whose key value is greater than a certain predefined value. Before calling db.gt() , you must assign the required value to the key field. For example:",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "long",
        "name": "lock",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.indexinfo": {
    "name": "db.indexinfo",
    "type": "function",
    "syntax": "function long db.indexinfo (long table_id, long index_nr, ref long index_info(32, 3), ref long indexparts, ref boolean indexdups, ref boolean indexactive)",
    "description": "This returns information about the parts of a specified index.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "long",
        "name": "index_nr",
        "description": "The index number."
      },
      {
        "type": "ref long",
        "name": "index_info(32, 3)",
        "description": "This returns the start position, length, and type of the index parts (up to a maximum of 32 parts): index_info(i,1) Start position in the logical record of part i of the index. index_info(i,2) Length of part i. index_info(i,3) Type of part i. The possible values are: DB.BYTE DB.TIME DB.INTEGER DB.TEXT DB.LONG DB.MAIL DB.FLOAT DB.ENUM DB.DOUBLE DB.BITSET DB.STRING DB.COMBINED DB.DATE DB.MULTIBYTE"
      },
      {
        "type": "ref long",
        "name": "indexparts",
        "description": "Returns the number of parts in the index."
      },
      {
        "type": "ref boolean",
        "name": "indexdups",
        "description": "Indicates whether or not duplicate values are permitted."
      },
      {
        "type": "ref boolean",
        "name": "indexactive",
        "description": "Indicates whether or not the index is active."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.insert": {
    "name": "db.insert",
    "type": "function",
    "syntax": "function long db.insert (long table_id [, long mode] [, long eflag])",
    "description": "This adds a new record to a specified table. The record pointer does not change.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Set this to DB.RETRY if retry points and the SELECT FOR UPDATE statement are being used. The actual database action is postponed until the transaction is committed."
      },
      {
        "type": "[long",
        "name": "eflag ]",
        "description": "For some errors, it is possible to indicate the action the system must perform when the error occurs. You use this argument to specify the required action(s). See Error handling ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.last": {
    "name": "db.last",
    "type": "function",
    "syntax": "function long db.last (long table_id [, long lock])",
    "description": "This reads the last record from a specified table. It uses the current index to search the table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.le": {
    "name": "db.le",
    "type": "function",
    "syntax": "function long db.le (long table_id [, long lock])",
    "description": "This reads from a specified table the record whose key value is less than or equal to a certain predefined value. Before calling db.le() , you must assign the required value to the key field. For example:",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.lock.table": {
    "name": "db.lock.table",
    "type": "function",
    "syntax": "function long db.lock.table (long table_id)",
    "description": "This locks a specified table. Other users cannot then write to or delete the table or any parts of the table. Nor can they lock the table or any parts of the table. The lock is released by commit.transaction() or abort.transaction()",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.lt": {
    "name": "db.lt",
    "type": "function",
    "syntax": "function long db.lt (long table_id [, long lock])",
    "description": "This reads from a specified table the record whose key value is less than a certain predefined value. Before calling db.lt() , you must assign the required value to the key field. For example:",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.max.retry": {
    "name": "db.max.retry",
    "type": "function",
    "syntax": "function long db.max.retry ()",
    "description": "This function returns the value of the MAX_RETRY resource setting, which indicates how often the system may return to a retry point as a result of an abort in an update action.",
    "arguments": [],
    "returnValue": "The value of the MAX_RETRY resource.",
    "category": "functions_db_operations"
  },
  "db.next": {
    "name": "db.next",
    "type": "function",
    "syntax": "function long db.next (long table_id [, long lock])",
    "description": "This reads the next record from a specified table. It uses the current index to search the table. If there is no current record, the function returns an error message.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.nr.indices": {
    "name": "db.nr.indices",
    "type": "function",
    "syntax": "function long db.nr.indices (long table_id, ref long nr_indices)",
    "description": "This returns the number of indices that exist on a specified table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "ref long",
        "name": "nr_indices",
        "description": "Returns the number of indices on the table."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.nr.rows": {
    "name": "db.nr.rows",
    "type": "function",
    "syntax": "function long db.nr.rows (long table_id, ref long nr_rows [, long comp_nr])",
    "description": "This returns the number of rows that a specified table contains.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "ref long",
        "name": "nr_rows",
        "description": "Returns the number of rows in the table."
      },
      {
        "type": "[long",
        "name": "comp_nr ]",
        "description": "This optional argument specifies a company number for the table. The default company is the company of the user."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.permission": {
    "name": "db.permission",
    "type": "function",
    "syntax": "function long db.permission (long table_id, string field [, ref string buffer])",
    "description": "Use this to check the access permissions that a user has to a specified table or table field.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "string",
        "name": "field",
        "description": "To check the permissions for a particular field, enter the field name here. If you do not specify a field here, or if you specify an empty string, the function returns the permissions for the table."
      },
      {
        "type": "[ref string",
        "name": "buffer ]",
        "description": "A user's permissions for a table or table field can depend on the contents of a record. In this case, you must specify the record buffer of the table in the buffer argument. The function returns the user's permissions for the record in the record buffer. If a user's permissions depend on the contents of a record, and you do not specify the buffer argument, the function returns PERM.UNKNOWN."
      }
    ],
    "returnValue": "The function returns a long that indicates the permissions that the user has on the table or on a specified field of that table. The return value consists of one of, or a combination of, the following codes: NO.PERMISSION 1 PERM.READ 2 PERM.MODIFY 4 PERM.WRITE 8 PERM.DELETE 16 NO.RESTRICTION (PERM.READ+PERM.MODIFY+PERM.WRITE+PERM.DELETE) PERM.UNKNOWN 32 So, if the value 6 is returned, the user is permitted to both read and modify the specified table or table field.",
    "category": "functions_db_operations"
  },
  "db.prev": {
    "name": "db.prev",
    "type": "function",
    "syntax": "function long db.prev (long table_id [, long lock])",
    "description": "This reads the previous record from a specified table. It uses the current index to search the table. If there is no current record, the function returns an error message.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "lock ]",
        "description": "By default, the record is not locked before reading. Use this optional argument to apply a lock to the record. The possible values are: DB.LOCK lock record for update DB.DELAYED.LOCK apply a delayed lock to the record; the lock is applied immediately before the update action"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.record.changed": {
    "name": "db.record.changed",
    "type": "function",
    "syntax": "function boolean db.record.changed (long table_id [, long size])",
    "description": "Tests whether the current value of the record buffer belonging to the given table id has changed since the last call of db.store.record() .",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID in the format tppmmmxxx . E.g. twhinh200"
      },
      {
        "type": "[long",
        "name": "size ]",
        "description": "The size of the part that is stored"
      }
    ],
    "returnValue": "true Record was changed since the last call to db.store.record() false Record was not changed",
    "category": "functions_db_operations"
  },
  "db.record.to.columns": {
    "name": "db.record.to.columns",
    "type": "function",
    "syntax": "function long db.record.to.columns (long table_id)",
    "description": "When you bind to a table (see db.bind() and specify that the default record buffer is to be used, the contents of the buffer are automatically copied to the table fields in your program script. This does not happen when you specify a record buffer other than the default buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.ref.handle.mode": {
    "name": "db.ref.handle.mode",
    "type": "function",
    "syntax": "function long db.ref.handle.mode (string table_name, long mode)",
    "description": "Use this to check whether a full table scan (FTS) is necessary during delete or update operations. Delete and update operations can take a long time to complete when the table is referenced by other tables but no reference counter is kept (cascade, nullify, or lookup mode). When there is no index on the foreign key in the child table, normally a full table scan is required to search for referring records.",
    "arguments": [
      {
        "type": "string",
        "name": "table_name",
        "description": "The table name, without the leading 't' character."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "Possible modes: DB.REF.UPDATE DB.REF.DELETE"
      }
    ],
    "returnValue": "0 Full table scan is not necessary. 1 Full table scan is necessary.",
    "category": "functions_db_operations"
  },
  "db.restore.record": {
    "name": "db.restore.record",
    "type": "function",
    "syntax": "function void db.restore.record (long table_id)",
    "description": "This restores the record of the given table that was stored previously with db.store.record() . Also the table's field values will be restored.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID in the format tppmmmxxx . E.g. twhinh200"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.retry.hit": {
    "name": "db.retry.hit",
    "type": "function",
    "syntax": "function long db.retry.hit ()",
    "description": "Use this to check whether the client database layer has returned to a retry point. You must set the retry point by using db.retry.point() before you call db.retry.hit(). See also Database handling overview .",
    "arguments": [],
    "returnValue": "0 Retry point defined but not returned to. >0 System returned to retry point. -1 No Retry point defined -2 Stack Error (Programming error in script. A db.retry.point() was done at a deeper stack level)",
    "category": "functions_db_operations"
  },
  "db.retry.point": {
    "name": "db.retry.point",
    "type": "function",
    "syntax": "function void db.retry.point ()",
    "description": "This sets a retry point for the current transaction. The program returns to this point if an error occurs during the transaction; the transaction is then retried. When you include a retry point for a transaction, you must set it before the start of the transaction.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.row.length": {
    "name": "db.row.length",
    "type": "function",
    "syntax": "function long db.row.length (long table_id, ref long row_length)",
    "description": "Use this to retrieve the length of records in a specified table.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "ref long",
        "name": "row_length",
        "description": "This returns the length of the internal buffer that is needed for a row in the table and its internal data like '_compnr' and '_dlock'. (see also the int_length of rdi.table())"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.set.error.bypass.off": {
    "name": "db.set.error.bypass.off",
    "type": "function",
    "syntax": "function void db.set.error.bypass.off ()",
    "description": "This function resets the values of error.bypass and error.bypass.with.retry to the previous values. The function must be called exactly once for each time the function db.set.error.bypass.on() is called. Calling this function more often than calling db.set.error.bypass.on() is a programming error and results in a fatal error.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.set.error.bypass.on": {
    "name": "db.set.error.bypass.on",
    "type": "function",
    "syntax": "function long db.set.error.bypass.on ( [boolean with.retry])",
    "description": "This function flushes all buffered database actions in the current transaction before setting the error.bypass and error.bypass.with.retry flags. If any of the database actions results in a retryable error a jump is made to the db.retry.point(). If any of the actions results in a fatal error, then the process is terminated. If any error occurs then the values of error.bypass and error.bypass.with.retry are not modified. After successful flush, sets the value of error.bypass to true. The value of error.bypass.with.retry is set to the value specified by the with.retry argument, or to false if the argument is not given.",
    "arguments": [
      {
        "type": "[boolean",
        "name": "with.retry ]",
        "description": "The value used to set the error.bypass.with.retry flag."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.set.to.default": {
    "name": "db.set.to.default",
    "type": "function",
    "syntax": "function long db.set.to.default (long table_id)",
    "description": "This sets bound variables in the program script to the default values defined in the data dictionary.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.store.record": {
    "name": "db.store.record",
    "type": "function",
    "syntax": "function void db.store.record (long table_id [, long size])",
    "description": "Creates a copy of the current value of the record buffer belonging to the given table id. Later on this copied value can be restored by calling db.restore.record() .",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID in the format tppmmmxxx . E.g. twhinh200"
      },
      {
        "type": "[long",
        "name": "size ]",
        "description": "The size of the part that is stored"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "db.unbind": {
    "name": "db.unbind",
    "type": "function",
    "syntax": "function long db.unbind (long table_id)",
    "description": "This deletes the specified table pointer.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "db.update": {
    "name": "db.update",
    "type": "function",
    "syntax": "function long db.update (long table_id [, long mode] [, long eflag])",
    "description": "This rewrites the current record. When updating a record with this function, you are permitted to update the primary key of the record.",
    "arguments": [
      {
        "type": "long",
        "name": "table_id",
        "description": "The table ID, as returned by db.bind() ."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This has two possible values: DB.RETRY"
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_db_operations"
  },
  "for.each.record.in.view.do": {
    "name": "for.each.record.in.view.do",
    "type": "function",
    "syntax": "function void for.each.record.in.view.do (string callback_function)",
    "description": "Executes the specified UI script callback function for each record in the current view on the maintable.",
    "arguments": [
      {
        "type": "string",
        "name": "callback_function",
        "description": "The name of the function that must be executed. The function must be of type 'extern long'."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "on.main.table": {
    "name": "on.main.table",
    "type": "function",
    "syntax": "function void on.main.table (string function_name [, string ...])",
    "description": "This copies the contents current record of the main table to the record buffer of that table, saves the record, and executes the specified function. After that the saved record buffer is restored. This enables you to perform actions on the record contents without affecting the values in the table.",
    "arguments": [
      {
        "type": "string",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "[string",
        "name": "... ]",
        "description": "Use these optional arguments to pass one or more arguments to the function."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "database operations overview": {
    "name": "Database operations overview",
    "type": "function",
    "syntax": "function Database operations overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "restore.rcd.main": {
    "name": "restore.rcd.main",
    "type": "function",
    "syntax": "function void restore.rcd.main (long occurrence)",
    "description": "This updates the main table with the contents of the buffer of the specified occurrence. It also makes the specified occurrence the current occurrence.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence number."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "set.limits.off": {
    "name": "set.limits.off",
    "type": "function",
    "syntax": "function void set.limits.off ()",
    "description": "This removes the limits set with the store.occ.max(), store.occ.min() and/or store.occ.max(), store.occ.min() functions. The entire table can then be accessed again.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "set.transaction.readonly": {
    "name": "set.transaction.readonly",
    "type": "function",
    "syntax": "function long set.transaction.readonly ()",
    "description": "This defines a transaction as read only. The transaction can only read records (without locks) from the database; it cannot update the database.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "skip.io": {
    "name": "skip.io",
    "type": "function",
    "syntax": "function void skip.io (string mesg [, string ...])",
    "description": "This function is deprecated!",
    "arguments": [
      {
        "type": "string",
        "name": "mesg",
        "description": "This specifies a message that is defined in the data dictionary. This message is displayed on screen when you call skip.io() . If you specify an empty string, the 4GL engine displays a default message."
      },
      {
        "type": "[string",
        "name": "... ]",
        "description": "The message can contain substitution symbols such as %d or face= %s (see sprintf$() . The values that must be substituted are specified in the second, third, etc. arguments of the function. The number of arguments is variable."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "store.occ.max, store.occ.min": {
    "name": "store.occ.max, store.occ.min",
    "type": "function",
    "syntax": "function void store.occ.max ()",
    "description": "Normally, standard commands that access records of the main table can access all records of that table. You can use these functions to limit the records that can be accessed to those whose key values are within a specified range. Use store.occ.max() to define the upper limit of the range. Use store.occ.min() to define the lower limit of the range. If you wish, you can define only a maximum or only a minimum limit.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "storing, restoring record buffers - examples": {
    "name": "Storing, restoring record buffers - Examples",
    "type": "function",
    "syntax": "function Storing, restoring record buffers - Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "sum.records.in.view": {
    "name": "sum.records.in.view",
    "type": "function",
    "syntax": "function void sum.records.in.view (const string column1.var, double result1.var [, const string, double ..., ...])",
    "description": "This function performs a query on the maintable of the session, including all reference tables, and will sum the values of each specified column. The query will take the current view fields, active user filter and any query extensions into account. Preconditions - an even number of parameters must be passed - any specified column must exist in the datadictionary if one of these conditions is not met, an assert is given Parameters column the name of column to sum result the result of the sum operation for 'column' ... more pairs of 'column' and 'result'",
    "arguments": [
      {
        "type": "const string",
        "name": "column1.var",
        "description": "field or expression to sum specify the field/expression to sum. fieldname or fieldname in expression must exist in the maintable or in the referenced tables. column1.var must be a decimal field."
      },
      {
        "type": "double",
        "name": "result1.var",
        "description": "result of sum fieldname1 specify the output field to receive the sum."
      },
      {
        "type": "[const string, double",
        "name": "..., ... ]",
        "description": "next pair of [column.var, result.var]. Use these optional pair of arguments to sum other columns. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "database operations synopsis": {
    "name": "Database operations synopsis",
    "type": "function",
    "syntax": "function Database operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "this.dal": {
    "name": "this.dal",
    "type": "function",
    "syntax": "function string this.dal ()",
    "description": "Returns the name of the current DAL.",
    "arguments": [],
    "returnValue": "the name of the current DAL",
    "category": "functions_db_operations"
  },
  "to.key": {
    "name": "to.key",
    "type": "function",
    "syntax": "function void to.key (long key_number [, long nr.view.fields])",
    "description": "Use this to change the key of the main table without user interaction. The key_number argument specifies the new key.",
    "arguments": [
      {
        "type": "long",
        "name": "key_number",
        "description": "Sequence number of the key to be used"
      },
      {
        "type": "[long",
        "name": "nr.view.fields ]",
        "description": "specifies the specified number of viewfields the session will start with"
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "with.object.set.do": {
    "name": "with.object.set.do",
    "type": "function",
    "syntax": "function void with.object.set.do (string function_name [, <type> ...])",
    "description": "With this function you can perform actions on records in the DAL's table, without affecting the current record. First the current record is saved into a temporary record buffer, then the specified function is executed. Afterwards the current record is restored from the temporary buffer.",
    "arguments": [
      {
        "type": "string",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "[<type>",
        "name": "... ]",
        "description": "Use these optional arguments to pass one or more arguments to the function."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "with.old.object.values.do": {
    "name": "with.old.object.values.do",
    "type": "function",
    "syntax": "function void with.old.object.values.do (string function_name [, <type> ...])",
    "description": "This executes the specified function for the current record, using the old values of the record. The record must have been previously modified.",
    "arguments": [
      {
        "type": "string",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "[<type>",
        "name": "... ]",
        "description": "Use these optional arguments to pass one or more arguments to the specified function."
      }
    ],
    "returnValue": "",
    "category": "functions_db_operations"
  },
  "digest.finalize)": {
    "name": "digest.finalize)",
    "type": "function",
    "syntax": "function long digest.finalize (long handle, ref string result)",
    "description": "After the last data has been fed into the hash-algorithm using digest.update() , the digest.finalize function can be used to retrieve the resulting hash value.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "A valid handle obtained by a previous call to digest.initialize() ."
      },
      {
        "type": "ref string",
        "name": "result",
        "description": "The calculated digest. The format is in \"raw hex\", a string of upper-case hexadecimal digits. The length depends on the algorithm chosen with digest.initialize() ."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, a result string that is too small to hold the result or an invalid handle .",
    "category": "functions_digest"
  },
  "digest.initialize": {
    "name": "digest.initialize",
    "type": "function",
    "syntax": "function long digest.initialize (long digest.type)",
    "description": "Initializes the state of the Secure Hash Algorithm and selects the apropriate Secure Hash algorithm.",
    "arguments": [
      {
        "type": "long",
        "name": "digest.type",
        "description": "The name of the secure hash algorithm. This must be one of: DIGEST_MD5 DIGEST_SHA (invalid) DIGEST_SHA1 DIGEST_SHA224 DIGEST_SHA256 DIGEST_SHA512 DIGEST_MDC2"
      }
    ],
    "returnValue": "A handle for this digest operation that must be used in subsequent calls to digest.update() and digest.finalize()) . The value -1 is returned upon error. Details of the error are logged by the bshell. The returned Id can only be used in the original process where digest.initialize was called, and is useless in other processes in the same bshell. The allocated memory is freed explicitly by passing the Id to digest.finalize(). The allocated memory is freed implicitly when the process exits. Any number of Secure Digest Algorithm states may be in use concurrently.",
    "category": "functions_digest"
  },
  "digest.update": {
    "name": "digest.update",
    "type": "function",
    "syntax": "function long digest.update (long handle, string data, long data.size)",
    "description": "Feeds data to the hash algorithm. This function can be called as many times as required to process the entire message. The third parameter can be used to explicitly specify the length of a binary string (when omitted, the logical length of the string argument is used).",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "A valid handle obtained by a previous call to digest.initialize() ."
      },
      {
        "type": "string",
        "name": "data",
        "description": "The data to compute the digest of. Can be any length."
      },
      {
        "type": "long",
        "name": "data.size",
        "description": "Optional. The number of bytes to read from the data argument. When omitted, the length() function is used to obtain the number of bytes in string ."
      }
    ],
    "returnValue": "0 Success. -1 Error. The specifics of the error are logged by the Bshell. The problem can be caused by the underlying OpenSSL function, an invalid buffer length (bigger than the actual length of string) or an invalid handle.",
    "category": "functions_digest"
  },
  "secure digest functions overview": {
    "name": "Secure Digest Functions overview",
    "type": "function",
    "syntax": "function Secure Digest Functions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_digest"
  },
  "secure digest functions synopsis": {
    "name": "Secure Digest Functions synopsis",
    "type": "function",
    "syntax": "function Secure Digest Functions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_digest"
  },
  "creat.tmp.file$": {
    "name": "creat.tmp.file$",
    "type": "function",
    "syntax": "function string creat.tmp.file$ ( [string pathname])",
    "description": "This creates a temporary file. By default, the file is created in the current directory. To create the file in a different directory, use the optional pathname argument to specify the full path to the required directory.",
    "arguments": [
      {
        "type": "[string",
        "name": "pathname ]",
        "description": ""
      }
    ],
    "returnValue": "The name of the temporary file.",
    "category": "functions_directory_file_operations"
  },
  "dir.close": {
    "name": "dir.close",
    "type": "function",
    "syntax": "function long dir.close (long dfd)",
    "description": "This closes a specified directory and frees all memory allocated to it. The dfd argument is the pointer to the directory returned by dir.open() or dir.open.tree() when the directory was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "dfd",
        "description": "The pointer to the required directory, as returned when the directory was opened by dir.open() or dir.open.tree() ."
      }
    ],
    "returnValue": ">=0 Success. -1 Error; The system dependent error value is put in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "dir.entry": {
    "name": "dir.entry",
    "type": "function",
    "syntax": "function string dir.entry (long dfd, long read_type [, ref long return_type] [, ref long filesize] [, ref long mode])",
    "description": "This retrieves entries from a previously opened directory. It retrieves the entries sequentially.",
    "arguments": [
      {
        "type": "long",
        "name": "dfd",
        "description": "The pointer to the required directory, as returned when the directory was opened by dir.open() or dir.open.tree() ."
      },
      {
        "type": "long",
        "name": "read_type",
        "description": "Specifies the type of entry to be retrieved. Allowed values are listed below. These values can be combined with bit.or() . TDIR"
      }
    ],
    "returnValue": "The directory entry. Or an empty string if the end of the entry list has been reached.",
    "category": "functions_directory_file_operations"
  },
  "dir.open": {
    "name": "dir.open",
    "type": "function",
    "syntax": "function long dir.open (const string path [, long read_type])",
    "description": "This reads the specified directory into memory. The path argument can have a maximum length of 512 characters.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "The path to the required directory. This can have a maximum length of 512 characters (it might be further restricted by OS/file system limitations)."
      },
      {
        "type": "[long",
        "name": "read_type ]",
        "description": "Use this argument to filter on types. Added as of TIV 2150 . If this argument is not provided, then TDIR + TFILE value is used as default. Allowed values, that can be combined with bit.or, are: TDIR"
      }
    ],
    "returnValue": "> 0 Success; A pointer to the directory data. <= 0 Error; The negative error value may be system dependent.",
    "category": "functions_directory_file_operations"
  },
  "dir.open.tree": {
    "name": "dir.open.tree",
    "type": "function",
    "syntax": "function long dir.open.tree (const string path [, long nlevels] [, long read_type])",
    "description": "This is similar to dir.open() in that it reads a specified directory into memory. However, dir.open.tree() can retrieve up to 256 directory levels.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "The path to the required directory. This can have a maximum length of 512 characters (it might be further restricted by OS/file system limitations)."
      },
      {
        "type": "[long",
        "name": "nlevels ]",
        "description": "Use this optional argument to indicate the number of directory levels that must be read. The default is one."
      },
      {
        "type": "[long",
        "name": "read_type ]",
        "description": "Use this argument to filter on types. Added as of TIV 2150 . If this argument is not provided, then TDIR + TFILE value is used as default. Allowed values, that can be combined with bit.or, are: TDIR"
      }
    ],
    "returnValue": "> 0 Success; A pointer to the directory data. <= 0 Error; The negative error value may be system dependent.",
    "category": "functions_directory_file_operations"
  },
  "dir.rewind": {
    "name": "dir.rewind",
    "type": "function",
    "syntax": "function long dir.rewind (long dfd)",
    "description": "This resets the read pointer of the specified directory to the beginning of the directory entry list. The dfd argument is the pointer to the directory returned by dir.open() or dir.open.tree() when the directory was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "dfd",
        "description": "Pointer to the directory returned by dir.open() or dir.open.tree() when the directory was opened."
      }
    ],
    "returnValue": ">0 Success; A pointer to the directory data. -1 Error. Bad directory descriptor.",
    "category": "functions_directory_file_operations"
  },
  "file.chown": {
    "name": "file.chown",
    "type": "function",
    "syntax": "function long file.chown (string file, string user, string group)",
    "description": "This changes the owner and/or group of a file. You can use a single call to change both the owner and the group. Alternatively, you can specify either the user argument or the group argument as an empty string.",
    "arguments": [
      {
        "type": "string",
        "name": "file",
        "description": "The name of the file."
      },
      {
        "type": "string",
        "name": "user",
        "description": "The new owner of the file."
      },
      {
        "type": "string",
        "name": "group",
        "description": "The new group of the file."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. See error codes . Internal note: For robust 3GL code, and to prevent mistakes when mixing different file-related functions, the return value should be interpreted as described above. The current implementation returns 0 on success and -1 on failure.",
    "category": "functions_directory_file_operations"
  },
  "file.cp": {
    "name": "file.cp",
    "type": "function",
    "syntax": "function long file.cp (const string source, const string target)",
    "description": "This copies a specified source file to a specified target file. Both files can be either local or remote. They can also be on different hosts (provided that the bshell can access both hosts).",
    "arguments": [
      {
        "type": "const string",
        "name": "source",
        "description": "Source file."
      },
      {
        "type": "const string",
        "name": "target",
        "description": "Target file."
      }
    ],
    "returnValue": ">=0 Success. (If source and target are the same local file, then e is set to 1, otherwise to 0.) <0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "file.mv.across.hosts": {
    "name": "file.mv.across.hosts",
    "type": "function",
    "syntax": "function long file.mv.across.hosts (const string source, const string target)",
    "description": "This moves a specified source file to the location specified in the target argument. The file can be either local or remote. Source and target can be on different hosts.",
    "arguments": [
      {
        "type": "const string",
        "name": "source",
        "description": "Source file."
      },
      {
        "type": "const string",
        "name": "target",
        "description": "Target file."
      }
    ],
    "returnValue": "1 Success. <0 Error.",
    "category": "functions_directory_file_operations"
  },
  "file.mv": {
    "name": "file.mv",
    "type": "function",
    "syntax": "function long file.mv (const string source, const string target)",
    "description": "This moves a specified source file to the location specified in the target argument. The file can be either local or remote. Both source and target must be on the same host.",
    "arguments": [
      {
        "type": "const string",
        "name": "source",
        "description": "Source file."
      },
      {
        "type": "const string",
        "name": "target",
        "description": "Target file."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "file.rm": {
    "name": "file.rm",
    "type": "function",
    "syntax": "function long file.rm (const string path)",
    "description": "This deletes a specified local or remote file. The path argument must include the full path to the file, including the host name, where appropriate. For example: \"host!/usr/myfile\".",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "Remote or local file."
      }
    ],
    "returnValue": ">=0 Success. <0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "file.stat": {
    "name": "file.stat",
    "type": "function",
    "syntax": "function long file.stat (string file_name, ref long file_size [, ref long ctime] [, ref long mtime] [, ref long atime])",
    "description": "This returns information about a specified file. It is a short version of the stat.info() function.",
    "arguments": [
      {
        "type": "string",
        "name": "file_name",
        "description": "The name of the file for which information is required."
      },
      {
        "type": "ref long",
        "name": "file_size",
        "description": "The file size in bytes."
      },
      {
        "type": "[ref long",
        "name": "ctime ]",
        "description": "The time when the file status was last changed, as a number of seconds since 00:00:00 GMT, January 1, 1970."
      },
      {
        "type": "[ref long",
        "name": "mtime ]",
        "description": "The time when the file was last modified, as a number of seconds since 00:00:00 GMT, January 1, 1970."
      },
      {
        "type": "[ref long",
        "name": "atime ]",
        "description": "The time when the file data was last accessed, as a number of seconds since 00:00:00 GMT, January 1, 1970."
      }
    ],
    "returnValue": "0 File exists. <>0 Operating system error code.",
    "category": "functions_directory_file_operations"
  },
  "filemanager.selectfile": {
    "name": "FileManager.selectFile",
    "type": "function",
    "syntax": "function long FileManager.selectFile (string i.path, string i.mime.filter, ref string o.file)",
    "description": "This shows the File Manager workbench running in file selection mode to allow a user to select a file on the server.",
    "arguments": [
      {
        "type": "string",
        "name": "i.path",
        "description": "The startup directory for the File Manager workbench. If i.path specifies a file instead of a directory, the directory part of i.path is used as startup directory. Note that this directory becomes the root directory of the File Manager workbench which means that the user can navigate to child directories but not to the parent directory. In case of an empty string the startup directory will be the directory where the Baan Software Environment is installed (see bse.dir$ )."
      },
      {
        "type": "string",
        "name": "i.mime.filter",
        "description": "The list of mime types, separated by commas, of the files shown by the File Manager. If the list is an empty string all files are shown."
      },
      {
        "type": "ref string",
        "name": "o.file",
        "description": "Output argument which will contain the full path of the file selected by the user."
      }
    ],
    "returnValue": "1 The user has selected a file. 0 The user has cancelled. -1 Error occurred",
    "category": "functions_directory_file_operations"
  },
  "filemanager.selectfolder": {
    "name": "FileManager.selectFolder",
    "type": "function",
    "syntax": "function long FileManager.selectFolder (string i.path, ref string o.folder)",
    "description": "This shows the File Manager workbench running in folder selection mode to allow a user to select one folder on the server.",
    "arguments": [
      {
        "type": "string",
        "name": "i.path",
        "description": "The startup directory for the File Manager workbench. Note that this directory becomes the root directory of the File Manager workbench which means that the user can navigate to child directories but not to the parent directory. In case of an empty string the startup directory will be the directory where the Baan Software Environment is installed (see bse.dir$ )."
      },
      {
        "type": "ref string",
        "name": "o.folder",
        "description": "Output argument which will contain the full path of the folder selected by the user."
      }
    ],
    "returnValue": "1 The user has selected a folder. 0 The user has cancelled. -1 Error occurred",
    "category": "functions_directory_file_operations"
  },
  "file.chmod": {
    "name": "file.chmod",
    "type": "function",
    "syntax": "function long file.chmod (const string file, long mode)",
    "description": "This sets the access permissions for a specified file.",
    "arguments": [
      {
        "type": "const string",
        "name": "file",
        "description": "The name of the file."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "The type of access permissions that must be set. This can be a combination of the following values: User/owner S_IRWXU"
      }
    ],
    "returnValue": ">= 0 Success. < 0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "fstat.info": {
    "name": "fstat.info",
    "type": "function",
    "syntax": "function long fstat.info (long fp, ref long size, ref long mode, ref long inode, ref long dev, ref long uid, ref long gid, ref long nlink, ref long ctime, ref long mtime, ref long atime)",
    "description": "This returns information about a specified file. It provides the same information as stat.info() . But instead of retrieving information about a named file, it returns information about an open file that is known by the file descriptor fp . This descriptor can be obtained, for example, from a successful seq.open() call.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "The file descriptor, as returned, for example, by seq.open() ."
      },
      {
        "type": "ref long",
        "name": "size",
        "description": "The file size in bytes."
      },
      {
        "type": "ref long",
        "name": "mode",
        "description": "This contains a bit pattern that indicates the access permission (posix) of the file. Use the following defines to check the file mode: S_IRWXU"
      }
    ],
    "returnValue": "1 Success. <>0 Operating system error code.",
    "category": "functions_directory_file_operations"
  },
  "getcwd": {
    "name": "getcwd",
    "type": "function",
    "syntax": "function string getcwd ()",
    "description": "This returns the current path as a string. Note that on Windows NT systems, pathnames can include drive letters (for example, c:/baan/bin ).",
    "arguments": [],
    "returnValue": "The current path as a string. Or an empty string if an error occurs.",
    "category": "functions_directory_file_operations"
  },
  "make.path.absolute": {
    "name": "make.path.absolute",
    "type": "function",
    "syntax": "function long make.path.absolute (ref string path_name)",
    "description": "Makes path absolute given in path_name . It gives the full path back also in path_name .",
    "arguments": [
      {
        "type": "ref string",
        "name": "path_name",
        "description": "path"
      }
    ],
    "returnValue": "0 Success. other value Errror.",
    "category": "functions_directory_file_operations"
  },
  "mkdir": {
    "name": "mkdir",
    "type": "function",
    "syntax": "function long mkdir (string path_name$ [, long access_level])",
    "description": "This creates the specified directory. You must have write permission in the parent directory to do this. Access permissions for the new directory are set to read, write, and execute for all users.",
    "arguments": [
      {
        "type": "string",
        "name": "path_name$",
        "description": ""
      },
      {
        "type": "[long",
        "name": "access_level ]",
        "description": "Optional, determines how to interpret the path if the current BSE is a tenant BSE and path_name$ is relative: PATH_USER_LEVEL"
      }
    ],
    "returnValue": ">=0 Success. (If the return value is 0 then you can be sure that the directory existed already.) <0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "directory and file operations overview": {
    "name": "Directory and file operations overview",
    "type": "function",
    "syntax": "function Directory and file operations overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_directory_file_operations"
  },
  "path.change.extension": {
    "name": "path.change.extension",
    "type": "function",
    "syntax": "function string path.change.extension (const string path, const string extension [, long os.type])",
    "description": "Changes the extension of the specified path string. By default the path string is interpreted according to the Operating System of the ERP Enterprise server.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path string to modify"
      },
      {
        "type": "const string",
        "name": "extension",
        "description": "the new extension (with or without a leading period). Specify an empty string to remove the existing extension from the path"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path string is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "The modified path information. If path is an empty string (\"\"), the extension (with a leading period) is returned. If extension is an empty string, the returned string contains the specified path with its extension removed. If path has no extension, and extension is not empty, the returned path string contains extension appended to the end of path.",
    "category": "functions_directory_file_operations"
  },
  "path.combine": {
    "name": "path.combine",
    "type": "function",
    "syntax": "function string path.combine (const string path, ..., long os.type)",
    "description": "Combines one ore more strings into a path.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "a path part"
      },
      {
        "type": "",
        "name": "...",
        "description": "optional path parts"
      },
      {
        "type": "long",
        "name": "os.type",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX . Note: this must be the last argument."
      }
    ],
    "returnValue": "The combined paths.",
    "category": "functions_directory_file_operations"
  },
  "path.dir.separator": {
    "name": "path.dir.separator",
    "type": "function",
    "syntax": "function string path.dir.separator ( [long os.type])",
    "description": "Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.",
    "arguments": [
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the directory separator returned is the one for the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "The value is a slash (\"/\") for UNIX, and a backslash (\"\\\") for the Windows operating systems.",
    "category": "functions_directory_file_operations"
  },
  "path.directory": {
    "name": "path.directory",
    "type": "function",
    "syntax": "function string path.directory (const string path [, long os.type])",
    "description": "Returns the directory information for the specified path string.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path of a file or a directory"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "Directory information for path, or an empty string if path denotes a root directory or is empty, or if path does not contain directory information. In most cases, the string returned by this function consists of all characters in the path up to but not including the last path.dir.separator() . If the path consists of a root directory, such as \"c:\\\", an empty string is returned. Note that this method does not support paths using \"file:\". Because the returned path does not include the path.dir.separator() , passing the returned path back into the path.directory() method will result in the truncation of one folder level per subsequent call on the result string. For example, passing the path \"C:\\Directory\\SubDirectory\\test.txt\" into the path.directory() method will return \"C:\\Directory\\SubDirectory\". Passing that string, \"C:\\Directory\\SubDirectory\", into path.directory() will result in \"C:\\Directory\".",
    "category": "functions_directory_file_operations"
  },
  "path.exists": {
    "name": "path.exists",
    "type": "function",
    "syntax": "function boolean path.exists (const string path [, long access_level])",
    "description": "This function returns true if the given path exists, and false otherwise. If the current BSE is a tenant BSE, path is always interpreted as a relative path.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "The file or directory to check."
      },
      {
        "type": "[long",
        "name": "access_level ]",
        "description": "Optional, determines how to interpret the path if the current BSE is a tenant BSE: PATH_USER_LEVEL"
      }
    ],
    "returnValue": "True if the file or directory exists, false otherwise",
    "category": "functions_directory_file_operations"
  },
  "path.extension": {
    "name": "path.extension",
    "type": "function",
    "syntax": "function string path.extension (const string path [, long os.type])",
    "description": "Returns the extension of the specified path string.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path string from which to get the extension"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "The extension of the specified path (including the period \".\"), or an empty string. If path is an empty string, or if path does not have extension information, this function returns an empty string. The extension of path is obtained by searching path for a period (.), starting with the last character in path and continuing toward the start of path. If a period is found before a path.dir.separator() character, the returned string contains the period and the characters after it; otherwise, an empty string is returned.",
    "category": "functions_directory_file_operations"
  },
  "path.filename": {
    "name": "path.filename",
    "type": "function",
    "syntax": "function string path.filename (const string path [, long os.type])",
    "description": "Returns the filename and extension of the specified path string.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path string from which to obtain the filename and the extension"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "The characters after the last directory character in path. If the last character of path is a directory or volume separator character, this method returns an empty string. If path is an empty string, this function returns an empty string as well. The separator character used to determine the start of the file name is path.dir.separator() .",
    "category": "functions_directory_file_operations"
  },
  "path.filename.without.extension": {
    "name": "path.filename.without.extension",
    "type": "function",
    "syntax": "function string path.filename.without.extension (const string path [, long os.type])",
    "description": "Returns the filename of the specified path string without the extension.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path string of the file"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "The string returned by path.filename() , minus the last period (.) and all characters following it. This method does not verify that the path or file name exists.",
    "category": "functions_directory_file_operations"
  },
  "path.has.extension": {
    "name": "path.has.extension",
    "type": "function",
    "syntax": "function boolean path.has.extension (const string path [, long os.type])",
    "description": "Determines whether a path string includes a file name extension.",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "the path string to search for an extension"
      },
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the path is interpreted according to the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "true if the characters that follow the last directory separator (\\ or /) in the path include a period (.) followed by one or more characters; otherwise, false. Starting from the end of path, this method searches for a period (.) followed by at least one character. If this pattern is found before a path.dir.separator() character is encountered, this method returns true.",
    "category": "functions_directory_file_operations"
  },
  "path.is.absolute": {
    "name": "path.is.absolute",
    "type": "function",
    "syntax": "function boolean path.is.absolute (string path_name)",
    "description": "This checks if path_name is an absolute path.",
    "arguments": [
      {
        "type": "string",
        "name": "path_name",
        "description": "Path name."
      }
    ],
    "returnValue": "false path_name is not absolute. true path_name is absolute.",
    "category": "functions_directory_file_operations"
  },
  "path.separator": {
    "name": "path.separator",
    "type": "function",
    "syntax": "function string path.separator ( [long os.type])",
    "description": "Returns a platform-specific separator character (\":\" or \";\") used to separate path strings in environment variables.",
    "arguments": [
      {
        "type": "[long",
        "name": "os.type ]",
        "description": "when specified, the separator returned is the one for the given OS type; specify one of the following values: OS_WINDOWS_NT , OS_UNIX"
      }
    ],
    "returnValue": "On Windows-based platforms, the value returned is the semicolon (;). On Unix platforms the value returned is the colon (:).",
    "category": "functions_directory_file_operations"
  },
  "pathname": {
    "name": "pathname",
    "type": "function",
    "syntax": "function long pathname (string file_basename, string file_type, ref string file_path [, long log.options])",
    "description": "This searches for and returns the location of a specified file.",
    "arguments": [
      {
        "type": "d",
        "name": "data/domain definition",
        "description": "\"D\""
      },
      {
        "type": "r",
        "name": "report",
        "description": "\"O\""
      },
      {
        "type": "o",
        "name": "object",
        "description": "\"O\""
      },
      {
        "type": "f",
        "name": "form",
        "description": "\"S\""
      },
      {
        "type": "m",
        "name": "menu",
        "description": "\"M\""
      },
      {
        "type": "p",
        "name": "program script",
        "description": "\"P\""
      },
      {
        "type": "i",
        "name": "include file",
        "description": "\"P\""
      },
      {
        "type": "b",
        "name": "additional files",
        "description": "\"B\""
      }
    ],
    "returnValue": "0 Success. ENOENT File not found.",
    "category": "functions_directory_file_operations"
  },
  "rmdir": {
    "name": "rmdir",
    "type": "function",
    "syntax": "function long rmdir (const string spath [, boolean recursive])",
    "description": "This deletes the specified directory (local or remote). The path argument must include the full path to the directory, including the host name, where appropriate. For example: \"host!c:\\usr\".",
    "arguments": [
      {
        "type": "const string",
        "name": "spath",
        "description": "Path."
      },
      {
        "type": "[boolean",
        "name": "recursive ]",
        "description": "specify true if any subdirectories and files in the directory have | to be deleted as well"
      }
    ],
    "returnValue": ">=0 Success. <0 Error. The error code is stored in the e variable.",
    "category": "functions_directory_file_operations"
  },
  "seq.clearerr": {
    "name": "seq.clearerr",
    "type": "function",
    "syntax": "function long seq.clearerr (long fp)",
    "description": "This resets the error and end-of-file indicators for the specified file. fp is the file pointer returned by seq.open() when the file was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "0 Success. -1 Errror. Probably fp not connected",
    "category": "functions_directory_file_operations"
  },
  "seq.close": {
    "name": "seq.close",
    "type": "function",
    "syntax": "function long seq.close (long fp)",
    "description": "This flushes the buffers associated with the specified file and closes the file. fp is the file pointer returned by seq.open() when the file was opened. Buffers allocated by the standard i/o system are also flushed and closed. These actions are performed automatically when the process exits.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "0 Success. -1 Error. Probably fp not connected. (the last system error is available in the e variable - for example, for file system full, e will be ENOSPC (that is, 28) - for a list of error codes, see Infor ES errors and messages )",
    "category": "functions_directory_file_operations"
  },
  "seq.eof": {
    "name": "seq.eof",
    "type": "function",
    "syntax": "function long seq.eof (long fp)",
    "description": "This checks the end-of-file indicator of a specified file. fp is the file pointer returned by seq.open() when the file was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "0 End-of-file indicator not set. >0 End-of-file indicator set -1 Error; probably fp not connected",
    "category": "functions_directory_file_operations"
  },
  "seq.error": {
    "name": "seq.error",
    "type": "function",
    "syntax": "function long seq.error (long fp)",
    "description": "This checks the error indicator of a specified file. The error indicator is set when an error occurs while reading from or writing to the file. It lasts until it is cleared by seq.clearerr() or until the file is closed. fp is the file pointer returned by seq.open() when the file was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "0 Error indicator not set. >0 Error indicator set -1 Error; probably fp not connected",
    "category": "functions_directory_file_operations"
  },
  "seq.flush": {
    "name": "seq.flush",
    "type": "function",
    "syntax": "function long seq.flush (long fp)",
    "description": "This causes all buffered data for a specified file to be written to that file. The file remains open. fp is the file pointer returned by seq.open() when the file was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "0 Success. >0 Error indicator set -1 Error; probably fp not connected. (The last system error is available in the e variable � for example, for file system full, e will be ENOSPC (that is, 28) � for a list of error codes, see Infor ES errors and messages )",
    "category": "functions_directory_file_operations"
  },
  "seq.getc$": {
    "name": "seq.getc$",
    "type": "function",
    "syntax": "function string seq.getc$ (long fp)",
    "description": "This returns the next character from a specified file. fp is the file pointer returned by seq.open() when the file was opened. An empty string (a string of length 0) indicates either that the end-of-file has been reached or that an error has occurred.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the file was opened. ."
      }
    ],
    "returnValue": "",
    "category": "functions_directory_file_operations"
  },
  "seq.gets": {
    "name": "seq.gets",
    "type": "function",
    "syntax": "function long seq.gets (ref string line, long nrbytes, long fp [, long mode] [, ref long there.was.more])",
    "description": "This reads one or more characters from a specified file.",
    "arguments": [
      {
        "type": "ref string",
        "name": "line",
        "description": "This stores the retrieved characters."
      },
      {
        "type": "long",
        "name": "nrbytes",
        "description": "The maximum number of bytes to be read. Note that the function stops retrieving characters when a new line character is read or when the end of file is reached."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The pointer to the file from which the characters are to be read, as returned by seq.open() when the file was opened."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Use this optional argument to specify the read mode for seq.gets(). Possible values are: GETS_NORMAL The function continues reading characters until either the buffer (line) is full, a new line character is read, or EOF is reached. If the buffer is full, any remaining characters on the line being read are discarded. This is the default mode."
      }
    ],
    "returnValue": "0 Success. -1 Error; probably fp not connected or end of file reached.",
    "category": "functions_directory_file_operations"
  },
  "seq.islocked": {
    "name": "seq.islocked",
    "type": "function",
    "syntax": "function long seq.islocked (long mode, long offset, long size, long fp)",
    "description": "This checks whether a specified file or segment of a file has been locked by seq.lock() .",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": "The type of lock you want to check for: SEQ_R_LCK"
      }
    ],
    "returnValue": "0 File or file segment not locked. <>0 File or file segment locked",
    "category": "functions_directory_file_operations"
  },
  "seq.lock": {
    "name": "seq.lock",
    "type": "function",
    "syntax": "function long seq.lock (long mode, long offset, long size, long fp)",
    "description": "This sets read and write locks on a specified file or segment of a file.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": "The type of lock to set: SEQ_R_LCK"
      }
    ],
    "returnValue": ">= 0 Success. -1 Error; probably fp not connected. < -1 Operating system error code.",
    "category": "functions_directory_file_operations"
  },
  "seq.open": {
    "name": "seq.open",
    "type": "function",
    "syntax": "function long seq.open (string file, string openmode [, ref string pathnm])",
    "description": "This opens a specified file. It uses the file $BSE/lib/fd ver.pack_combination to find the file. ver refers to a particular release of the software; pack_combination refers to a particular package combination (see pathname() ).",
    "arguments": [
      {
        "type": "string",
        "name": "file",
        "description": "The file name."
      },
      {
        "type": "string",
        "name": "openmode",
        "description": "The mode in which the file must be opened. This can be one of the following options: \"r\""
      }
    ],
    "returnValue": ">= 1 Success; File pointer returned for use in subsequent operations. <1 Error; that is, the negative value of the system error (for example, for a permission error, the system returns 13 and the function returns -13, or if the internal table is full, the function returns -EAGAIN).",
    "category": "functions_directory_file_operations"
  },
  "seq.putc$": {
    "name": "seq.putc$",
    "type": "function",
    "syntax": "function string seq.putc$ (string char, long fp)",
    "description": "This writes a specified character to a specified file. fp is the file pointer returned by seq.open() when the particular file was opened.",
    "arguments": [
      {
        "type": "string",
        "name": "char",
        "description": "character"
      },
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": "The character written to the file. Or an empty string (a string of length 0) if the end-of-file was reached or an error occurred. The last system error is available in the e variable � for example, for file system full, e will be ENOSPC (that is, 28) � for a list of error codes, see Infor ES errors and messages .",
    "category": "functions_directory_file_operations"
  },
  "seq.puts": {
    "name": "seq.puts",
    "type": "function",
    "syntax": "function long seq.puts (const string line, long fp)",
    "description": "This writes the specified characters to a specified file, and appends a new line character. fp is the file pointer returned by seq.open() when the particular file was opened.",
    "arguments": [
      {
        "type": "const string",
        "name": "line",
        "description": "Specified characters"
      },
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": "0 Success. -1 Error; probably fp not connected (the last system error is available in the e variable � for example, for file system full, e will be ENOSPC (that is, 28) � for a list of error codes, see Infor ES errors and messages )",
    "category": "functions_directory_file_operations"
  },
  "seq.r.long": {
    "name": "seq.r.long",
    "type": "function",
    "syntax": "function long seq.r.long (long fp)",
    "description": "Reads a 32-bit value from the file. The 4 bytes read from the file are interpreted as the 32-bit two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function reads 4 bytes from the file."
      }
    ],
    "returnValue": "return_value = -1 Error, most probably fp is not a valid file pointer or end-of-file was reached. The last system error is available in predefined variable e . Notice that this error value -1 cannot be distinguished from normal value -1. This is problematic, unless it is known that value -1 is not expected as a normal value to be read from the file. -2^31 &#8804; return_value &#8804; 2^31 - 1 The numerical value of the first 4 bytes of the supplied file. This is a value in the signed 32-bit range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647]).",
    "category": "functions_directory_file_operations"
  },
  "seq.r.short": {
    "name": "seq.r.short",
    "type": "function",
    "syntax": "function long seq.r.short (long fp)",
    "description": "Reads a 16-bit value from the file. The 2 bytes read from the file are interpreted as the 16-bit binary representation of an unsigned integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function reads 2 bytes from the file."
      }
    ],
    "returnValue": "-1 Error, most probably fp is not a valid file pointer. The last system error is available in predefined variable e . >=0 The numerical value of the first 2 bytes of the supplied file. This is a value in the unsigned 16-bit range [0 � 2^16 - 1] (i.e. [0 � 65,535]).",
    "category": "functions_directory_file_operations"
  },
  "seq.r.utc": {
    "name": "seq.r.utc",
    "type": "function",
    "syntax": "function long seq.r.utc (long fp [, long byte.count])",
    "description": "Reads a specified amount of bytes from the file. The bytes read from the file are interpreted as the two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function reads an amount of bytes from the file as specified by byte.count ."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be read from the file. Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the (big endian) byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used."
      }
    ],
    "returnValue": "return_value = -1 Error, most probably fp is not a valid file pointer. The last system error is available in predefined variable e . Notice that this error value -1 cannot be distinguished from normal value -1. This is problematic, unless it is known that value -1 is not expected as a normal value to be read from the file. -(256^ byte.count )/2 &#8804; return_value &#8804; (256^ byte.count )/2 - 1 The numerical value of the bytes read from the supplied file. Typically, this is a (non-negative) UTC long format value stored earlier by the function seq.w.utc() , or prepared by any other means. This function does not perform any value check.",
    "category": "functions_directory_file_operations"
  },
  "seq.read": {
    "name": "seq.read",
    "type": "function",
    "syntax": "function long seq.read (ref string buffer, long nrbytes, long fp)",
    "description": "This reads a specified number of bytes from a specified file into buffer . fp is the file pointer returned by seq.open() when the particular file was opened.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "Buffer"
      },
      {
        "type": "long",
        "name": "nrbytes",
        "description": "Number of bytes to read."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": ">0 Number of bytes read. 0 Either end of file encountered or the number of bytes to read was 0. -1 Error; probably fp not connected.",
    "category": "functions_directory_file_operations"
  },
  "seq.rewind": {
    "name": "seq.rewind",
    "type": "function",
    "syntax": "function long seq.rewind (long fp)",
    "description": "This sets the current file position to the beginning of the file. It is equivalent to: seq.seek() except that the return value is always -1 on error.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp is the file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": "0 Success. -1 Error; probably fp not connected.",
    "category": "functions_directory_file_operations"
  },
  "seq.seek": {
    "name": "seq.seek",
    "type": "function",
    "syntax": "function long seq.seek (long offset, long opt, long fp)",
    "description": "This changes the current file position.",
    "arguments": [
      {
        "type": "long",
        "name": "offset",
        "description": "The new file position, as a number of bytes."
      },
      {
        "type": "long",
        "name": "opt",
        "description": "This determines whether the specified offset is from the beginning of the file, the end of the file, or the current file position: 0 new position is offset from the beginning of the file 1 new position is offset from the current file position 2 new position is offset from the end of the file"
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": ">=0 Success. Returns new position in bytes from the beginning of the file. <0 Error; probably fp not connected. Current file position is not changed.",
    "category": "functions_directory_file_operations"
  },
  "seq.skip": {
    "name": "seq.skip",
    "type": "function",
    "syntax": "function long seq.skip (long nrbytes, long fp)",
    "description": "This skips nrbytes bytes, relative to the current file position, in a file represented by fp . fp is the file pointer returned by seq.open() when the particular file was opened. It is equivalent to: seq.seek() .",
    "arguments": [
      {
        "type": "long",
        "name": "nrbytes",
        "description": "This skips nrbytes bytes, relative to the current file position, in a file represented by fp. fp is the file pointer returned by seq.open() when the particular file was opened. It is equivalent to: seq.seek( nrbytes, 1, fp )."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": ">=0 Success. Returns new position in bytes from the beginning of the file. <0 Error; probably fp not connected. Current file position is not changed.",
    "category": "functions_directory_file_operations"
  },
  "seq.tell": {
    "name": "seq.tell",
    "type": "function",
    "syntax": "function long seq.tell (long fp)",
    "description": "This returns the current file position, relative to the beginning of the file. The file position is measured in bytes. fp is the file pointer returned by seq.open() when the particular file was opened.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": ">=0 Success. <0 Error; probably fp not connected.",
    "category": "functions_directory_file_operations"
  },
  "seq.ungetc$": {
    "name": "seq.ungetc$",
    "type": "function",
    "syntax": "function string seq.ungetc$ (string char, long fp)",
    "description": "This puts back a specified character, retrieved by seq.getc$() . The character will be returned by the next seq.getc$() call on that file. This function works only if something has been read from the file and if the file is buffered. fp is the file pointer returned by seq.open() when the particular file was opened.",
    "arguments": [
      {
        "type": "string",
        "name": "char",
        "description": "This puts back a specified character"
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": "The character written to the file. Or an empty string if end-of-file is reached or an error occured.",
    "category": "functions_directory_file_operations"
  },
  "seq.unlink": {
    "name": "seq.unlink",
    "type": "function",
    "syntax": "function long seq.unlink (string path_name(512))",
    "description": "This deletes the file indicated by the path_name argument.",
    "arguments": [
      {
        "type": "string",
        "name": "path_name(512)",
        "description": "Path name argument."
      }
    ],
    "returnValue": ">=0 Success. <0 Error; The negative value of the operating system error.",
    "category": "functions_directory_file_operations"
  },
  "seq.unlock": {
    "name": "seq.unlock",
    "type": "function",
    "syntax": "function long seq.unlock (long mode, long offset, long size, long fp)",
    "description": "This removes a lock set by seq.lock() .",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": "The type of lock to remove: SEQ_R_LCK"
      }
    ],
    "returnValue": ">=0 Success. -1 Error; probably fp not connected. < -1 Error; Negative error value.",
    "category": "functions_directory_file_operations"
  },
  "seq.w.long": {
    "name": "seq.w.long",
    "type": "function",
    "syntax": "function long seq.w.long (long value, long fp)",
    "description": "Writes a 32-bit integer value into the file.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the file. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-0x80000000 � 0x7fffffff] or [-2,147,483,648 � 2,147,483,647]). See store.long() for a description of explicit wrapping that might be done beforehand."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function writes 4 bytes to the file."
      }
    ],
    "returnValue": "-1 Error, most probably fp is not a valid file pointer. The last system error is available in predefined variable e . 0 Success.",
    "category": "functions_directory_file_operations"
  },
  "seq.w.short": {
    "name": "seq.w.short",
    "type": "function",
    "syntax": "function long seq.w.short (long value, long fp)",
    "description": "Writes a 16-bit integer value into the file.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the file It is not an error (but it is not encouraged) to supply a value outside the unsigned 16-bit value range [0 � 2^16 - 1] (i.e. [0 � 0xffff] or [0 � 65,535]), for which the inverse function seq.r.short() will retrieve the original supplied integer value. Explicit wrapping of the input value may be done beforehand by means of the 'remainder after division by 0x10000' operator \\ 0x10000 . However, for a negative input value, the result of the expression value \\ 0x10000 is still not in the desired range [0 � 0xffff] but in the range [-0xffff] � 0]. For complete wrapping to the desired range [0 � 0xffff], the following expression may be used: (value \\ 0x10000 + 0x10000) \\ 0x10000 . In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647])."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function writes 2 bytes to the file."
      }
    ],
    "returnValue": "-1 Error, most probably fp is not a valid file pointer. The last system error is available in predefined variable e . 0 Success.",
    "category": "functions_directory_file_operations"
  },
  "seq.w.utc": {
    "name": "seq.w.utc",
    "type": "function",
    "syntax": "function long seq.w.utc (long value, long fp [, long byte.count])",
    "description": "Writes an integer value into the file.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the file. Typically, this is a (non-negative) UTC long format value. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a negative value . When the bshell is in 64-bit mode, it is a fatal error to supply a value which cannot be stored in the available byte.count bytes without loss of information. Typically, this is the case when byte.count is 4 and the supplied value is outside the signed 32-bit value range, i.e. is greater than 2,147,483,647 (0x7fff,ffff), which corresponds to January 19, 2038, 03:14:07 UTC. When the bshell is in 64-bit mode, it is a fatal error to supply a value which is a UTC long format value greater than the current maximum DB.TIME domain value. Typically, this maximum is 253,402,214,400 (0x3a,fff2,f000), which corresponds to the begin of the last day of the last four-digit year, i.e. December 31, 9999, 00:00:00 UTC."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened. This function writes an amount of bytes to the file as specified by byte.count ."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be written to the file. Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the (big endian) byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used."
      }
    ],
    "returnValue": "-1 Error, most probably fp is not a valid file pointer. The last system error is available in predefined variable e . 0 Success.",
    "category": "functions_directory_file_operations"
  },
  "seq.write": {
    "name": "seq.write",
    "type": "function",
    "syntax": "function long seq.write (const string buffer, long nrbytes, long fp)",
    "description": "This function appends the specified number of bytes from the specified buffer to the specified file, beginning at the current file position.",
    "arguments": [
      {
        "type": "const string",
        "name": "buffer",
        "description": "Input string, providing the bytes to be written to the file."
      },
      {
        "type": "long",
        "name": "nrbytes",
        "description": "The number of bytes to be written to the file. A negative number triggers the complete buffer to be written."
      },
      {
        "type": "long",
        "name": "fp",
        "description": "The file pointer returned by seq.open() when the particular file was opened."
      }
    ],
    "returnValue": ">0 Number of bytes actually written. 0 End-of-file. < -1 Error; Probably fp not connected. (the last system error is available in the e variable � for example, for file system full, e will be ENOSPC (that is, 28) � for a list of error codes, see Infor ES errors and messages )",
    "category": "functions_directory_file_operations"
  },
  "stat.info": {
    "name": "stat.info",
    "type": "function",
    "syntax": "function long stat.info (string file_name, ref long size, ref long mode, ref long inode, ref long dev, ref long uid, ref long gid, ref long nlink, ref long ctime, ref long mtime, ref long atime)",
    "description": "This returns information about a named file. It provides the same information as fstat.info() , but for a named file.",
    "arguments": [
      {
        "type": "string",
        "name": "file_name",
        "description": "The name of the file. All files listed in the path name must be searchable. To specify a remote file, include the host name. For example: \"host!/usr/myfile\"."
      },
      {
        "type": "ref long",
        "name": "size",
        "description": "The file size in bytes."
      },
      {
        "type": "ref long",
        "name": "mode",
        "description": "This contains a bit pattern that indicates the access permission (posix) of the file. Use the following defines to check the file mode: S_IRWXU"
      }
    ],
    "returnValue": "0 Success. <>0 Operating system error code.",
    "category": "functions_directory_file_operations"
  },
  "directory and file operations synopsis": {
    "name": "Directory and file operations synopsis",
    "type": "function",
    "syntax": "function Directory and file operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_directory_file_operations"
  },
  "zipfile.build": {
    "name": "zipfile.build",
    "type": "function",
    "syntax": "function long zipfile.build (long zipinfo)",
    "description": "Builds a zip file based on the specified zipinfo object.",
    "arguments": [
      {
        "type": "long",
        "name": "zipinfo",
        "description": "a list with entries to add to the zip file; both directories and files are allowed; in case of directories, all sub directories and files are taken into account as well"
      }
    ],
    "returnValue": "0 OK, success. <>0 When an error occurred.",
    "category": "functions_directory_file_operations"
  },
  "zipfile.create": {
    "name": "zipfile.create",
    "type": "function",
    "syntax": "function long zipfile.create (const string zipfile, const string entry)",
    "description": "Creates a zip file for the specified entry. This may be a file or a directory. In case of a directory, all files and subdirectories in that directory are added to the zip file. In case the zip file already exists, it is overwritten.",
    "arguments": [
      {
        "type": "const string",
        "name": "zipfile",
        "description": "the full name of the zip file to create"
      },
      {
        "type": "const string",
        "name": "entry",
        "description": "the file or directory create the zip file for; in case of directories, all sub directories and files are taken into account as well"
      }
    ],
    "returnValue": "0 OK, success. <>0 When an error occurred.",
    "category": "functions_directory_file_operations"
  },
  "zipfile.extract": {
    "name": "zipfile.extract",
    "type": "function",
    "syntax": "function long zipfile.extract (const string zipfile, const string dir)",
    "description": "Extracts all files from a zip file to the specified directory. Any files in the zip file that already exist in the specified directory, will be overwritten. In case the extracted files are to be removed after processing them, it is advised to extract the files to a just created temporary directory, which can be removed when no longer needed. See rmdir() for more information regarding removing a directory structure.",
    "arguments": [
      {
        "type": "const string",
        "name": "zipfile",
        "description": "the full name of the zip file to extract from"
      },
      {
        "type": "const string",
        "name": "dir",
        "description": "the directory to extract the contents to"
      }
    ],
    "returnValue": "0 OK, success. <>0 When an error occurred.",
    "category": "functions_directory_file_operations"
  },
  "zipfile.info": {
    "name": "zipfile.info",
    "type": "function",
    "syntax": "function long zipfile.info (const string zipfile)",
    "description": "Retrieves a zipinfo object providing information regarding all entries in a zipfile.",
    "arguments": [
      {
        "type": "const string",
        "name": "zipfile",
        "description": "the full name of the zip file to retrieve the info from"
      }
    ],
    "returnValue": "<>0 a handle to a zipinfo object 0 in case of failure.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.add": {
    "name": "zipinfo.add",
    "type": "function",
    "syntax": "function [long] zipinfo.add (long handle, const string entry [, long type])",
    "description": "Adds an entry to a zipinfo object. The entry may either be a directory or a file. Optionally, the entry type (directory or file) may be specified.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      },
      {
        "type": "const string",
        "name": "entry",
        "description": "the name of a file or a directory"
      },
      {
        "type": "[long",
        "name": "type ]",
        "description": "specify TDIR for directories, or TFILE for files; if not specified an attempt is made to determine the type using the entry name"
      }
    ],
    "returnValue": "0 OK, success. <>0 When an error occurred.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.count": {
    "name": "zipinfo.count",
    "type": "function",
    "syntax": "function long zipinfo.count (long handle)",
    "description": "Returns the number of entries in a zipinfo object.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      }
    ],
    "returnValue": "the number of entries in a zipinfo object.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.delete": {
    "name": "zipinfo.delete",
    "type": "function",
    "syntax": "function [long] zipinfo.delete (long handle)",
    "description": "Deletes a zipinfo object.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      }
    ],
    "returnValue": "0 OK, success. <0 When an error occurred.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.file": {
    "name": "zipinfo.file",
    "type": "function",
    "syntax": "function string zipinfo.file (long handle)",
    "description": "Retrieves attribute file.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      }
    ],
    "returnValue": "the name of a zipfile for which a zipinfo object is or will be created",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.first": {
    "name": "zipinfo.first",
    "type": "function",
    "syntax": "function boolean zipinfo.first (long handle, ref string entry, ref long type)",
    "description": "Retrieves the first entry from a zipinfo object.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      },
      {
        "type": "ref string",
        "name": "entry",
        "description": "the returned name of the entry."
      },
      {
        "type": "ref long",
        "name": "type",
        "description": "the returned entry type: TDIR for directories, TFILE for files"
      }
    ],
    "returnValue": "True the zipinfo object has a first entry. False the zipinfo object has no first entry.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.new": {
    "name": "zipinfo.new",
    "type": "function",
    "syntax": "function long zipinfo.new (const string zipfile)",
    "description": "Returns a new empty zipinfo object for the specified zipfile.",
    "arguments": [
      {
        "type": "const string",
        "name": "zipfile",
        "description": "the name of a zipfile for which a zipinfo object must be created."
      }
    ],
    "returnValue": "<>0 a handle to the new zipinfo object 0 in case of failure.",
    "category": "functions_directory_file_operations"
  },
  "zipinfo.next": {
    "name": "zipinfo.next",
    "type": "function",
    "syntax": "function boolean zipinfo.next (long handle, ref string entry, ref long type)",
    "description": "Retrieves the next entry from a zipinfo object.",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "a handle to a zipinfo object. Retrieved by zipinfo.new() or zipfile.info()."
      },
      {
        "type": "ref string",
        "name": "entry",
        "description": "the returned name of the entry."
      },
      {
        "type": "ref long",
        "name": "type",
        "description": "the returned entry type: TDIR for directories, TFILE for files"
      }
    ],
    "returnValue": "True the zipinfo object has a next entry. False the zipinfo object has no next entry.",
    "category": "functions_directory_file_operations"
  },
  "exec_dll_function": {
    "name": "exec_dll_function",
    "type": "function",
    "syntax": "function long exec_dll_function (string dll_name, string function_name [, ref void return_value] [, void ...])",
    "description": "This loads a specified DLL and executes a specified function within that DLL. It provides a fast algorithm for executing a DLL function that is to be executed only once. If the DLL is already loaded, the identification number of the loaded DLL is used to search for the specified function. Otherwise, a load_dll(dll_name, 0) call is executed automatically. If a function is to be called more than once, it is faster to use the load_dll() , get_function() , and exec_function() combination.",
    "arguments": [
      {
        "type": "string",
        "name": "dll_name",
        "description": "The name of the DLL that must be loaded."
      },
      {
        "type": "string",
        "name": "function_name",
        "description": "The name of the function that must be executed."
      },
      {
        "type": "[ref void",
        "name": "return_value ]",
        "description": "Optional reference argument to which the return value of the function call must be assigned. Implicit conversion of the return value of the function call from its original type to the type of the reference argument is performed. This argument can be omitted only if the function is called without any arguments and the function is either of type void (this means that no value is returned) or its return value is not needed. If the function is of type void and is called with any arguments, then the return_value argument must be supplied. No value will be assigned to the supplied reference argument."
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "The values to be passed as arguments to the function call. An error occurs when any of the supplied values is of a different type than the required type of the corresponding argument of the function to be called. If any argument values for the function call are supplied, then first the return_value argument must be supplied."
      }
    ],
    "returnValue": "0 Success. -1 Error; DLL not found. -2 Error; Function not found.",
    "category": "functions_dll"
  },
  "exec_function": {
    "name": "exec_function",
    "type": "function",
    "syntax": "function long exec_function (long dll_id, long funct_id [, ref void return_value] [, void ...])",
    "description": "This executes a function previously loaded by a call to get_function() . After the function has been loaded, you can call exec_function() any number of times to execute the function.",
    "arguments": [
      {
        "type": "long",
        "name": "dll_id",
        "description": "The identification number of the DLL that contains the function, as returned by load_dll() ."
      },
      {
        "type": "long",
        "name": "funct_id",
        "description": "The identification number of the function, as returned by get_function() ."
      },
      {
        "type": "[ref void",
        "name": "return_value ]",
        "description": "Optional reference argument to which the return value of the function call must be assigned. Implicit conversion of the return value of the function call from its original type to the type of the reference argument is performed. This argument can be omitted only if the function is called without any arguments and the function is either of type void (this means that no value is returned) or its return value is not needed. If the function is of type void and is called with any arguments, then the return_value argument must be supplied. No value will be assigned to the supplied reference argument."
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "The values to be passed as arguments to the function call. An error occurs when any of the supplied values is of a different type than the required type of the corresponding argument of the function to be called. If any argument values for the function call are supplied, then first the return_value argument must be supplied."
      }
    ],
    "returnValue": "0 Success. -1 Error; DLL not found. -2 Error; Function not found.",
    "category": "functions_dll"
  },
  "get_function": {
    "name": "get_function",
    "type": "function",
    "syntax": "function long get_function (long dll_id, string funct_name)",
    "description": "This loads a specified function from a previously loaded DLL. It returns an identification number for the function.",
    "arguments": [
      {
        "type": "long",
        "name": "dll_id",
        "description": "The identification number of the DLL that contains the function, as returned by load_dll() ."
      },
      {
        "type": "string",
        "name": "funct_name",
        "description": "The function name."
      }
    ],
    "returnValue": ">0 Function identifier. 0 Error; Function not found or DLL not loaded.",
    "category": "functions_dll"
  },
  "load_dll": {
    "name": "load_dll",
    "type": "function",
    "syntax": "function long load_dll (string dll_name [, long overload])",
    "description": "This loads a specified DLL.",
    "arguments": [
      {
        "type": "string",
        "name": "dll_name",
        "description": "The name of the DLL."
      },
      {
        "type": "[long",
        "name": "overload ]",
        "description": "This optional argument sets the overload flag for the specified DLL. The possible values are: 0"
      }
    ],
    "returnValue": ">0 DLL identifier. 0 Error; DLL not found.",
    "category": "functions_dll"
  },
  "dll functions (executing) overview and synopsis": {
    "name": "DLL functions (executing) overview and synopsis",
    "type": "function",
    "syntax": "function DLL functions (executing) overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dll"
  },
  "parse_and_exec_function": {
    "name": "parse_and_exec_function",
    "type": "function",
    "syntax": "function long parse_and_exec_function (string dll_name, string function_call [, ref void return_value] [, ref string return_call])",
    "description": "This function is similar to exec_dll_function() . It loads a specified DLL and parses and executes a specified function within that DLL. If the DLL is already loaded, the identification number of the loaded DLL is used to search for the specified function. Otherwise, a load_dll(dll_name, 0) call is executed automatically.",
    "arguments": [
      {
        "type": "string",
        "name": "dll_name",
        "description": "The name of the DLL that must be loaded."
      },
      {
        "type": "string",
        "name": "function_call",
        "description": "A string containing the function name and arguments. You can specify any function in this argument, except one that contains array arguments. To execute a function with array arguments, use exec_dll_function() instead. For each argument value, implicit conversion of its string representation to the type of the function argument is performed."
      },
      {
        "type": "[ref void",
        "name": "return_value ]",
        "description": "Reference argument to which the return value of the function call must be assigned. Implicit conversion of the return value of the function call from its original type to the type of the reference argument is performed. If the function to be called is of type void (this means that no value is returned), then this argument must be omitted."
      },
      {
        "type": "[ref string",
        "name": "return_call ]",
        "description": "Reference argument which receives a representation of the function call after its execution. For reference arguments of the function, the resulting argument value is given. Implicit conversion of the represented values from their original type to the string type is performed."
      }
    ],
    "returnValue": "0 Success. -1 Error; DLL not found. -2 Error; Function not found. -3 Error; Syntax error in function call.",
    "category": "functions_dll"
  },
  "dynamic sql queries overview": {
    "name": "Dynamic SQL queries overview",
    "type": "function",
    "syntax": "function Dynamic SQL queries overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.break": {
    "name": "sql.break",
    "type": "function",
    "syntax": "function long sql.break (long sql_id)",
    "description": "This stops the specified query and clears any interim results. The sql_id argument indicates the query ID, as returned by sql.parse() . The function does not remove the query itself. So the query can be reused after binding to another variable, for example.",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": ""
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.close": {
    "name": "sql.close",
    "type": "function",
    "syntax": "function long sql.close (long sql_id)",
    "description": "This deletes all internal information relating to the specified query. The sql_id argument indicates the query ID, as returned by sql.parse() .",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": ""
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.exec": {
    "name": "sql.exec",
    "type": "function",
    "syntax": "function long sql.exec (long sql_id)",
    "description": "This initializes the specified query and evaluates any bind variables in the WHERE clause. Before calling this function, you must previously have called sql.parse() to define the query. The sql_id argument indicates the query ID, as returned by sql.parse() .",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": "the query ID, as returned by sql.parse()"
      }
    ],
    "returnValue": "0 Success. <>0 Error. Note that executing an UPDATE or DELETE statement may result in error ENOREC, which means that the statement completed but no rows were processed.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.fetch": {
    "name": "sql.fetch",
    "type": "function",
    "syntax": "function long sql.fetch (long sql_id)",
    "description": "This reads a single query result and stores the values retrieved in the variables specified in the SELECT list. The sql_id argument indicates the query ID, as returned by sql.parse() . You must call the function for each individual record in the result set.",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": ""
      }
    ],
    "returnValue": "0 Success. <>0 Error. The function returns eendfile when it reaches the end of the result set. It returns enorec if the set is empty.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.get.select.all.data.languages": {
    "name": "sql.get.select.all.data.languages",
    "type": "function",
    "syntax": "function boolean sql.get.select.all.data.languages ()",
    "description": "This function retrieves the value of the select.all.data.languages flag of the current process.",
    "arguments": [],
    "returnValue": "The current value of the select.all.data.languages flag of the current process",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.parse": {
    "name": "sql.parse",
    "type": "function",
    "syntax": "function long sql.parse (string query(.) [, long mode] [, ref string err.msg] [, ref long err.line] [, const string annotation, ...])",
    "description": "This defines an SQL query that you can subsequently execute and retrieve the results of by using the other dynamic SQL functions. The query takes the form of a SELECT statement (see Database handling overview ).",
    "arguments": [
      {
        "type": "string",
        "name": "query(.)",
        "description": ""
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "Optional parameter with default value 0. PARSE.SUPPRESS When this flag is set, error messages are suppressed. (the predefined variable e contains the error number)."
      }
    ],
    "returnValue": "0 Error. >0 Query ID; this is used by the other functions to identify the particular query.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.select.bind": {
    "name": "sql.select.bind",
    "type": "function",
    "syntax": "function long sql.select.bind (long sql_id, long pseudo_var, varname var_name(.))",
    "description": "When you define an SQL statement with the sql.parse() function, you can define a pseudo variable for any or all of the fields specified in the SELECT statement. You do this by appending a number, prefixed by a colon [:], to each field. You use sql.select.bind() to bind a pseudo variable to a BAAN 4GL variable. As a result, the values of the field retrieved by the SELECT statement are stored in the 4GL variable. They can then be used elsewhere in the program.",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": "The query ID, as returned by sql.parse() ."
      },
      {
        "type": "long",
        "name": "pseudo_var",
        "description": "The pseudo variable from the SELECT list. This is always a number."
      },
      {
        "type": "varname",
        "name": "var_name(.)",
        "description": "The name of the BAAN 4GL variable to which the pseudo variable must be bound."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.set.rds.full": {
    "name": "sql.set.rds.full",
    "type": "function",
    "syntax": "function long sql.set.rds.full (long sql_id, long size)",
    "description": "This sets the size of the RDBMS buffer. The buffer is used to send the result rows of a query from the database back to the client (that is, the bshell). For example, if a query fetches 20 rows and you have set the size of the buffer to 5, then the database sends the rows back to the client five at a time.",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": "The query ID, as returned by sql.parse() ."
      },
      {
        "type": "long",
        "name": "size",
        "description": "The size of the buffer, in rows."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.set.select.all.data.languages": {
    "name": "sql.set.select.all.data.languages",
    "type": "function",
    "syntax": "function boolean sql.set.select.all.data.languages (boolean select.all.data.languages)",
    "description": "This function sets the value of the select.all.data.languages flag of the current process. The specified value of the flag is valid until the end of the current 3GL function. After return from the current 3GL function, the flag is set back to the value which it had in the calling 3GL function. When the program is set back to a retry point , the flag is set back to the value which it had at the moment that the retry point was set.",
    "arguments": [
      {
        "type": "boolean",
        "name": "select.all.data.languages",
        "description": "The new value of the select.all.data.languages flag of the current process"
      }
    ],
    "returnValue": "The old value of the select.all.data.languages flag of the current process",
    "category": "functions_dynamic_sql_queries"
  },
  "sql.where.bind": {
    "name": "sql.where.bind",
    "type": "function",
    "syntax": "function long sql.where.bind (long sql_id, long pseudo_var, varname var_name(.))",
    "description": "This binds a pseudo variable from the WHERE clause of a specified SQL query to a BAAN 4GL variable. This enables the BAAN 4GL variable to be used in the WHERE clause. Note that there is no need to bind external variables.",
    "arguments": [
      {
        "type": "long",
        "name": "sql_id",
        "description": "The query ID, as returned by sql.parse() ."
      },
      {
        "type": "long",
        "name": "pseudo_var",
        "description": "The pseudo variable from the WHERE clause. This is always a number. In the WHERE clause, it is entered as the number, prefixed by a colon [:]."
      },
      {
        "type": "varname",
        "name": "var_name(.)",
        "description": "The name of the BAAN 4GL variable to which the pseudo variable must be bound."
      }
    ],
    "returnValue": "0 Success. <>0 Error.",
    "category": "functions_dynamic_sql_queries"
  },
  "dynamic sql queries synopsis": {
    "name": "Dynamic SQL queries synopsis",
    "type": "function",
    "syntax": "function Dynamic SQL queries synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_dynamic_sql_queries"
  },
  "ask.enum": {
    "name": "ask.enum",
    "type": "function",
    "syntax": "function bset ask.enum (string quescode, bset default_enumval [, void arg, ...])",
    "description": "This displays a message box containing a question and a number of possible responses. The responses are presented as push buttons. To respond to the question and close the message box, the user selects one of the push buttons.",
    "arguments": [
      {
        "type": "string",
        "name": "quescode",
        "description": "The question to be displayed in the message box is defined in the data dictionary. This argument specifies the data dictionary code for the question. If the question contains substitution symbols, use the third and subsequent arguments to specify the values to substitute for these symbols."
      },
      {
        "type": "bset",
        "name": "default_enumval",
        "description": "Specifies the enumerate value of the default answer. For example, tcyesno.yes. If this argument is empty, the default value specified in the data dictionary is used."
      },
      {
        "type": "[void",
        "name": "arg, ... ]",
        "description": "The values to substitute for any substitution symbols that the question contains. See sprintf$() ."
      }
    ],
    "returnValue": "The value of the enumerated domain that corresponds to the option selected by the user. This is always the enumerate value and not its description.",
    "category": "functions_enumerates"
  },
  "enum.descr$": {
    "name": "enum.descr$",
    "type": "function",
    "syntax": "function string enum.descr$ (string domain_code(12), enum_expr [, string language_code])",
    "description": "This returns the description associated with a specific value in an enumerated domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_code(12)",
        "description": "The name of the domain. The domain must be of type enumerated."
      },
      {
        "type": "",
        "name": "enum_expr",
        "description": "One of the possible values of the enumerated domain."
      },
      {
        "type": "[string",
        "name": "language_code ]",
        "description": "To retrieve the description in a language other than the user language, specify the relevant language code in this argument. This is an optional argument. The default language is the language of the user. Note that the language code of the user is available in the predefined, read-only variable language$ ."
      }
    ],
    "returnValue": "The description of the specified enumerate value, either in the current user language or in another specified language. The function returns an empty string, and displays an error message, if an unknown domain is specified or if no description exists in the data dictionary for the specified language.",
    "category": "functions_enumerates"
  },
  "etol": {
    "name": "etol",
    "type": "function",
    "syntax": "function long etol (domain domain_value)",
    "description": "This returns the numeric code corresponding to a specified value in an enumerated domain.",
    "arguments": [
      {
        "type": "domain",
        "name": "domain_value",
        "description": "The name of the domain. The domain must be of type enumerated."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "ltoe": {
    "name": "ltoe",
    "type": "function",
    "syntax": "function domain ltoe (long long_value)",
    "description": "This returns the named constant corresponding to a specified numeric code. The numeric code represents one of the values in an enumerated domain.",
    "arguments": [
      {
        "type": "long",
        "name": "long_value",
        "description": "The numeric code represents one of the values in an enumerated domain."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "enumerates overview and synopsis": {
    "name": "Enumerates overview and synopsis",
    "type": "function",
    "syntax": "function Enumerates overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.ask.enum.values": {
    "name": "set.ask.enum.values",
    "type": "function",
    "syntax": "function void set.ask.enum.values (enum_constant,... enum_constant)",
    "description": "This restricts the values valid for the ask.enum() function. Only the values specified are shown as buttons.",
    "arguments": [
      {
        "type": "enum_constant,...",
        "name": "enum_constant",
        "description": "List of enum_constants."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.enum.array.for.field": {
    "name": "set.enum.array.for.field",
    "type": "function",
    "syntax": "function void set.enum.array.for.field (const string field.name, const long size, const long values)",
    "description": "In case the field is a listbox , this fills the list with a specified set of enumerate values.",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name",
        "description": "The name of the enumerated field. For example, \"ttadv996.type\". For an array field, include the array element. For example, \"tttadv996.type(5)\"."
      },
      {
        "type": "const long",
        "name": "size",
        "description": "the size of the values array."
      },
      {
        "type": "const long",
        "name": "values",
        "description": "The values to be displayed in the field."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.enum.values.for.field": {
    "name": "set.enum.values.for.field",
    "type": "function",
    "syntax": "function void set.enum.values.for.field (const string field.name [, long ALL_ENUMS_EXCEPT] [, enum enum_value, ...])",
    "description": "In case the field is a listbox , this fills the list with a specified set of enumerate values.",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name",
        "description": "The name of the enumerated field. For example, \"ttadv996.type\". For an array field, include the array element. For example, \"tttadv996.type(5)\"."
      },
      {
        "type": "[long",
        "name": "ALL_ENUMS_EXCEPT ]",
        "description": "This optional macro specifies that the succeeding list of enumerate values represents those values that are to be excluded from the enumerate set. Otherwise, the list of enumerate values represents the values that are to be included ."
      },
      {
        "type": "[enum",
        "name": "enum_value, ... ]",
        "description": "The values to be displayed in the field, separated by commas [,]. This is an optional argument. If not included, all enumerate values defined for the field are available."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.enum.values": {
    "name": "set.enum.values",
    "type": "function",
    "syntax": "function void set.enum.values (enum_constant enum_constant,...)",
    "description": "This restricts the values valid for the ask.enum() function. Only the values specified are shown as buttons.",
    "arguments": [
      {
        "type": "enum_constant",
        "name": "enum_constant,...",
        "description": "The name of the constant."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.initial.enum.array.for.field": {
    "name": "set.initial.enum.array.for.field",
    "type": "function",
    "syntax": "function void set.initial.enum.array.for.field (const string field.name, long size, const long values)",
    "description": "This function applies to enumerated fields that are displayed as listbox or option set. It limits the number of options to the specified set of enum constants. Any options not specified will be hidden .",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name",
        "description": "The name of the optionset field. For example, \"ttadv996.type\". For an array field, include the array element. For example, \"tttadv996.type(5)\"."
      },
      {
        "type": "long",
        "name": "size",
        "description": "The size of the values array."
      },
      {
        "type": "const long",
        "name": "values",
        "description": "The values to be displayed in the field."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.initial.enum.values.for.field": {
    "name": "set.initial.enum.values.for.field",
    "type": "function",
    "syntax": "function void set.initial.enum.values.for.field (const string field.name, long ALL_ENUMS_EXCEPT, enum enum_value, ...)",
    "description": "This function applies to enumerated fields that are displayed as listbox or optionset. It limits the number of options to the specified set of enum constants. Any options not specified will be hidden .",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name",
        "description": "The name of the optionset field. For example, \"ttadv996.type\". For an array field, include the array element. For example, \"tttadv996.type(5)\"."
      },
      {
        "type": "long",
        "name": "ALL_ENUMS_EXCEPT",
        "description": "This optional macro specifies that the succeeding list of enumerate values represents those values that are to be excluded from the enumerate set. Otherwise, the list of enumerate values represents the values that are to be included ."
      },
      {
        "type": "enum",
        "name": "enum_value, ...",
        "description": "The options to be displayed on the form, separated by commas [,]. This is an optional argument. If not included, all enumerate values (= all options) defined for the field are available."
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "set.initial.enum.values.for.workflow.status.field": {
    "name": "set.initial.enum.values.for.workflow.status.field",
    "type": "function",
    "syntax": "function void set.initial.enum.values.for.workflow.status.field (long ALL_ENUMS_EXCEPT, enum workflow_status, ...)",
    "description": "This function applies to a workflow status field that is displayed as listbox. It limits the number of workflow statuses to the specified set. Any workflow status not specified will be hidden . Function set.initial.enum.values.for.workflow.status.field is equivalent to set.initial.enum.values.for.field() with the field.name argument set to �ttocm999.stts�",
    "arguments": [
      {
        "type": "long",
        "name": "ALL_ENUMS_EXCEPT",
        "description": "This optional macro specifies that the succeeding list of workflow statuses represents those statuses that are to be excluded . Otherwise, the list of workflow statuses represents the statuses that are to be included ."
      },
      {
        "type": "enum",
        "name": "workflow_status, ...",
        "description": "The workflow statuses to be displayed on the form, separated by commas [,]. This is an optional argument. If not included, all workflow statuses are available. There are 9 workflow statuses predefined. Use these predefined statuses by specifying: DBCM_STATUS_NOT_STARTED DBCM_STATUS_DRAFT DBCM_STATUS_DRAFT_REV DBCM_STATUS_PENDING DBCM_STATUS_RECALL_REQ DBCM_STATUS_REJECTED DBCM_STATUS_APPRV_RECVD DBCM_STATUS_APPROVED DBCM_STATUS_NOT_APPL"
      }
    ],
    "returnValue": "",
    "category": "functions_enumerates"
  },
  "d.expr": {
    "name": "d.expr",
    "type": "function",
    "syntax": "function double d.expr (long expr_id [, void value] [, boolean suppressError])",
    "description": "Executes (or evaluates) an expression previously compiled by expr.compile() . The result is always converted to a double.",
    "arguments": [
      {
        "type": "long",
        "name": "expr_id",
        "description": "The ID of the compiled expression, as returned by expr.compile() ."
      },
      {
        "type": "[void",
        "name": "value ]",
        "description": "If the expression contains the characters '$$', the value specified by this argument is substituted for those characters. This is an optional argument."
      },
      {
        "type": "[boolean",
        "name": "suppressError ]",
        "description": "Suppresses errors"
      }
    ],
    "returnValue": "The result of the expression converted to a double.",
    "category": "functions_expressions_runtime"
  },
  "expr.compile": {
    "name": "expr.compile",
    "type": "function",
    "syntax": "function long expr.compile (string expression)",
    "description": "This compiles the specified expression and returns an ID number for the compiled expression. The expression can be executed subsequently using l.expr() , d.expr() , or s.expr$() . Because variables included in the expression must be known at runtime, they must be declared as external variables.",
    "arguments": [
      {
        "type": "string",
        "name": "expression",
        "description": "Expression to compile."
      }
    ],
    "returnValue": "An ID for the compiled expression.",
    "category": "functions_expressions_runtime"
  },
  "expr.free": {
    "name": "expr.free",
    "type": "function",
    "syntax": "function void expr.free (long expr_id)",
    "description": "This frees the memory allocated to a compiled expression. expr_id is the ID of the compiled expression, as returned by expr.compile() It is important to call this function when you have finished with an expression.",
    "arguments": [
      {
        "type": "long",
        "name": "expr_id",
        "description": "The ID of the compiled expression."
      }
    ],
    "returnValue": "",
    "category": "functions_expressions_runtime"
  },
  "l.expr": {
    "name": "l.expr",
    "type": "function",
    "syntax": "function long l.expr (long expr_id [, void value] [, boolean suppressError])",
    "description": "Executes (or evaluates) an expression previously compiled by expr.compile() . The result is always converted to a long.",
    "arguments": [
      {
        "type": "long",
        "name": "expr_id",
        "description": "The ID of the compiled expression, as returned by expr.compile() ."
      },
      {
        "type": "[void",
        "name": "value ]",
        "description": "If the expression contains the characters '$$', the value specified by this argument is substituted for those characters. This is an optional argument."
      },
      {
        "type": "[boolean",
        "name": "suppressError ]",
        "description": "Suppresses errors"
      }
    ],
    "returnValue": "The result of the expression converted to an integer value. Notice that signed 64-bit values are used for integer arithmetic in runtime expression evaluation. In older porting sets (with bshell TIV level less than 2000 ), signed 32-bit values are used for integer arithmetic in runtime expression evaluation. If the resulting integer value is greater than the maximum value 2^( BitCountOfLong -1) - 1 of the signed BitCountOfLong -bit range, then that maximum value is returned. If the resulting integer value is less than the minimum value -2^( BitCountOfLong -1) of the signed BitCountOfLong -bit range, then that minimum value is returned.",
    "category": "functions_expressions_runtime"
  },
  "runtime expressions: overview and synopsis": {
    "name": "Runtime expressions: overview and synopsis",
    "type": "function",
    "syntax": "function Runtime expressions: overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_expressions_runtime"
  },
  "s.expr$": {
    "name": "s.expr$",
    "type": "function",
    "syntax": "function string s.expr$ (long expr_id [, void value] [, boolean suppressError])",
    "description": "Executes (or evaluates) an expression previously compiled by expr.compile() . The result is always converted to a string.",
    "arguments": [
      {
        "type": "long",
        "name": "expr_id",
        "description": "The ID of the compiled expression, as returned by expr.compile() ."
      },
      {
        "type": "[void",
        "name": "value ]",
        "description": "If the expression contains the characters '$$', the value specified by this argument is substituted for those characters. This is an optional argument."
      },
      {
        "type": "[boolean",
        "name": "suppressError ]",
        "description": "Suppresses errors"
      }
    ],
    "returnValue": "The result of the expression converted to a string.",
    "category": "functions_expressions_runtime"
  },
  "edit$": {
    "name": "edit$",
    "type": "function",
    "syntax": "function string edit$ (void expression, string format)",
    "description": "This formats an expression according to a specified format.",
    "arguments": [
      {
        "type": "void",
        "name": "expression",
        "description": "The expression that must be formatted. Implicit conversion of the input value from its original type to type string is performed. The resulting string value is formatted according to the format argument."
      },
      {
        "type": "string",
        "name": "format",
        "description": "A string that defines the required format. The following formatting characters are available: 9"
      }
    ],
    "returnValue": "The function returns the formatted expression. If the specified expression does not fit in the format string, the result is filled with the overflow characters defined in the data dictionary.",
    "category": "functions_formatting_io"
  },
  "get.numformat.symbols": {
    "name": "get.numformat.symbols",
    "type": "function",
    "syntax": "function long get.numformat.symbols (ref string decimal$, ref string grouping$)",
    "description": "Determine which decimal sign and thousand separator are currently being used.",
    "arguments": [
      {
        "type": "ref string",
        "name": "decimal$",
        "description": "The current decimal sign will be returned in this string."
      },
      {
        "type": "ref string",
        "name": "grouping$",
        "description": "The current thousand separator will be returned in this string."
      }
    ],
    "returnValue": "0 The returned decimal sign and thousand separator have the original, user defined, values. 1 The returned decimal sign and thousand separator have been set with the function set.numformat.symbols()",
    "category": "functions_formatting_io"
  },
  "formatting input and output - overview and synopsis": {
    "name": "Formatting input and output - overview and synopsis",
    "type": "function",
    "syntax": "function Formatting input and output - overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_formatting_io"
  },
  "reset.numformat.symbols": {
    "name": "reset.numformat.symbols",
    "type": "function",
    "syntax": "function void reset.numformat.symbols ()",
    "description": "Reset the decimal sign and thousand separator to the user defined values. The user defined settings will be used from this moment on for all formatted numbers.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_formatting_io"
  },
  "set.numformat.symbols": {
    "name": "set.numformat.symbols",
    "type": "function",
    "syntax": "function void set.numformat.symbols (string decimal(1), string grouping(1))",
    "description": "Set the decimal sign and thousand separator. These settings will be used from this moment on for all formatted numbers.",
    "arguments": [
      {
        "type": "string",
        "name": "decimal(1)",
        "description": "The character to be used as decimal sign."
      },
      {
        "type": "string",
        "name": "grouping(1)",
        "description": "The character to be used as thousand separator."
      }
    ],
    "returnValue": "",
    "category": "functions_formatting_io"
  },
  "sprintf$": {
    "name": "sprintf$",
    "type": "function",
    "syntax": "function string sprintf$ (string format [, void ...])",
    "description": "This formats a string and returns the formatted string. The format argument contains zero or more ordinary characters and substitution symbols. The ordinary characters are copied directly to the output string. The substitution symbols specify formats for the values specified in the expression arguments and are substituted by these formatted values.",
    "arguments": [
      {
        "type": "string",
        "name": "format",
        "description": "contains zero or more ordinary characters and substitution symbols"
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "One or more expressions to be replaced in the format Implicit conversion of the input value is performed from its original type to the type expected according to the corresponding substitution symbol."
      }
    ],
    "returnValue": "The formatted string. If you specify an invalid format, sprintf$() returns a percentage character [%].",
    "category": "functions_formatting_io"
  },
  "string.scan": {
    "name": "string.scan",
    "type": "function",
    "syntax": "function long string.scan (string value, string format [, void ...])",
    "description": "This scans an input string ( value ) for one or more fields and stores each individual field found in the first available variable argument. The format argument contains conversion symbols that the function uses to interpret the input string and retrieve the individual field values. The conversion symbols indicate the types of values expected:",
    "arguments": [
      {
        "type": "string",
        "name": "value",
        "description": "Input string"
      },
      {
        "type": "string",
        "name": "format",
        "description": "contains zero or more ordinary characters and substitution symbols"
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "References to variables to which the values scanned from the string must be assigned. For each substitution symbol in the format string, implicit conversion of the currently matched sub-string of the input string to the type of the corresponding reference argument is performed. Typical (but not enforced) usage is to supply a reference variable of type string for conversion symbol %s, a reference variable of type double for conversion symbol %f and a reference variable of type long for conversion symbol %d."
      }
    ],
    "returnValue": "The function returns the number of scanned fields.",
    "category": "functions_formatting_io"
  },
  "vsprintf$": {
    "name": "vsprintf$",
    "type": "function",
    "syntax": "function string vsprintf$ (string format [, void ...])",
    "description": "This acts the same as sprintf$() , except that the arguments to be substituted for the substitution symbols in the format argument are not known until run time.",
    "arguments": [
      {
        "type": "string",
        "name": "format",
        "description": "contains zero or more ordinary characters and substitution symbols"
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "One or more expressions to be replaced in the format"
      }
    ],
    "returnValue": "",
    "category": "functions_formatting_io"
  },
  "add.sync.fields": {
    "name": "add.sync.fields",
    "type": "function",
    "syntax": "function void add.sync.fields (const string satelliteSessionCode, const string ...)",
    "description": "This function maps a variable in the multi-main table controller session to a fields in the satellite session. This variable must be declared as external.",
    "arguments": [
      {
        "type": "const string",
        "name": "satelliteSessionCode",
        "description": "The session code of the satellite."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Pairs of arguments of the form [const string variableName, const string satelliteField]."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "add.sync.fields.nokey": {
    "name": "add.sync.fields.nokey",
    "type": "function",
    "syntax": "function void add.sync.fields.nokey (const string satelliteSessionCode, const string ...)",
    "description": "This function maps a variable in the multi-main table controller session to a variable in the session. Both of these variables must be declared as external.",
    "arguments": [
      {
        "type": "const string",
        "name": "satelliteSessionCode",
        "description": "The session code of the satellite."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Pairs of arguments of the form [const string controllerVariableName, const string satelliteVariableName]."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "add.sync.fields.once": {
    "name": "add.sync.fields.once",
    "type": "function",
    "syntax": "function void add.sync.fields.once (const string satelliteSessionCode, const string ...)",
    "description": "This function maps a variable in the multi-main table controller session to a fields in the satellite session. This variable must be declared as external.",
    "arguments": [
      {
        "type": "const string",
        "name": "satelliteSessionCode",
        "description": "The session code of the satellite."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Pairs of arguments of the form [const string variableName, const string satelliteField]."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "add.variable.to.defaults": {
    "name": "add.variable.to.defaults",
    "type": "function",
    "syntax": "function void add.variable.to.defaults (string var_name, long var_type)",
    "description": "Save other variables in the user defaults which are not on the form. All form fields are stored automatically in the user�s defaults when the save.defaults command is executed.",
    "arguments": [
      {
        "type": "string",
        "name": "var_name",
        "description": "The name of the variable to be added, this must be declared as an external variable in the script. To save a particular element of an array variable to the user default, append the element number (in parentheses) to the variable name. The element number must be an integer, formatted as a string. It cannot be a variable. For example: �a_array(5)�."
      },
      {
        "type": "long",
        "name": "var_type",
        "description": "The database type of the variable to be added."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "add.view.field": {
    "name": "add.view.field",
    "type": "function",
    "syntax": "function void add.view.field (long index.nr, const string fname)",
    "description": "Deprecated. This function is supported for compatibility reasons, do not use this function anymore but use for conditional view-fields remove.field.from.view() .",
    "arguments": [
      {
        "type": "long",
        "name": "index.nr",
        "description": "The index identifier. If this is 0, the field is not associated with any index. It is always a view field."
      },
      {
        "type": "const string",
        "name": "fname",
        "description": "The name of the form field to be added. To specify a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "blank.all": {
    "name": "blank.all",
    "type": "function",
    "syntax": "function void blank.all ()",
    "description": "This clears all display fields and input fields on the current form. Display only and input only fields (that is, display and input fields that are not included in the form�s TAB sequence) are not cleared.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "change.dal.field": {
    "name": "change.dal.field",
    "type": "function",
    "syntax": "function void change.dal.field (string field, void value)",
    "description": "Changes the value of the given table field and calls the DAL Layer to update any dependent fields. Afterwards, the UI is updated.",
    "arguments": [
      {
        "type": "string",
        "name": "field",
        "description": "The name of the field to change, in the format \"fieldname\" or \"fieldname(element)\""
      },
      {
        "type": "void",
        "name": "value",
        "description": "the value to assign to the field"
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "change.field.label": {
    "name": "change.field.label",
    "type": "function",
    "syntax": "function long change.field.label (const string fname, long element, const string label1 [, const string label2] [, const string label3])",
    "description": "Use this to set the label for a specified field. A field can have up to three lines of text (label-lines). The new label-line(s) replace the current label-line(s). The function requires that the specified field already has a (dummy) label in the form-definition. When the field is not in the grid, the label in the form-definition should have at least the same number of label-lines, as specified with this function.",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The name of the field whose label must be set."
      },
      {
        "type": "long",
        "name": "element",
        "description": "For an array field, use this to specify the array element for which you want to set the label. For multi-currency fields the element number must be -1."
      },
      {
        "type": "const string",
        "name": "label1",
        "description": "The first (top) label-line."
      },
      {
        "type": "[const string",
        "name": "label2 ]",
        "description": "The second label-line. (optional)"
      },
      {
        "type": "[const string",
        "name": "label3 ]",
        "description": "The third label-line. (optional)"
      }
    ],
    "returnValue": "0 success -1 session is not dynamic -2 field not found",
    "category": "functions_form_and_form_field_operations"
  },
  "change.group.label": {
    "name": "change.group.label",
    "type": "function",
    "syntax": "function long change.group.label (const long groupId, const string label)",
    "description": "Use this to set the label for a specified group. The new label replace the current label. The function requires that the specified group already has a (dummy) label in the form-definition.",
    "arguments": [
      {
        "type": "const long",
        "name": "groupId",
        "description": "The Id of the group whose label must be set."
      },
      {
        "type": "const string",
        "name": "label",
        "description": "The new label text."
      }
    ],
    "returnValue": "0 success -1 session is not dynamic -2 group not found",
    "category": "functions_form_and_form_field_operations"
  },
  "change.picture": {
    "name": "change.picture",
    "type": "function",
    "syntax": "function long change.picture (const string fname, const string icon [, const string absolute.file])",
    "description": "Static pictures stored on the server can be displayed on a form. Pictures can be added to the form using the DFE. For display of an icon, the picture must be one of the pictures in the Icon Group \"form_<pp>\", where pp is the package-code of the picture's session. For display of an image from a local file on the server, the optional argument absolute.file must be filled.",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The name of the field whose picture must be set."
      },
      {
        "type": "const string",
        "name": "icon",
        "description": "Name of the icon in icongroup \"form_pp\" where 'pp' is the package-code of the form."
      },
      {
        "type": "[const string",
        "name": "absolute.file ]",
        "description": "The file name (including the path) in which a picture is stored. The picture being displayed must be of type .gif when displaying in Worktop. Webtop, LN-Ui and later supports .gif, .jpg, .png. When the file name is passed as an argument, the icon argument is ignored."
      }
    ],
    "returnValue": "0 succes -1 session is not dynamic -2 field not found -3 field not a picture field",
    "category": "functions_form_and_form_field_operations"
  },
  "change.satellite.label": {
    "name": "change.satellite.label",
    "type": "function",
    "syntax": "function void change.satellite.label (const string session.code, const string description)",
    "description": "Use this to change the text shown on the tab of a satellite session.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "The session code of the satellite."
      },
      {
        "type": "const string",
        "name": "description",
        "description": "The new text to show on the tab of the satellite."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "check.all.input": {
    "name": "check.all.input",
    "type": "function",
    "syntax": "function void check.all.input ()",
    "description": "This executes all check.input subsections (if any) included in the program script. When an input error is detected, the choice.again() function is automatically executed. The check.all.input function doesn't work for array fields.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "choice.again": {
    "name": "choice.again",
    "type": "function",
    "syntax": "function void choice.again ()",
    "description": "This cancels execution of a standard command and transfers control to the 4GL engine . Statements programmed after this function will never be executed. You can call this function during execution of a standard command. You can also call the function in field sections, as these are called indirectly during execution of some commands.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "defaults.saved": {
    "name": "defaults.saved",
    "type": "function",
    "syntax": "function boolean defaults.saved ()",
    "description": "Determines if there are saved defaults for the current user/company/session combination.",
    "arguments": [],
    "returnValue": "FALSE user defaults not found TRUE user defaults found",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.checkmark": {
    "name": "disable.checkmark",
    "type": "function",
    "syntax": "function void disable.checkmark (string field [,occurrence],...)",
    "description": "This disables single-occurrence and multi-occurrence checkmarks on a form.",
    "arguments": [
      {
        "type": "string",
        "name": "field [,occurrence],...",
        "description": "This identifies the checkbox field to be disabled. For array fields you can append suffixes to the field name to indicate the particular element or segment to be disabled. If you omit these suffixes, all elements/segments are disabled. To disable a particular element of an array field, append the element number (in parentheses) to the field name. The element number must be an integer, formatted as a string. It cannot be a variable. For example: \"tfmod100.perd(10)\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.commands": {
    "name": "disable.commands",
    "type": "function",
    "syntax": "function void disable.commands (const string command, const string ...)",
    "description": "This disables the specified standard and/or form command(s). Standard commands are identified by their Standard commands . Form commands are identified either by a function name, a session code, or a menu code.",
    "arguments": [
      {
        "type": "const string",
        "name": "command",
        "description": "Standard and/or form command(s). Standard commands are identified by their commandIDs. Form commands are identified either by a function name, a session code, or a menu code."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.fields": {
    "name": "disable.fields",
    "type": "function",
    "syntax": "function void disable.fields ( [long mode], string field [,occurrence],...)",
    "description": "This disables single-occurrence and multi-occurrence fields on a form.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This is an optional argument. It has two possible values: DISABLE This is the default mode and does not need to be specified. READONLY The field(s) become read-only fields that cannot be edited by the user."
      },
      {
        "type": "string",
        "name": "field [,occurrence],...",
        "description": "This identifies the field to be disabled. For a single-occurrence field, this is the field name. For a multioccurrence field, this can be either the field name or the field name followed by an occurrence number (depending on whether you wish to disable all occurrences of the field or only one particular occurrence). For array fields, UTC fields, and segmented fields, you can append suffixes to the field name to indicate the particular element or segment to be disabled. If you omit these suffixes, all elements/segments are disabled. To disable a particular element of an array field, append the element number (in parentheses) to the field name. The element number must be an integer, formatted as a string. It cannot be a variable. For example: \"tfmod100.perd(10)\". To disable only the date or time element of a UTC field, append either .date or .time to the field name. For example: \"ttadv300.cdat.time\". To disable a particular segment of a segmented field, append .segment.segment_id to the field name. For example: \"tiitm001.item.segment.1\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.group": {
    "name": "disable.group",
    "type": "function",
    "syntax": "function void disable.group (long group.nr [, long type] [, long occurrence])",
    "description": "This disables all the fields of the specified (dynamic) group. See disable.fields() .",
    "arguments": [
      {
        "type": "long",
        "name": "group.nr",
        "description": "The group number."
      },
      {
        "type": "[long",
        "name": "type ]",
        "description": "Type."
      },
      {
        "type": "[long",
        "name": "occurrence ]",
        "description": "The occurrence."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.pagemode": {
    "name": "disable.pagemode",
    "type": "function",
    "syntax": "function void disable.pagemode ()",
    "description": "This disables pagemode for this session, even when the user runs in pagemode.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.personalize.view": {
    "name": "disable.personalize.view",
    "type": "function",
    "syntax": "function void disable.personalize.view ()",
    "description": "This disables the personalize view option.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.quick.flow": {
    "name": "disable.quick.flow",
    "type": "function",
    "syntax": "function void disable.quick.flow (const string frmcmd, const string ...)",
    "description": "This function can be used in e.g. the after.choice of choice.mark.occur to disable the quick.flow for one or more form commands. In this way the application script can decide to disable quick.flow based on values in the marked record.",
    "arguments": [
      {
        "type": "const string",
        "name": "frmcmd",
        "description": "Form command(s). Form commands are identified either by a function name, a session code, or a menu code."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.satellite": {
    "name": "disable.satellite",
    "type": "function",
    "syntax": "function void disable.satellite (const string session.code)",
    "description": "This disables the specified satellite. The TAB on which the satellite is shown will become disabled. When this TAB is currently active, another TAB will be selected. Initially all satellite TAB buttons are enabled.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "The index identifier. If this is 0, the field is not associated with any index. It is always a view field."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "disable.zoom.buttons": {
    "name": "disable.zoom.buttons",
    "type": "function",
    "syntax": "function void disable.zoom.buttons (string field [,occurrence],...)",
    "description": "This disables single-occurrence and multi-occurrence zoom buttons on a form.",
    "arguments": [
      {
        "type": "string",
        "name": "field [,occurrence],...",
        "description": "This identifies the zoom button to be disabled. For a single-occurrence field, this is the field name. For a multioccurrence field, this can be either the field name or the field name followed by an occurrence number (depending on whether you wish to disable all occurrences of the zoom button or only one particular occurrence). For array fields, UTC fields, and segmented fields, you can append suffixes to the field name to indicate the particular zoom button of the element or segment to be disabled. If you omit these suffixes, all zoom buttons of all elements/segments are disabled. To disable the zoom button of a particular element of an array field, append the element number (in parentheses) to the field name. The element number must be an integer, formatted as a string. It cannot be a variable. For example: \"tfmod100.perd(10)\". To disable only the zoom button of the date or time element of a UTC field, append either .date or .time to the field name. For example: \"ttadv300.cdat.time\". To disable the zoom button of a particular segment of a segmented field, append .segment.segment_id to the field name. For example: \"tiitm001.item.segment.1\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display.all": {
    "name": "display.all",
    "type": "function",
    "syntax": "function void display.all ()",
    "description": "Use this function to display all fields on a form. Usually, the 4GL engine displays fields automatically, either when the form is opened or when data in a related input field is changed. However, there are situations when you need to use these functions to display fields. For example, to display fields that are not in the input field TAB sequence, or to send data to the form during batch processes.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display.curr.occ": {
    "name": "display.curr.occ",
    "type": "function",
    "syntax": "function void display.curr.occ ()",
    "description": "Use this function to display all fields of the current occurrence on a form. Usually, the 4GL engine displays fields automatically, either when the form is opened or when data in a related input field is changed. However, there are situations when you need to use these functions to display fields. For example, to display fields that are not in the input field TAB sequence, or to send data to the form during batch processes.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display.fld": {
    "name": "display.fld",
    "type": "function",
    "syntax": "function void display.fld (long occurrence, string field)",
    "description": "Use this function to display a specified field of a specific occurrence on a form. Usually, the 4GL engine displays fields automatically, either when the form is opened or when data in a related input field is changed. However, there are situations when you need to use these functions to display fields. For example, to display stand-alone fields, to display fields that are not in the input field TAB sequence, or to send data to the form during batch processes.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence for which the field(s) are to be displayed. You can use the predefined variable actual.occ here. This always contains the number of the current occurrence."
      },
      {
        "type": "string",
        "name": "field",
        "description": "Indicates the field to be displayed. This can be the field number or a string containing the field name. For example: display.fld( actual.occ, \"pctstqqq.item\" )"
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display": {
    "name": "display",
    "type": "function",
    "syntax": "function void display (string field)",
    "description": "Use this function to display a specified field on a form. Usually, the 4GL engine displays fields automatically, either when the form is opened or when data in a related input field is changed. However, there are situations when you need to use these functions to display fields. For example, to display stand-alone fields, to display fields that are not in the input field TAB sequence, or to send data to the form during batch processes.",
    "arguments": [
      {
        "type": "string",
        "name": "field",
        "description": "Indicates the field to be displayed. This can be the field number or a string containing the field name. For example: display( \"pctstqqq.item\" )"
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display.occ": {
    "name": "display.occ",
    "type": "function",
    "syntax": "function void display.occ (long occurrence)",
    "description": "Use this function to display the fields of a specific occurrence on a form. Usually, the 4GL engine displays fields automatically, either when the form is opened or when data in a related input field is changed. However, there are situations when you need to use these functions to display fields. For example, to display fields that are not in the input field TAB sequence, or to send data to the form during batch processes.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence for which the field(s) are to be displayed. You can use the predefined variable actual.occ here. This always contains the number of the current occurrence."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "display.total.fields": {
    "name": "display.total.fields",
    "type": "function",
    "syntax": "function void display.total.fields (string fieldname1, void value1, string fieldname2,..., void value2,...)",
    "description": "When a total line is included in a form, this function displays total values for specified fields in the grid. The function takes one or more pairs of arguments. In each pair, the first argument is the field name; the second argument is the total value for that field.",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname1",
        "description": ""
      },
      {
        "type": "void",
        "name": "value1",
        "description": ""
      },
      {
        "type": "string",
        "name": "fieldname2,...",
        "description": ""
      },
      {
        "type": "void",
        "name": "value2,...",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "do.all.occ": {
    "name": "do.all.occ",
    "type": "function",
    "syntax": "function void do.all.occ (function_name function_name, function_name ...)",
    "description": "This executes the specified function for all occurrences on the current form. When included in the before.choice subsection of a choice.update.db section, the function is executed only for occurrences that are pending to be saved.",
    "arguments": [
      {
        "type": "function_name",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "function_name",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "do.occ": {
    "name": "do.occ",
    "type": "function",
    "syntax": "function void do.occ (long occurrence, function_name function_name, function_name ...)",
    "description": "This locks the specified occurrence (delayed lock) and executes the specified function for that occurrence. After the function has been executed all fields of the specified occurrence are redisplayed.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence number."
      },
      {
        "type": "function_name",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "function_name",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "do.occ.without.update": {
    "name": "do.occ.without.update",
    "type": "function",
    "syntax": "function long do.occ.without.update (long occurrence, function_name function_name, function_name ...)",
    "description": "This executes the specified function for a specified occurrence, without any locking or update actions. After the function has been executed all fields of the specified occurrence are redisplayed.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence number."
      },
      {
        "type": "function_name",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "function_name",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "do.selection": {
    "name": "do.selection",
    "type": "function",
    "syntax": "function void do.selection (long mode, function_name function_name [, function_name ...])",
    "description": "This executes the specified function for all marked occurrences. Depending on the mode parameter, this executes either do.occ() or do.occ.without.update() on the currently marked records.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": "The mode. Specify true if do.occ() should be used. This will lock the occurrences. Specify false if do.occ.without.update() should be used."
      },
      {
        "type": "function_name",
        "name": "function_name",
        "description": "The name of the function that must be executed for each marked occurrence. The function must be of type void."
      },
      {
        "type": "[function_name",
        "name": "... ]",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.commands": {
    "name": "enable.commands",
    "type": "function",
    "syntax": "function void enable.commands (const string command, const string ...)",
    "description": "This enables the specified standard and/or form command(s). Standard commands are identified by their Standard commands . Form commands are identified either by a function name, a session code, or a menu code.",
    "arguments": [
      {
        "type": "const string",
        "name": "command",
        "description": "Standard and/or form command(s). Standard commands are identified by their commandIDs. Form commands are identified either by a function name, a session code, or a menu code."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.fields": {
    "name": "enable.fields",
    "type": "function",
    "syntax": "function void enable.fields (string field,...)",
    "description": "This enables the specified single-occurrence and/or multi-occurrence field(s) on a form.",
    "arguments": [
      {
        "type": "string",
        "name": "field,...",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.group": {
    "name": "enable.group",
    "type": "function",
    "syntax": "function void enable.group (long group.nr [, long occurrence])",
    "description": "This enables all the fields of the specified (dynamic) group. See enable.fields() .",
    "arguments": [
      {
        "type": "long",
        "name": "group.nr",
        "description": ""
      },
      {
        "type": "[long",
        "name": "occurrence ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.quick.flow": {
    "name": "enable.quick.flow",
    "type": "function",
    "syntax": "function void enable.quick.flow (const string frmcmd, const string ...)",
    "description": "This function can be used in e.g. the after.choice of choice.mark.occur to disable the quick.flow for one or more form commands. In this way the application script can decide to disable quick.flow based on values in the marked record.",
    "arguments": [
      {
        "type": "const string",
        "name": "frmcmd",
        "description": "Form command(s). Form commands are identified either by a function name, a session code, or a menu code."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.satellite": {
    "name": "enable.satellite",
    "type": "function",
    "syntax": "function void enable.satellite (const string session.code )",
    "description": "This enables the specified satellite. The TAB on which the satellite is shown will become enabled when it was disabled. Initially all satellite TAB buttons are enabled.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.save.on.occ.change": {
    "name": "enable.save.on.occ.change",
    "type": "function",
    "syntax": "function void enable.save.on.occ.change ()",
    "description": "Use this function to force the 4GL Engine to save an occurrence at the time the user selects or moves to another occurrence. Any unsaved changes to the occurrence, will be automatically saved. I.e. the UPDATE.DB choice is executed and the 4GL engine will continue in the previous mode (MODIFY.SET or ADD.SET).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "enable.zoom.buttons": {
    "name": "enable.zoom.buttons",
    "type": "function",
    "syntax": "function void enable.zoom.buttons (string field [,occurrence],...)",
    "description": "This enables single-occurrence and multi-occurrence zoom buttons on a form.",
    "arguments": [
      {
        "type": "string",
        "name": "field [,occurrence],...",
        "description": "This identifies the zoom button to be enabled. For a single-occurrence field, this is the field name. For a multioccurrence field, this can be either the field name or the field name followed by an occurrence number (depending on whether you wish to enable all occurrences of the zoom button or only one particular occurrence). For array fields, UTC fields, and segmented fields, you can append suffixes to the field name to indicate the particular zoom button of the element or segment to be enabled. If you omit these suffixes, all zoom buttons of all elements/segments are enabled. To enable the zoom button of a particular element of an array field, append the element number (in parentheses) to the field name. The element number must be an integer, formatted as a string. It cannot be a variable. For example: \"tfmod100.perd(10)\". To enable only the zoom button of the date or time element of a UTC field, append either .date or .time to the field name. For example: \"ttadv300.cdat.time\". To enable the zoom button of a particular segment of a segmented field, append .segment.segment_id to the field name. For example: \"tiitm001.item.segment.1\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "execute": {
    "name": "execute",
    "type": "function",
    "syntax": "function void execute (long command)",
    "description": "This executes the specified standard command. Normally, standard commands are activated by the user. This function enables applications to execute standard commands without user intervention. This is useful, for example, if you want to display the first record of the main table when a session is started.",
    "arguments": [
      {
        "type": "long",
        "name": "command",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "fields.autocomplete": {
    "name": "fields.autocomplete",
    "type": "function",
    "syntax": "function void fields.autocomplete (boolean try.autocomplete,... [, string fieldname(18)])",
    "description": "Auto-complete is automatically executed by the 4GLE for fields that have a reference path to another table and have a zoom session and has no button and is not segmented. With this function auto-complete can be turned off ( try.autocomplete = FALSE ) and on again ( try.autocomplete = TRUE ).",
    "arguments": [
      {
        "type": "boolean",
        "name": "try.autocomplete,...",
        "description": ""
      },
      {
        "type": "[string",
        "name": "fieldname(18) ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "get.active.satellite": {
    "name": "get.active.satellite",
    "type": "function",
    "syntax": "function string get.active.satellite ( [ref long satellite.nr])",
    "description": "This function returns the active satellite and can be used in UI scripts for multi main table controller sessions to determine which satellite is currently active. It can be used after the first satellite has been started; it cannot be used in the before.program section.",
    "arguments": [
      {
        "type": "[ref long",
        "name": "satellite.nr ]",
        "description": "The number of the active satellite, as defined in MMT Satellite Sessions of the controller session. 0 when the active satellite cannot be determined."
      }
    ],
    "returnValue": "session code when successful, otherwise empty string.",
    "category": "functions_form_and_form_field_operations"
  },
  "get.current.field.label": {
    "name": "get.current.field.label",
    "type": "function",
    "syntax": "function long get.current.field.label (const string fname, long element, ref string label1 to label3)",
    "description": "This retrieves the current label text associated with the specified field. The function is relevant to dynamic forms only.",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The field name."
      },
      {
        "type": "long",
        "name": "element",
        "description": "For an array field, use this to specify the array element for which you wish to retrieve the current label."
      },
      {
        "type": "ref string",
        "name": "label1 to label3",
        "description": "A field can have up to three labels. These return the text of the first, second, and third labels respectively (if they exist)."
      }
    ],
    "returnValue": "&0 label of field found -1 session is not dynamic -2 field not found",
    "category": "functions_form_and_form_field_operations"
  },
  "get.field.label": {
    "name": "get.field.label",
    "type": "function",
    "syntax": "function long get.field.label (const string fname, long element, ref string label1 to label3)",
    "description": "This retrieves the label text associated with the specified field. The function is relevant to dynamic forms only.",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The field name."
      },
      {
        "type": "long",
        "name": "element",
        "description": "For an array field, use this to specify the array element for which you wish to retrieve the label."
      },
      {
        "type": "ref string",
        "name": "label1 to label3",
        "description": "A field can have up to three labels. These return the text of the first, second, and third labels respectively (if they exist)."
      }
    ],
    "returnValue": "&0 label of field found -1 session is not dynamic -2 field not found",
    "category": "functions_form_and_form_field_operations"
  },
  "get.initial.field.label": {
    "name": "get.initial.field.label",
    "type": "function",
    "syntax": "function long get.initial.field.label (const string fname, long element, ref string label1 to label3)",
    "description": "This retrieves the initial label text associated with the specified field. The function is relevant to dynamic forms only.",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The field name."
      },
      {
        "type": "long",
        "name": "element",
        "description": "For an array field, use this to specify the array element for which you wish to retrieve the initial label."
      },
      {
        "type": "ref string",
        "name": "label1 to label3",
        "description": "A field can have up to three labels. These return the text of the first, second, and third labels respectively (if they exist)."
      }
    ],
    "returnValue": "&0 label of field found -1 session is not dynamic -2 field not found",
    "category": "functions_form_and_form_field_operations"
  },
  "get.prev.value": {
    "name": "get.prev.value",
    "type": "function",
    "syntax": "function boolean get.prev.value (long value)",
    "description": "This function retrieves the field's previous value. The previous value is converted to the type of the output parameter.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": ""
      }
    ],
    "returnValue": "true when successful, otherwise false.",
    "category": "functions_form_and_form_field_operations"
  },
  "get.screen.defaults": {
    "name": "get.screen.defaults",
    "type": "function",
    "syntax": "function void get.screen.defaults ()",
    "description": "The save.defaults standard command enables users to save the current field values of a session as the default values for that session. The get.screen.defaults() function displays the default values for all fields on all forms of the current session. It is often used at the start of update or print programs, where the user must specify some parameters before executing the session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "get.user.default": {
    "name": "get.user.default",
    "type": "function",
    "syntax": "function boolean get.user.default (const string session.code, const string field, ref string field.value)",
    "description": "Returns the default value for the passed sessioncode, field combination. The default is retrieved using the current user and current company.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "The sessioncode (i.e. ttaad2500m000) for which the default is wanted."
      },
      {
        "type": "const string",
        "name": "field",
        "description": "The field (i.e. ttaad200.user) for which the default is wanted."
      },
      {
        "type": "ref string",
        "name": "field.value",
        "description": "The current default value for the passed field."
      }
    ],
    "returnValue": "FALSE default not found TRUE default found",
    "category": "functions_form_and_form_field_operations"
  },
  "group.invisible": {
    "name": "group.invisible",
    "type": "function",
    "syntax": "function void group.invisible (long group.nr)",
    "description": "This hides the specified group completely, including all associated fields, labels, and subgroups. The group.nr argument specifies the group number, as defined in the form editor. The group cannot be made visible again.",
    "arguments": [
      {
        "type": "long",
        "name": "group.nr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "hide.selection.column": {
    "name": "hide.selection.column",
    "type": "function",
    "syntax": "function void hide.selection.column ()",
    "description": "This hides the selection column in thin-client sessions completely.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "input.again": {
    "name": "input.again",
    "type": "function",
    "syntax": "function void input.again ()",
    "description": "After input by a user, this forces the user to input the data again. If there is an input error, it is preferable to use set.input.error() in the check.input subsection for the field.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "inputfield.invisible": {
    "name": "inputfield.invisible",
    "type": "function",
    "syntax": "function void inputfield.invisible (string field_name(18),...)",
    "description": "This hides the specified field(s) completely. In dynamic sessions, associated label and button are also hidden. To hide a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\" .",
    "arguments": [
      {
        "type": "string",
        "name": "field_name(18),...",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "inputfield.password": {
    "name": "inputfield.password",
    "type": "function",
    "syntax": "function void inputfield.password (string field_name(18),...)",
    "description": "This causes input to the specified field to be displayed as asterisks (*). To specify a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\" .",
    "arguments": [
      {
        "type": "string",
        "name": "field_name(18),...",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "inputfield.visible": {
    "name": "inputfield.visible",
    "type": "function",
    "syntax": "function void inputfield.visible (string field_name(18))",
    "description": "Use this to redisplay one or more fields made invisible by inputfield.invisible() . To redisplay a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\" .",
    "arguments": [
      {
        "type": "string",
        "name": "field_name(18)",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "is.field.invisible": {
    "name": "is.field.invisible",
    "type": "function",
    "syntax": "function if not is.field.invisible (string field_name(18))",
    "description": "This checks whether a specified field is currently visible or invisible. To specify a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\".",
    "arguments": [
      {
        "type": "string",
        "name": "field_name(18)",
        "description": ""
      }
    ],
    "returnValue": "FALSE field is visible TRUE field is invisible",
    "category": "functions_form_and_form_field_operations"
  },
  "is.field.multi.currency": {
    "name": "is.field.multi.currency",
    "type": "function",
    "syntax": "function boolean is.field.multi.currency (string field_name(18))",
    "description": "This returns whether a specified field is a multi currency field.",
    "arguments": [
      {
        "type": "string",
        "name": "field_name(18)",
        "description": ""
      }
    ],
    "returnValue": "TRUE Field is a multi currency field. FALSE Field is not a multi currency field.",
    "category": "functions_form_and_form_field_operations"
  },
  "is.mmt.controller": {
    "name": "is.mmt.controller",
    "type": "function",
    "syntax": "function boolean is.mmt.controller ()",
    "description": "This function checks whether the current session is running as a multi-main table controller session or not. This function can be usefull when a session can be run in standalone mode or as a controller within a multi-main table session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "is.mmt.satellite": {
    "name": "is.mmt.satellite",
    "type": "function",
    "syntax": "function boolean is.mmt.satellite ()",
    "description": "This function checks whether the current session is running as a multi-main table satellite session or not. This function can be usefull when a session can be run in standalone mode or as a satellite within a multi-main table session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "is.view.field": {
    "name": "is.view.field",
    "type": "function",
    "syntax": "function boolean is.view.field (const string fieldname)",
    "description": "This function can be used to check whether a field is currently a view field. This is useful when, for example, the view can be personalized and a total line only makes sense with a specific field in the view.",
    "arguments": [
      {
        "type": "const string",
        "name": "fieldname",
        "description": "The name of the field to check."
      }
    ],
    "returnValue": "True if the field is currently a view field",
    "category": "functions_form_and_form_field_operations"
  },
  "is.webpart.session": {
    "name": "is.webpart.session",
    "type": "function",
    "syntax": "function boolean is.webpart.session ()",
    "description": "This function checks whether the current session is running as a primary session in a Workspace WebPart. This function can be useful when a session can be run in different modes.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "job.add.field": {
    "name": "job.add.field",
    "type": "function",
    "syntax": "function void job.add.field (string fld_name [, long fld_element] [, long fld_type] [, string fld_descr])",
    "description": "Save other fields in the jobdata which are not on the form. All form fields are stored in the jobdata.",
    "arguments": [
      {
        "type": "string",
        "name": "fld_name",
        "description": "The name of the field to be added, this must be declared as an external variable in the script."
      },
      {
        "type": "[long",
        "name": "fld_element ]",
        "description": "Use this to specify a particular array element to be saved. For simple fields element can be omitted or set to 1."
      },
      {
        "type": "[long",
        "name": "fld_type ]",
        "description": "The database type of the field to be added to be saved. When this function is called for a field of type DB.DATE or DB.TIME a question is asked to the user whether a relative or absolute date/time value must be saved. Note: this question is skipped when: 1) external variable job.skip.date.question is true (absolute values are saved) 2) this question was answered by the user with \"no to all\" or \"yes to all\" before."
      },
      {
        "type": "[string",
        "name": "fld_descr ]",
        "description": "Use this to specify the description shown in the question for relative or absolute date/time."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "make.current": {
    "name": "make.current",
    "type": "function",
    "syntax": "function void make.current ()",
    "description": "This reads the current main table record and displays it on screen. Calling this function is similar to calling execute(find.data), except that if the specified record is not present, make.current() does not read the next record.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "mark.occ": {
    "name": "mark.occ",
    "type": "function",
    "syntax": "function void mark.occ (long occurence)",
    "description": "This marks the specified occurrence with a reverse bar, makes the marked record the current record in the database, and sets the predefined variable actual.occ to the marked occurrence.",
    "arguments": [
      {
        "type": "long",
        "name": "occurence",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "occ.independent.view.field": {
    "name": "occ.independent.view.field",
    "type": "function",
    "syntax": "function void occ.independent.view.field (string field.name)",
    "description": "This defines the specified field as occurrence independent. This means that its value is not stored in one of the records that is shown in the grid. An example is an order total field that is shown in the grid. Another example is a field that is used to filter out records.",
    "arguments": [
      {
        "type": "string",
        "name": "field.name",
        "description": "The name of the field that must be defined as occurrence independent."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "on.old.occ": {
    "name": "on.old.occ",
    "type": "function",
    "syntax": "function void on.old.occ (const string function_name, const string ...)",
    "description": "This executes the specified function for the current occurrence, using the old values of the record. The record must have been previously modified.",
    "arguments": [
      {
        "type": "const string",
        "name": "function_name",
        "description": "The name of the function that must be executed. The function must be of type void."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "form and form field operations overview": {
    "name": "Form and form field operations overview",
    "type": "function",
    "syntax": "function Form and form field operations overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "print.const": {
    "name": "print.const",
    "type": "function",
    "syntax": "function void print.const ()",
    "description": "This displays a specified constant string value in the current form field. The current value of the database field is not affected.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "publish.webpart.message": {
    "name": "publish.webpart.message",
    "type": "function",
    "syntax": "function void publish.webpart.message (const string type, long fromNode [, long toNode])",
    "description": "Sends a message to the Companyon shell, where it is passed on to any webparts registered to this message type.",
    "arguments": [
      {
        "type": "const string",
        "name": "type",
        "description": "The message type."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "refresh.all.occs": {
    "name": "refresh.all.occs",
    "type": "function",
    "syntax": "function void refresh.all.occs ()",
    "description": "This re-reads all records that are currently on the screen and refreshes them (after all processes are idle).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "refresh.curr.occ": {
    "name": "refresh.curr.occ",
    "type": "function",
    "syntax": "function void refresh.curr.occ ()",
    "description": "This reads the current record and refreshes it on screen. All references on the form are read again. For example, in the case of a zoom from a field to a session where the record can be modified, calling refresh.curr.occ() refreshes the occurrence on the parent form also.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "refresh.total.line": {
    "name": "refresh.total.line",
    "type": "function",
    "syntax": "function void refresh.total.line ()",
    "description": "This triggers the 4GL-Engine to execute the program section: on.display.total.line . This section is not called directly but after all other sections have been executed. This function can be usefull when the total line must be updated immediately after a user action or a change of a field value. When this function is not used, the program section on.display.total.line is only called after reading a new set of records from the database.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "register.webpart.handler": {
    "name": "register.webpart.handler",
    "type": "function",
    "syntax": "function void register.webpart.handler (const string type, const string handler)",
    "description": "Registers a handler for the specified message type. When a message of this type is received from a webpart the specified function is called.",
    "arguments": [
      {
        "type": "const string",
        "name": "type",
        "description": "The message type."
      },
      {
        "type": "const string",
        "name": "handler",
        "description": "The name of the function that should be called. This function must be defined in the script that calls the register.webpart.handler function."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "remove.field.from.view": {
    "name": "remove.field.from.view",
    "type": "function",
    "syntax": "function void remove.field.from.view (const string fname)",
    "description": "The view fields for a dynamic session are determined by the view-property of a field in the DFE or, in case of dynamic index switching, by the view column in the Available Indices by Session session. You can use this function to conditionally remove a field from the view-area. e.g. Based on the current index (the predefined variable session.current.index ).",
    "arguments": [
      {
        "type": "const string",
        "name": "fname",
        "description": "The name of the form field to be removed from the view. To specify a particular element of an array field, append the element number (in parentheses) to the field name. For example: \"ttadv301.labl(2)\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "remove.form.commands": {
    "name": "remove.form.commands",
    "type": "function",
    "syntax": "function void remove.form.commands (string command,...)",
    "description": "This removes the specified form command(s). Form commands are identified either by a function name or a session code. There is no way to restore or create a new form command.",
    "arguments": [
      {
        "type": "string",
        "name": "command,...",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "remove.mark": {
    "name": "remove.mark",
    "type": "function",
    "syntax": "function void remove.mark ()",
    "description": "This function clears the selection.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "remove.quick.flow": {
    "name": "remove.quick.flow",
    "type": "function",
    "syntax": "function void remove.quick.flow (const string frmcmd, const string ...)",
    "description": "This function can be used in the after.form.read section to remove the quick.flow support for one or more form commands. In this way the application script can decide to not support quick.flow based on a paremaeter.",
    "arguments": [
      {
        "type": "const string",
        "name": "frmcmd",
        "description": "Form command(s). Form commands are identified either by a function name, a session code, or a menu code."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "remove.session.index": {
    "name": "remove.session.index",
    "type": "function",
    "syntax": "function long remove.session.index (long session.index)",
    "description": "This removes the specified session index. Session index is identified by a session index number as defined by the session.",
    "arguments": [
      {
        "type": "long",
        "name": "session.index",
        "description": ""
      }
    ],
    "returnValue": "0 Success. -1 Invalid session Index. Session index should be > 1 -2 Invalid session Index. Not allowed to disable the current index",
    "category": "functions_form_and_form_field_operations"
  },
  "satellite.invisible": {
    "name": "satellite.invisible",
    "type": "function",
    "syntax": "function void satellite.invisible (const string session.code)",
    "description": "This hides the specified satellite. This function can only be used in section: after.form.read .",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "set.checked.command": {
    "name": "set.checked.command",
    "type": "function",
    "syntax": "function void set.checked.command (string command, boolean checked)",
    "description": "Use this to check or uncheck a command in the menubar or the toolbar. This can be used to indicate to the user that the command is activated. Example:",
    "arguments": [
      {
        "type": "string",
        "name": "command",
        "description": "The name of the form command that must appear checked or unchecked."
      },
      {
        "type": "boolean",
        "name": "checked",
        "description": "Specify TRUE if you want the command to appear checked. Specify FALSE to show the command unchecked."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "set.fields.default": {
    "name": "set.fields.default",
    "type": "function",
    "syntax": "function void set.fields.default ()",
    "description": "It is possible to define default values for form fields with the form editor. For all fields of the current form, this function sets the corresponding script variables to the default form values.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "set.list.values.for.field": {
    "name": "set.list.values.for.field",
    "type": "function",
    "syntax": "function void set.list.values.for.field (const string field.name.string, long no.list.values, const string list.values(,))",
    "description": "This fills a listbox field or a combobox field with a specified set of values. The field must be a string type field, and the appearance must be set to Dropdown Listbox or Dropdown Combobox in the DFE.",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name.string",
        "description": "The name of the string field. For example, \"prog.code\". For an array field, include the array element. For example, \"prog.code(5)\"."
      },
      {
        "type": "long",
        "name": "no.list.values",
        "description": "Number of values present in the list.values array"
      },
      {
        "type": "const string",
        "name": "list.values(,)",
        "description": "A string array that contains all values that need to be placed in the listbox field. It should contain the number of entries as indicated by the no.list.values argument."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "set.starting.satellite": {
    "name": "set.starting.satellite",
    "type": "function",
    "syntax": "function void set.starting.satellite (const string satelliteSessionCode)",
    "description": "This function specifies which satellite should be active when the multi-main table session is started.",
    "arguments": [
      {
        "type": "const string",
        "name": "satelliteSessionCode",
        "description": "The session code of the satellite."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "standard.commands.off": {
    "name": "standard.commands.off",
    "type": "function",
    "syntax": "function void standard.commands.off (long command, ...)",
    "description": "In session Standard Commands (ttadv3110s000) you can define which standard commands are available to the user. E.g. you can permanently disable the File | New (ADD.SET) command by unchecking its check box.",
    "arguments": [
      {
        "type": "long",
        "name": "command, ...",
        "description": "The IDs of one or more standard commands that must be turned off. E.g. ADD.SET, MODIFY.SET, DEF.FIND."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "synchronize.satellite": {
    "name": "synchronize.satellite",
    "type": "function",
    "syntax": "function void synchronize.satellite (const string [satelliteSessionCode]*)",
    "description": "Calling this function triggers a synchronization between the header and the active satellite. Since the controller does not know which satellite is currently active, the optional argument is used to indicate for which satellites a synchronization is needed. If the active satellite is not one of the specified satellites, no synchronization is performed. If no arguments are passed a synchronization is performed regardless of which satellite is active.",
    "arguments": [
      {
        "type": "const string",
        "name": "[satelliteSessionCode]*",
        "description": "The session codes of the satellites that should be synchronized, separated by commas."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "form and form field operations synopsis": {
    "name": "Form and form field operations synopsis",
    "type": "function",
    "syntax": "function Form and form field operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "to.field": {
    "name": "to.field",
    "type": "function",
    "syntax": "function void to.field (field field [, long occ])",
    "description": "This transfers control of the 4GL engine to the specified field after input to or display of the current field. This overrides the TAB sequence of the form. You can specify the field by using the field number or a string containing the field name.",
    "arguments": [
      {
        "type": "field",
        "name": "field",
        "description": ""
      },
      {
        "type": "[long",
        "name": "occ ]",
        "description": "The occurrence number. (optional) This parameter is available from Tools Interface Version (TIV) TIV 1900 ."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "to.form": {
    "name": "to.form",
    "type": "function",
    "syntax": "function void to.form (long form_number)",
    "description": "This forces a switch from the current form to the specified form. The form_number argument must specify an existing form in the session, and must be in the range one to the value of the predefined variable number.forms . During the switch operation, the 4GL form sections subsection of the current form is executed and the 4GL form sections and 4GL form sections subsections of the new form are executed. The init.form subsection is executed only the first time a form becomes current.",
    "arguments": [
      {
        "type": "long",
        "name": "form_number",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "to.group": {
    "name": "to.group",
    "type": "function",
    "syntax": "function boolean to.group (long group_number)",
    "description": "Use this to make the first form on which the specified group occurs the current form. This function is relevant to dynamic forms only.",
    "arguments": [
      {
        "type": "long",
        "name": "group_number",
        "description": ""
      }
    ],
    "returnValue": "true success false group not found",
    "category": "functions_form_and_form_field_operations"
  },
  "to.satellite": {
    "name": "to.satellite",
    "type": "function",
    "syntax": "function void to.satellite (long selected.tab)",
    "description": "This function can be used in UI scripts for multi main table controller sessions to switch to another satellite session. It can be used after the form definition has been read; it cannot be used in the before.program section.",
    "arguments": [
      {
        "type": "long",
        "name": "selected.tab",
        "description": "The selected tab: when numeric: the index of the tab to select. when alfabetic: the name of the satellite session."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "unlink.from.maintable": {
    "name": "unlink.from.maintable",
    "type": "function",
    "syntax": "function void unlink.from.maintable (string field, ...)",
    "description": "By default, when a session has a maintable, all form fields are treated as if they have a link to the maintable. When such fields are modified by the user, the maintable's update.status is set and the current record is marked as changed.",
    "arguments": [
      {
        "type": "string",
        "name": "field, ...",
        "description": "One or more fields to unlink from the maintable. Use the format \"field\" or \"field(element)\"."
      }
    ],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "update.occ": {
    "name": "update.occ",
    "type": "function",
    "syntax": "function void update.occ ()",
    "description": "The 4GL engine automatically detects changes a user makes to a field. However, it cannot detect changes to field values made in the program script. When you modify a field of the main table in the program script, you must call update.occ() to lock the record (delayed lock) and to switch on the update.status flag of the 4GL engine . This ensures when that the database is next updated, the modifications are saved to the database. The database update action can be initiated either by the user or within the script (use execute(update.db)).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_form_and_form_field_operations"
  },
  "example": {
    "name": "Example",
    "type": "function",
    "syntax": "function Example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "example structure availability": {
    "name": "Example structure availability",
    "type": "function",
    "syntax": "function Example structure availability()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_gantt_and_schedule_charts"
  },
  "getting started": {
    "name": "Getting started",
    "type": "function",
    "syntax": "function Getting started()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "gantt and schedule chart overview": {
    "name": "Gantt and Schedule Chart Overview",
    "type": "function",
    "syntax": "function Gantt and Schedule Chart Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.activity.action.performed": {
    "name": "plcm.activity.action.performed",
    "type": "function",
    "syntax": "function boolean plcm.activity.action.performed (const string activity.id)",
    "description": "Callback-function for when the activity is double-click upon.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id",
        "description": "ID of the activity."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.activity.deleted": {
    "name": "plcm.activity.deleted",
    "type": "function",
    "syntax": "function boolean plcm.activity.deleted (const string activity.id)",
    "description": "Callback-function for when the activity is about to be deleted in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id",
        "description": "ID of the activity."
      }
    ],
    "returnValue": "True, when the delete is allowed. False, when the delete is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.activity.moved": {
    "name": "plcm.activity.moved",
    "type": "function",
    "syntax": "function boolean plcm.activity.moved (string activity.id, long start.date, long end.date)",
    "description": "Callback-function for when the activity end-date and/or start-date have been changed in the UI.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "start.date",
        "description": "New start date."
      },
      {
        "type": "long",
        "name": "end.date",
        "description": "New end date."
      }
    ],
    "returnValue": "True, when the move is allowed. False, when the move is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.activity": {
    "name": "plcm.add.activity",
    "type": "function",
    "syntax": "function long plcm.add.activity (string parent.activity.id, string activity.id, string activity.name [, long start.date] [, long end.date] [, long completion.percentage])",
    "description": "Adds a child activity to an activity. This will cause the parent activity to be displayed as a summary bar.",
    "arguments": [
      {
        "type": "string",
        "name": "parent.activity.id",
        "description": "ID of the parent activity."
      },
      {
        "type": "string",
        "name": "activity.id",
        "description": "Unique ID of the activity."
      },
      {
        "type": "string",
        "name": "activity.name",
        "description": "Name for the activity."
      },
      {
        "type": "[long",
        "name": "start.date ]",
        "description": "Date the activity starts (utc) If a start.date is passed, end.date is mandatory."
      },
      {
        "type": "[long",
        "name": "end.date ]",
        "description": "Date the activity ends (utc)"
      },
      {
        "type": "[long",
        "name": "completion.percentage ]",
        "description": "The completion percentage for the activity (0-100)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.activity.marker": {
    "name": "plcm.add.activity.marker",
    "type": "function",
    "syntax": "function long plcm.add.activity.marker (string activity.id, long icon.id, long date_time, string tooltip, string legend.id)",
    "description": "Adds a marker to an activity. The marker will be visualized by an icon.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "icon.id",
        "description": "Identification of a marker icon. There are 7 icons predefined. Use one of these predefined icons by specifying: PLCM_ICON_TACK PLCM_ICON_TAG PLCM_ICON_UP PLCM_ICON_BOOKMARK PLCM_ICON_PIN PLCM_ICON_STAR PLCM_ICON_CLOCK"
      },
      {
        "type": "long",
        "name": "date_time",
        "description": "The date and time of the marker (utc)."
      },
      {
        "type": "string",
        "name": "tooltip",
        "description": "Tooltip of the marker."
      },
      {
        "type": "string",
        "name": "legend.id",
        "description": "ID of the legend of the marker."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.activity.property": {
    "name": "plcm.add.activity.property",
    "type": "function",
    "syntax": "function long plcm.add.activity.property (string property.id, string property.label)",
    "description": "Adds a property to an activity. The property will be visualized as a column in the table part of the Gantt view.",
    "arguments": [
      {
        "type": "string",
        "name": "property.id",
        "description": "ID of the property. The following property.id's are predefined. You can change the label for these predefined properties. NAME|ID|START|END|RESOURCE Adding a property with id equal to \"TOOLTIP\" will also add a tooltip on the activity."
      },
      {
        "type": "string",
        "name": "property.label",
        "description": "Label (column header) of the property."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.command": {
    "name": "plcm.add.command",
    "type": "function",
    "syntax": "function long plcm.add.command (string command.id, string command.text [, enum ecatg] [, boolean command.checked])",
    "description": "Adds a custom command. This command will appear in the specific menu of the plan chart.",
    "arguments": [
      {
        "type": "string",
        "name": "command.id",
        "description": "Unique ID of the command. If ID equals \"SEPARATOR\", a separator will be added to the specific menu. If a command with this ID has been added before, the command text will be changed."
      },
      {
        "type": "string",
        "name": "command.text",
        "description": "Command text."
      },
      {
        "type": "[enum",
        "name": "ecatg ]",
        "description": "An optional parameter for specifying the category of the command. This parameter is applicable when running in one of the following UI-modes: WEBUI_COMMONUI, HTML_UI or SOHO_XI. If this parameter is not specified while running in one of these three UI-modes, the category Actions will be used by default."
      },
      {
        "type": "[boolean",
        "name": "command.checked ]",
        "description": "An optional parameter for specifying the check mark in front of the command. Specify TRUE if you want the command to appear checked. Specify FALSE to show the command unchecked."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.constraint": {
    "name": "plcm.add.constraint",
    "type": "function",
    "syntax": "function long plcm.add.constraint (string activity.id.from, string activity.id.to, long constraint.type)",
    "description": "Adds a constraint between two activities.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id.from",
        "description": "ID of the from activity."
      },
      {
        "type": "string",
        "name": "activity.id.to",
        "description": "ID of the to activity."
      },
      {
        "type": "long",
        "name": "constraint.type",
        "description": "CONSTRAINT_START_START | CONSTRAINT_START_END | CONSTRAINT_END_START | CONSTRAINT_END_END"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.reservation": {
    "name": "plcm.add.reservation",
    "type": "function",
    "syntax": "function long plcm.add.reservation (string activity.id, string resource.id)",
    "description": "Assigns an activity to a resource.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity to assign."
      },
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the resource to assign the activity to."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.resource": {
    "name": "plcm.add.resource",
    "type": "function",
    "syntax": "function long plcm.add.resource (string parent.resource.id, string resource.id, string resource.name [, long quantity])",
    "description": "Adds a child resource to a resource.",
    "arguments": [
      {
        "type": "string",
        "name": "parent.resource.id",
        "description": "ID of the parent resource."
      },
      {
        "type": "string",
        "name": "resource.id",
        "description": "Unique ID of the resource."
      },
      {
        "type": "string",
        "name": "resource.name",
        "description": "Name for the resource."
      },
      {
        "type": "[long",
        "name": "quantity ]",
        "description": "Optional. Quantity"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.resource.property": {
    "name": "plcm.add.resource.property",
    "type": "function",
    "syntax": "function long plcm.add.resource.property (string property.id, string property.label)",
    "description": "Adds a property to a resource. The property will be visualized as a column in the table part of the Schedule view.",
    "arguments": [
      {
        "type": "string",
        "name": "property.id",
        "description": "ID of the property. The following property.id's are predefined. You can change the label for these predefined properties. NAME|ID|QUANTITY"
      },
      {
        "type": "string",
        "name": "property.label",
        "description": "Label (column header) of the property"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.root.activity": {
    "name": "plcm.add.root.activity",
    "type": "function",
    "syntax": "function long plcm.add.root.activity (string root.activity.id, string root.activity.name)",
    "description": "Call this function only once. The root activity will serve as highest level parent for all other activities. Therefore it will be displayed as summary bar in the Gantt view.",
    "arguments": [
      {
        "type": "string",
        "name": "root.activity.id",
        "description": "Unique ID for the activity."
      },
      {
        "type": "string",
        "name": "root.activity.name",
        "description": "Name for the root activity."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.add.root.resource": {
    "name": "plcm.add.root.resource",
    "type": "function",
    "syntax": "function long plcm.add.root.resource (string root.resource.id, string root.resource.name)",
    "description": "Call this function only once. The root resource will serve as highest level parent for all other resources",
    "arguments": [
      {
        "type": "string",
        "name": "root.resource.id",
        "description": "Unique ID for the resource."
      },
      {
        "type": "string",
        "name": "root.resource.name",
        "description": "Name for the root resource."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.clear": {
    "name": "plcm.clear",
    "type": "function",
    "syntax": "function long plcm.clear ()",
    "description": "Clears the plan chart in order to build up a new schedule.",
    "arguments": [],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.command.performed": {
    "name": "plcm.command.performed",
    "type": "function",
    "syntax": "function long plcm.command.performed (string command.id, const long activities.context.count, const string activities.context(), const long resources.context.count, string resources.context())",
    "description": "Callback-function for when a \"custom' command has been performed in the UI.",
    "arguments": [
      {
        "type": "string",
        "name": "command.id",
        "description": "ID of the command."
      },
      {
        "type": "const long",
        "name": "activities.context.count",
        "description": "Number of items in activities.context() array"
      },
      {
        "type": "const string",
        "name": "activities.context()",
        "description": "Array of activity id's that are selected in the UI."
      },
      {
        "type": "const long",
        "name": "resources.context.count",
        "description": "Number of items in resources.context() array"
      },
      {
        "type": "string",
        "name": "resources.context()",
        "description": "Array of resource id's that are selected in the UI."
      }
    ],
    "returnValue": "None.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.constraint.deleted": {
    "name": "plcm.constraint.deleted",
    "type": "function",
    "syntax": "function boolean plcm.constraint.deleted (const string activity.id.from, const string activity.id.to, const long constraint.type)",
    "description": "Callback-function for when the constraint is about to be deleted in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id.from",
        "description": "ID of the from activity."
      },
      {
        "type": "const string",
        "name": "activity.id.to",
        "description": "ID of the to activity."
      },
      {
        "type": "const long",
        "name": "constraint.type",
        "description": "CONSTRAINT_START_START | CONSTRAINT_START_END | CONSTRAINT_END_START | CONSTRAINT_END_END"
      }
    ],
    "returnValue": "True, when the delete is allowed. False, when the delete is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.create.legend.entry": {
    "name": "plcm.create.legend.entry",
    "type": "function",
    "syntax": "function long plcm.create.legend.entry (string legend.id, long color, string description)",
    "description": "Defines a legend entry. This function must be called before the plcm.start() is called. The legend will be visualized in the underneath the plan chart.",
    "arguments": [
      {
        "type": "string",
        "name": "legend.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "color",
        "description": "One of the following constants: PLCM_RED, PLCM_LIGHTRED, PLCM_BLUE, PLCM_DARKBLUE, PLCM_GREEN, PLCM_LIGHTGREEN, PLCM_ORANGE, PLCM_YELLOW, PLCM_PURPLE, PLCM_BACKGROUND PLCM_BACKGROUND is avialable from Tools Interface Version (TIV) TIV 2140"
      },
      {
        "type": "string",
        "name": "description",
        "description": "The description (meaning) of the legend"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.delete.activity": {
    "name": "plcm.delete.activity",
    "type": "function",
    "syntax": "function long plcm.delete.activity (string activity.id)",
    "description": "Deletes an activity.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity to delete."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.delete.constraint": {
    "name": "plcm.delete.constraint",
    "type": "function",
    "syntax": "function long plcm.delete.constraint (string activity.id.from, string activity.id.to, long constraint.type)",
    "description": "Deletes a constraint between two activities.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id.from",
        "description": "ID of the from activity."
      },
      {
        "type": "string",
        "name": "activity.id.to",
        "description": "ID of the to activity"
      },
      {
        "type": "long",
        "name": "constraint.type",
        "description": "CONSTRAINT_START_START | CONSTRAINT_START_END | CONSTRAINT_END_START | CONSTRAINT_END_END"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.delete.reservation": {
    "name": "plcm.delete.reservation",
    "type": "function",
    "syntax": "function long plcm.delete.reservation (string activity.id, string resource.id)",
    "description": "Deletes a reservation.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity the resource is assigned to."
      },
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the assigned resource."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.delete.resource": {
    "name": "plcm.delete.resource",
    "type": "function",
    "syntax": "function long plcm.delete.resource (string resource.id)",
    "description": "Deletes a resource.",
    "arguments": [
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the resource to delete."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.get.default.availability": {
    "name": "plcm.get.default.availability",
    "type": "function",
    "syntax": "function boolean plcm.get.default.availability ()",
    "description": "Callback-function for the initial setting value of the show availability.",
    "arguments": [],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.get.resource.unavailability": {
    "name": "plcm.get.resource.unavailability",
    "type": "function",
    "syntax": "function void plcm.get.resource.unavailability (const string resource.id(), const long i.start.date, const long i.end.date)",
    "description": "Callback-function when the scope of the view of unavailabilities of the resource is changed in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "resource.id()",
        "description": "Unique ID of the referenced resource."
      },
      {
        "type": "const long",
        "name": "i.start.date",
        "description": "input of the start date of the view for unavailabilities."
      },
      {
        "type": "const long",
        "name": "i.end.date",
        "description": "input of the end date of the view for unavailabilities."
      }
    ],
    "returnValue": "",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.init": {
    "name": "plcm.init",
    "type": "function",
    "syntax": "function long plcm.init (string title, string initial.types [, long options])",
    "description": "This function must be the first to be called, it initializes the global data structures of the plan chart.",
    "arguments": [
      {
        "type": "string",
        "name": "title",
        "description": "The title for the Plan Chart."
      },
      {
        "type": "string",
        "name": "initial.types",
        "description": "Initial type of the chart. Supported types: CHART_TYPE_GANTT, CHART_TYPE_SCHEDULE. Or you can display both by passing CHART_TYPE_GANTT +CHART_TYPE_SCHEDULE."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "When passing both types to the initial.types argument, the default.type argument determines which type will be default shown: STARTUP_CHART_TYPE_GANTT or STARTUP_CHART_TYPE_SCHEDULE,SHOW_COMPLETION_PERCENTAGES,EXPAND_ALL_ROWS,DELETE_NOT_ALLOWED"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.move.activity": {
    "name": "plcm.move.activity",
    "type": "function",
    "syntax": "function long plcm.move.activity (string activity.id, long start.date, long end.date)",
    "description": "Sets a new start/end date for an activity",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity to move."
      },
      {
        "type": "long",
        "name": "start.date",
        "description": "New start.date (utc)"
      },
      {
        "type": "long",
        "name": "end.date",
        "description": "New end date (utc)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.reservation.changed": {
    "name": "plcm.reservation.changed",
    "type": "function",
    "syntax": "function boolean plcm.reservation.changed (const string activity.id., const string old.resource.id, const string new.resource.id)",
    "description": "Callback-function for when a reservation is about to change in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id.",
        "description": "ID of the from activity."
      },
      {
        "type": "const string",
        "name": "old.resource.id",
        "description": "ID of the old assigned resource."
      },
      {
        "type": "const string",
        "name": "new.resource.id",
        "description": "ID of the new assigned resource"
      }
    ],
    "returnValue": "True, when the delete is allowed. False, when the delete is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.reservation.deleted": {
    "name": "plcm.reservation.deleted",
    "type": "function",
    "syntax": "function boolean plcm.reservation.deleted (const string activity.id, const string resource.id)",
    "description": "Callback-function for when the reservation is about to be deleted in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "const string",
        "name": "resource.id",
        "description": "ID of the resource."
      }
    ],
    "returnValue": "True, when the delete is allowed. False, when the delete is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.resource.deleted": {
    "name": "plcm.resource.deleted",
    "type": "function",
    "syntax": "function boolean plcm.resource.deleted (const string resource.id)",
    "description": "Callback-function for when the resource is about to be deleted in the UI.",
    "arguments": [
      {
        "type": "const string",
        "name": "resource.id",
        "description": "ID of the resource."
      }
    ],
    "returnValue": "True, when the delete is allowed. False, when the delete is not allowed.",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.completion.percentage": {
    "name": "plcm.set.activity.completion.percentage",
    "type": "function",
    "syntax": "function long plcm.set.activity.completion.percentage (string activity.id, long completion.percentage)",
    "description": "Change the completion.percentage of an activity.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "completion.percentage",
        "description": "The completion percentage for the activity (0-100)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.end.date": {
    "name": "plcm.set.activity.end.date",
    "type": "function",
    "syntax": "function long plcm.set.activity.end.date (string activity.id, long end.date)",
    "description": "Change the end.date of an activity.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "end.date",
        "description": "New end date for the activity"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.name": {
    "name": "plcm.set.activity.name",
    "type": "function",
    "syntax": "function long plcm.set.activity.name (string activity.id, string name)",
    "description": "Change the name of an activity.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "string",
        "name": "name",
        "description": "New name for the activity"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.property": {
    "name": "plcm.set.activity.property",
    "type": "function",
    "syntax": "function long plcm.set.activity.property (string activity.id, string property.id, string property.value)",
    "description": "Sets an activity property. The property will be visualized in the table part of the Gantt view.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "string",
        "name": "property.id",
        "description": "D of the property. The following property.id's are predefined, and must not be used in this function. NAME|ID|START|END|RESOURCE When using property.id equals \"TOOLTIP\", the tooltip on the activity will also change. When using property.id equals \"SLACK_TOOLTIP\", the tooltip of the slack for the activity will also change."
      },
      {
        "type": "string",
        "name": "property.value",
        "description": "Value of the property"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.start.date": {
    "name": "plcm.set.activity.start.date",
    "type": "function",
    "syntax": "function long plcm.set.activity.start.date (string activity.id, long start.date)",
    "description": "Change the start.date of an activity.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "start.date",
        "description": "New start date for the activity"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.activity.unavailability": {
    "name": "plcm.set.activity.unavailability",
    "type": "function",
    "syntax": "function long plcm.set.activity.unavailability (const string activity.id(), const long no.elements, const long start.date(), const long end.date(), const string description() mb, const string legend.id() mb)",
    "description": "Sets the unavailabilities of an activity. This show the bars of unavailabilities on the background of the row of the activity and provide an insight of the availability of the activity.",
    "arguments": [
      {
        "type": "const string",
        "name": "activity.id()",
        "description": "Unique ID of the referenced activity."
      },
      {
        "type": "const long",
        "name": "no.elements",
        "description": "Number of unavailabilities of the activity"
      },
      {
        "type": "const long",
        "name": "start.date()",
        "description": "Array of start dates of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const long",
        "name": "end.date()",
        "description": "Array of end dates of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const string",
        "name": "description() mb",
        "description": "Array of descriptions of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const string",
        "name": "legend.id() mb",
        "description": "Array of legend ID�s of the unavailability. (no.elements occurrences)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.legend.for.activity": {
    "name": "plcm.set.legend.for.activity",
    "type": "function",
    "syntax": "function long plcm.set.legend.for.activity (string activity.id, string legend.id)",
    "description": "Lets the complete activity refer to a legend entry. The activity will get the color of the legend.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "string",
        "name": "legend.id",
        "description": "ID of the legend."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.legend.for.activity.division": {
    "name": "plcm.set.legend.for.activity.division",
    "type": "function",
    "syntax": "function long plcm.set.legend.for.activity.division (string activity.id, string legend.id, long Start.percentage, long End.percentage [, long Num.decimals])",
    "description": "Lets a division of an activity refer to a legend entry. Thedivision will get the color of the legend.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "string",
        "name": "legend.id",
        "description": "ID of the legend."
      },
      {
        "type": "long",
        "name": "Start.percentage",
        "description": "0-99. Start of the division within the activity"
      },
      {
        "type": "long",
        "name": "End.percentage",
        "description": "1-100. End of the division within the activity"
      },
      {
        "type": "[long",
        "name": "Num.decimals ]",
        "description": "0-6. Number of decimals (default 2) to be used in the percentage values (optional)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.resource.name": {
    "name": "plcm.set.resource.name",
    "type": "function",
    "syntax": "function long plcm.set.resource.name (string resource.id, string name)",
    "description": "Change the name of a resource.",
    "arguments": [
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the resource"
      },
      {
        "type": "string",
        "name": "name",
        "description": "New name for the resource"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.resource.property.value": {
    "name": "plcm.set.resource.property.value",
    "type": "function",
    "syntax": "function long plcm.set.resource.property.value (string resource.id, string property.id, string property.value)",
    "description": "Sets a resource property. The property will be visualized in the table part of the Schedule view.",
    "arguments": [
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the resource."
      },
      {
        "type": "string",
        "name": "property.id",
        "description": "ID of the property. The following property.id's are predefined, and must not be used in this function. NAME|ID|QUANTITY"
      },
      {
        "type": "string",
        "name": "property.value",
        "description": "Value of the property"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.resource.quantity": {
    "name": "plcm.set.resource.quantity",
    "type": "function",
    "syntax": "function long plcm.set.resource.quantity (string resource.id, long quantity)",
    "description": "Change the quantity of a resource.",
    "arguments": [
      {
        "type": "string",
        "name": "resource.id",
        "description": "ID of the resource"
      },
      {
        "type": "long",
        "name": "quantity",
        "description": "New quantity for the resource"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.resource.unavailability": {
    "name": "plcm.set.resource.unavailability",
    "type": "function",
    "syntax": "function long plcm.set.resource.unavailability (const string resource.id(), const long no.elements, const long start.date(), const long end.date(), const string description() mb, const string legend.id() mb)",
    "description": "Sets the unavailabilities of an resource. This show the bars of unavailabilities on the background of the row of the activity and provide an insight of the availability of the resource.",
    "arguments": [
      {
        "type": "const string",
        "name": "resource.id()",
        "description": "Unique ID of the referenced resource."
      },
      {
        "type": "const long",
        "name": "no.elements",
        "description": "Number of unavailabilities of the resource"
      },
      {
        "type": "const long",
        "name": "start.date()",
        "description": "Array of start dates of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const long",
        "name": "end.date()",
        "description": "Array of end dates of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const string",
        "name": "description() mb",
        "description": "Array of descriptions of the unavailability. (no.elements occurrences)"
      },
      {
        "type": "const string",
        "name": "legend.id() mb",
        "description": "Array of legend ID�s of the unavailability. (no.elements occurrences)"
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.set.slack.for.activity": {
    "name": "plcm.set.slack.for.activity",
    "type": "function",
    "syntax": "function long plcm.set.slack.for.activity (string activity.id, long start.date, long end.date, string legend.id)",
    "description": "Sets the slack attributes of an activity. The slack will get the color of the legend.",
    "arguments": [
      {
        "type": "string",
        "name": "activity.id",
        "description": "ID of the activity."
      },
      {
        "type": "long",
        "name": "start.date",
        "description": "Start date for the activity slack (utc)."
      },
      {
        "type": "long",
        "name": "end.date",
        "description": "End date for the activity slack (utc)."
      },
      {
        "type": "string",
        "name": "legend.id",
        "description": "ID of the legend for the slack."
      }
    ],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "plcm.start": {
    "name": "plcm.start",
    "type": "function",
    "syntax": "function long plcm.start ()",
    "description": "Activates the plan chart,in other words it takes over control from the application. See also plcm.init() for more information.",
    "arguments": [],
    "returnValue": "0 Success",
    "category": "functions_gantt_and_schedule_charts"
  },
  "synopsis": {
    "name": "Synopsis",
    "type": "function",
    "syntax": "function Synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_gantt_and_schedule_charts"
  },
  "allowed functions": {
    "name": "Allowed functions",
    "type": "function",
    "syntax": "function Allowed functions()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "generic browser framework error codes and return values": {
    "name": "Generic Browser Framework error codes and return values",
    "type": "function",
    "syntax": "function Generic Browser Framework error codes and return values()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.add.header": {
    "name": "gbf.add.header",
    "type": "function",
    "syntax": "function long gbf.add.header (const string object.key(), string object.description() mb, long object.value)",
    "description": "Adds a header to the object tree.",
    "arguments": [
      {
        "type": "const string",
        "name": "object.key()",
        "description": "The key of the object by which it is known in the application."
      },
      {
        "type": "string",
        "name": "object.description() mb",
        "description": "The text that is displayed in the browser to describe the object."
      },
      {
        "type": "long",
        "name": "object.value",
        "description": "The object.value can be used to further identify this object, which may be needed in case the object appears more than once in the tree. This object.value will be returned on subsequent function calls, such as gbf.get.children() or gbf.menu.selected() . Note that a value of 0 means something special, see gbf.update.object()."
      }
    ],
    "returnValue": ">= 0 Successful completion, returned value is the new obj.id GBF.NO.MEMORY Not enough memory GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id, help.function.id or drop.function.id identification GBF.ILL.LENGTH Length of object.key exceeds the stored key length in GBF GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NOT.EXPECTED Function called when GBF did not expect this",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.add.interior": {
    "name": "gbf.add.interior",
    "type": "function",
    "syntax": "function long gbf.add.interior (const string object.key(), string object.description() mb, long object.value)",
    "description": "Adds an interior node to the object tree.",
    "arguments": [
      {
        "type": "const string",
        "name": "object.key()",
        "description": "The key of the object by which it is known in the application."
      },
      {
        "type": "string",
        "name": "object.description() mb",
        "description": "The text that is displayed in the browser to describe the object."
      },
      {
        "type": "long",
        "name": "object.value",
        "description": "The object.value can be used to further identify this object, which may be needed in case the object appears more than once in the tree. This object.value will be returned on subsequent function calls, such as gbf.get.children() or gbf.menu.selected() . Note that a value of 0 means something special, see gbf.update.object()."
      }
    ],
    "returnValue": ">= 0 Successful completion, returned value is the new obj.id GBF.NO.MEMORY Not enough memory GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id, help.function.id or drop.function.id identification GBF.ILL.LENGTH Length of object.key exceeds the stored key length in GBF GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NOT.EXPECTED Function called when GBF did not expect this",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.add.leaf": {
    "name": "gbf.add.leaf",
    "type": "function",
    "syntax": "function long gbf.add.leaf (const string object.key(), string object.description() mb, long object.value)",
    "description": "Adds a leaf node to the object tree.",
    "arguments": [
      {
        "type": "const string",
        "name": "object.key()",
        "description": "The key of the object by which it is known in the application."
      },
      {
        "type": "string",
        "name": "object.description() mb",
        "description": "The text that is displayed in the browser to describe the object."
      },
      {
        "type": "long",
        "name": "object.value",
        "description": "The object.value can be used to further identify this object, which may be needed in case the object appears more than once in the tree. This object.value will be returned on subsequent function calls, such as gbf.get.children() or gbf.menu.selected() . Note that a value of 0 means something special, see gbf.update.object()."
      }
    ],
    "returnValue": ">= 0 Successful completion, returned value is the new obj.id GBF.NO.MEMORY Not enough memory GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id, help.function.id or drop.function.id identification GBF.ILL.LENGTH Length of object.key exceeds the stored key length in GBF GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NOT.EXPECTED Function called when GBF did not expect this",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.add.object": {
    "name": "gbf.add.object",
    "type": "function",
    "syntax": "function long gbf.add.object (const string object.key(), const string object.description() mb, long object.value, long obj.type [, long icon.set] [, long default.function.id] [, long help.function.id] [, long drop.function.id] [, long menumask] [, long text.color] [, long line.style] [, long context.menu.id])",
    "description": "Adds a header, interior, or leaf node to the object tree.",
    "arguments": [
      {
        "type": "const string",
        "name": "object.key()",
        "description": "The key of the object by which it is known in the application."
      },
      {
        "type": "const string",
        "name": "object.description() mb",
        "description": "The text that is displayed in the browser to describe the object."
      },
      {
        "type": "long",
        "name": "object.value",
        "description": "The object.value can be used to further identify this object, which may be needed in case the object appears more than once in the tree. This object.value will be returned on subsequent function calls, such as gbf.get.children() or gbf.menu.selected() . Note that a value of 0 means something special, see gbf.update.object()."
      },
      {
        "type": "long",
        "name": "obj.type",
        "description": "Specify the object type by choosing one of the following: GBF.HEADER GBF.INTERIOR GBF.LEAF"
      },
      {
        "type": "[long",
        "name": "icon.set ]",
        "description": "The value returned by a function depending on the obj.type: GBF.HEADER or GBF.LEAF: gbf.set.leaf.icon() GBF.INTERIOR: gbf.set.interior.icon()"
      },
      {
        "type": "[long",
        "name": "default.function.id ]",
        "description": "The default.function.id is an overloaded function identification. The actual function depends on whether or not this object is a leaf object. See Table default.function.id."
      },
      {
        "type": "[long",
        "name": "help.function.id ]",
        "description": "The help.function.id, if given and > 0, is the function to be called when help is asked and this object is currently selected. The value of help.function.id must be a value returned by a preceding gbf.set.help.function() call. When this help.function.id has an illegal value an error will be returned, and when GBF.OPT.DEBUG has been set then a debug error message will be given."
      },
      {
        "type": "[long",
        "name": "drop.function.id ]",
        "description": "The drop.function.id, if given and > 0, is the function to be called when other objects are dragged and dropped on this object. The value of drop.function.id must be a value returned by a preceding gbf.set.help.function() call. When this drop.function.id has an illegal value an error will be returned and when GBF.OPT.DEBUG has been set then a debug error message will be given."
      },
      {
        "type": "[long",
        "name": "menumask ]",
        "description": "The menumask is a bitmask to indicate which menu options should be disabled. Which bit disables which option is defined by setting a maskbit with gbf.set.menu.item() ."
      },
      {
        "type": "[long",
        "name": "text.color ]",
        "description": "The text.color, if given and <> 0 is the color with which the object.description will be written in the tree. The value must be given as an RGB (red-green-blue) value. The standard defines are RGB.RED, RGB.GREEN, RGB.YELLOW, RGB.CYAN, RGB.MAGENTA, RGB.BLUE, RGB.WHITE RGB.GRAY, RGB.DGRAY. There is a limited number of colors possible, so that when this limit is exceeded the standard colors will be used. Note that the RGB.BLACK happens to be 0, so that value is mapped onto the standard foreground color of the GBF (see also: gbf.get.resource() and gbf.set.resource() ) which by default is black. All used colors must have a description so in case the end user asks for Help on Colors they will get a short explanation of these colors, see also gbf.set.color() ."
      },
      {
        "type": "[long",
        "name": "line.style ]",
        "description": "The line.style, if given and <> GBF.LINE.SOLID (which is defined as: 0), indicates that the linestyle to the parent node must be used rather than a solid line. Currently only GBF.LINE.DASHED must be used, which draws dashed lines. Note that this information is not used when this gbf.add.object() call is made during a gbf.get.top.level() function call."
      },
      {
        "type": "[long",
        "name": "context.menu.id ]",
        "description": "The context.menu.id is used to couple a context menu to this specific object. The context menu and its context should be known before the call to gbf.start() . The context.menu.id is aquired through the function gbf.create.context.menu(). When used properly the end user can right-click on an item which makes a context menu appear for this specific node. When the option GBF.OPT.TREE.CONTROL is used, i.e. microsoft treeview, the functions gbf.set.leaf.icon() and gbf.set.interior.icon() have to be used to add the context menu. This is because the Microsoft Treeview couples the context menus to the icon groups."
      }
    ],
    "returnValue": ">= 0 Successful completion, returned value is the new obj.id GBF.NO.MEMORY Not enough memory GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id, help.function.id or drop.function.id identification GBF.ILL.LENGTH Length of object.key exceeds the stored key length in GBF GBF.ILL.STATE GBF is not in the correct state to deal with this function GBF.NOT.EXPECTED Function called when GBF did not expect this",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.bms.received": {
    "name": "gbf.bms.received",
    "type": "function",
    "syntax": "function long gbf.bms.received (long sender.id, const string mask(), const string mss(), long length)",
    "description": "This function will be called by the GBF when the GBF receives a BMS message that it cannot handle itself. The application should now deal (or ignore) this message.",
    "arguments": [
      {
        "type": "long",
        "name": "sender.id",
        "description": "The Baan process which has send this message."
      },
      {
        "type": "const string",
        "name": "mask()",
        "description": "The mask with which the message has been send"
      },
      {
        "type": "const string",
        "name": "mss()",
        "description": "The actual BMS message"
      },
      {
        "type": "long",
        "name": "length",
        "description": "The length of the message mss"
      }
    ],
    "returnValue": "The return value is treated in the same way as with the gbf.menu.selected() function call, but be very careful with operations on the current selected object.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.create.context.menu": {
    "name": "gbf.create.context.menu",
    "type": "function",
    "syntax": "function long gbf.create.context.menu ()",
    "description": "This function creates a popup menu that is activated when the user clicks on the right mouse button and the mouse cursor is on a node. The popup menu is initially completely empty. The programmer has to add the popup menu items with the function gbf.set.menu.item() . After that, the developer has to bind this context menu to a certain object through a call to gbf.add.object() which has an argument context.menu.id for this so at the same time the node is created the context menu is assigned to it. Thus each node can have its own specific context menu.",
    "arguments": [],
    "returnValue": ">=0 Successful completion, returned value is the new popup menu.id GBF.NO.MEMORY Not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NOT.EXPECTED Function called when GBF did not expect it",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.current.library": {
    "name": "gbf.current.library",
    "type": "function",
    "syntax": "function string gbf.current.library ()",
    "description": "The gbf.current.library() is a macro, which is defined as: gbf.file.to.library(__FILE__). It makes an educated guess based on the current filename what the object name is.",
    "arguments": [],
    "returnValue": "The run time object name of the object file.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.delete.object": {
    "name": "gbf.delete.object",
    "type": "function",
    "syntax": "function long gbf.delete.object (long obj.id)",
    "description": "Deletes the given object, identified by obj.id, including all its child objects. When obj.id is GBF.ROOT.OBJECT then all child objects will be deleted.Note that in most cases a return value from gbf.menu.selected() will do better than using this function. The object identified by obj.id is deleted from the object tree, including all its children. Deleting obj.id in case when it is part of a multiple selection has some complications. If the obj.id is in the list of current selected objects, then it will also be removed from that list, which implies that the list is now at least one element shorter than it used to be and all elements that follow this element now have a smaller index. For example, if this obj.id used to have an index of 3 (see gbf.get.selected() ) then the object which used to have index 4 will now have index 3, object 5 will now be object 4 and so on. Take care that when this to be deleted obj.id, has child objects that are also in the current selection, then these will be removed to. So that the list will get even shorter and the indices of the remaining objects may have changed more than just with 1.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.desc.to.column": {
    "name": "gbf.desc.to.column",
    "type": "function",
    "syntax": "function string gbf.desc.to.column (const string column1, const string ...)",
    "description": "Create a special description string which is used to separate columns.",
    "arguments": [
      {
        "type": "const string",
        "name": "column1",
        "description": "The column 1 part of the description."
      },
      {
        "type": "const string",
        "name": "...",
        "description": "Optional arguments containing the column 2, column 3 etc. parts of the description."
      }
    ],
    "returnValue": "A description string, containing the concatenated column descriptions, separated by a special separator character.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.drag.drop": {
    "name": "gbf.drag.drop",
    "type": "function",
    "syntax": "function long gbf.drag.drop (long drag.obj, const string drag.key(), long drag.value, long drag.type, long drop.obj, const string drop.key(), long drop.value, long drop.type, long button.mode)",
    "description": "This function will be called by the GBF when a drag and drop operation has been performed by the end-user. Note that in order to receive these function calls, the GBF must be configured for drag and drop (see gbf.init() ), otherwise it will not support drag and drop. Also when the GBF is not configured for multiple select, then always only one object can be dragged and dropped.",
    "arguments": [
      {
        "type": "long",
        "name": "drag.obj",
        "description": "See above."
      },
      {
        "type": "const string",
        "name": "drag.key()",
        "description": ""
      },
      {
        "type": "long",
        "name": "drag.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "drag.type",
        "description": ""
      },
      {
        "type": "long",
        "name": "drop.obj",
        "description": ""
      },
      {
        "type": "const string",
        "name": "drop.key()",
        "description": ""
      },
      {
        "type": "long",
        "name": "drop.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "drop.type",
        "description": ""
      },
      {
        "type": "long",
        "name": "button.mode",
        "description": "The button.mode indicates which keys are hold down, possible values: EVTSHIFTMASK and/or EVTCONTROLMASK, indicating that the Shift key and/or Ctrl key are/were pushed down at the moment of the drop."
      }
    ],
    "returnValue": "The return value is treated in the same way as with the gbf.menu.selected() function call and it applies to both the dragged objects as well as to the drop object.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.enable.drop": {
    "name": "gbf.enable.drop",
    "type": "function",
    "syntax": "function long gbf.enable.drop (const string session.code, const string dllname, const string gbf.on.drop)",
    "description": "Allow drop operation from objects dragged from the indicated composite child sessions. When an object from the indicated session is dropped, the function passed in parameter gbf.on.drop will be called. This function must be called by the application after gbf.init() has been called but before gbf.start() is called.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "code of the session from which objects can be dropped"
      },
      {
        "type": "const string",
        "name": "dllname",
        "description": "The name of the DLL in which the function gbf.on.drop is implemented. Usually you can use the return value of gbf.current.library()"
      },
      {
        "type": "const string",
        "name": "gbf.on.drop",
        "description": "The name of the function that will be called when a drop event occurs. This function must be declared as described here: gbf.on.drop() ."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.DLL Illegal or unknown dllname specified GBF.ILL.FUNCTION Illegal or unknown gbf.on.drop function specified GBF.ILL.STATE GBF is not in the right state to handle this function GBF.NO.MEMORY not enough memory",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.error.string": {
    "name": "gbf.error.string",
    "type": "function",
    "syntax": "function string gbf.error.string (long error)",
    "description": "Returns the string which represents the given error. This error should be a return value from any other GBF function call. This function translates such an (error) return value into its defined format.",
    "arguments": [
      {
        "type": "long",
        "name": "error",
        "description": "The error return value."
      }
    ],
    "returnValue": "String holding the mnemonic value (or define).",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.file.to.library": {
    "name": "gbf.file.to.library",
    "type": "function",
    "syntax": "function string gbf.file.to.library (const string filename())",
    "description": "Uses the given filename to guess the object name of the session. It replaces the first \"p\" (of program file) in the file name with an \"o\" (of object file) and removes the trailing digit (usually a 0, but in fact the variant number). This macro can be used when all session functions, such as gbf.get.top.level(), gbf.get.children(), gbf.menu.selected() and so on, reside in the source file name filename. When these functions gbf.get.top.level() and so on reside in the current file, gbf.current.library() should be used.",
    "arguments": [
      {
        "type": "const string",
        "name": "filename()",
        "description": "The program file name."
      }
    ],
    "returnValue": "The run time object name of the object file.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.children": {
    "name": "gbf.get.children",
    "type": "function",
    "syntax": "function long gbf.get.children (const string object.key(), long object.value, long cur.level)",
    "description": "This function will be called by the GBF whenever it has the need for the children of a specific parent, for example after a parent is opened or after a refresh.",
    "arguments": [
      {
        "type": "const string",
        "name": "object.key()",
        "description": "The parent is identified by the object.key and object.value, which have been given to the GBF on a preceding gbf.add.object() call. Note that in this particular call the obj.type argument must have been set to GBF.INTERIOR otherwise this function ( gbf.get.children() ) would not have been called for this object."
      },
      {
        "type": "long",
        "name": "object.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "cur.level",
        "description": "The cur.level indicates the current level of the given object. The level is defined as: 1 for every object which is added to the GBF by a gbf.add.object() call when called from a gbf.get.top.level() function call 1 + cur.level for each child which is added to the GBF with gbf.add.object() when called from this gbf.get.children() call."
      }
    ],
    "returnValue": "GBF.DO.CONTINUE or 0 Successful completion, GBF will continue working GBF.DO.ABORT Abort GBF, which will end the GBF and return with an error, see gbf.start() GBF.DO.EXIT Finish GBF, which will end the GBF and return with 0, see gbf.start() Any return other than these values will be treated as if GBF.DO.ABORT has been returned",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.current.parent": {
    "name": "gbf.get.current.parent",
    "type": "function",
    "syntax": "function long gbf.get.current.parent ()",
    "description": "Returns the object identification (obj.id) of the current parent, which is the parent for which the children are now asked for by the GBF. In other words, the current parent is the parent to which objects will be added with the gbf.add.object() function. This function can thus only be called during a call back to gbf.get.top.level() (in which case the return value will be the special value: GBF.ROOT.OBJECT), or during a gbf.get.children(). Unlike with gbf.get.parent() function the parents key and value are not returned by this gbf.get.current.parent() function, since that information has already been supplied with the original (gbf.get.top.level() and) gbf.get.children() function call. In case the GBF has added a special extra parent then this extra node will not be returned by this function.",
    "arguments": [],
    "returnValue": "other Object id of current object, function called during gbf.get.children() GBF.ROOT.OBJECT Successful completion, no parent (or root is parent), function called during gbf.get.top.level() GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.cutcopy": {
    "name": "gbf.get.cutcopy",
    "type": "function",
    "syntax": "function long gbf.get.cutcopy (long index, ref string obj.key(), ref string obj.description(), ref long obj.value)",
    "description": "This function must only be used when a call back to the main application indicates that there are one or more objects in the cut, copy and paste buffers (see gbf.get.cutcopynr()). A further use of this function is immediately after the GBF has stopped (in other words the gbf.start() function call has completed) to get the current cut or copy objects, so in this case the GBF can be used as a zoom session to pick a specific object. This function then allows you to retrieve all the cut or copy objects one by one as it returns the cut or copy object at the given index. The object is identified by the obj.key, obj.desc and obj.value, which have been given to the GBF on a gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "index",
        "description": "The index in the cut, copy and paste buffer. To retrieve the number of objects within the buffer, use the gbf.get.cutcopy.nr() function."
      },
      {
        "type": "ref string",
        "name": "obj.key()",
        "description": "A reference to the key of the object by which it is known in the application."
      },
      {
        "type": "ref string",
        "name": "obj.description()",
        "description": "A reference to the text that is displayed in the browser to describe the object."
      },
      {
        "type": "ref long",
        "name": "obj.value",
        "description": "A reference to the value of the object that is used to further identify this object (in case the object is in the tree more than once). Note that a value of 0 means something special, see gbf.update.object()."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OBJECT Illegal index given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.cutcopy.nr": {
    "name": "gbf.get.cutcopy.nr",
    "type": "function",
    "syntax": "function long gbf.get.cutcopy.nr ()",
    "description": "This function returns the number of objects that have been pasted into the so-called cut, copy and paste buffers. You can use the following user actions to fill the cut, copy and paste buffers:",
    "arguments": [],
    "returnValue": "= 0 Successful completion, but cut, copy & paste buffers are empty > 0 Successful completion, returned value is number of objects in cut, copy & paste buffers GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.description": {
    "name": "gbf.get.description",
    "type": "function",
    "syntax": "function long gbf.get.description (long obj.id, ref string description() mb)",
    "description": "This function returns the description of the given object. In other words the description with which the object has been created ( gbf.add.object() ) or last updated (gbf.update.object()).",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      },
      {
        "type": "ref string",
        "name": "description() mb",
        "description": "A reference to the description of the object."
      }
    ],
    "returnValue": "0 Successful completion, description is valid GBF.ILL.OBJECT Illegal obj.id given, description is invalid GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.first.child": {
    "name": "gbf.get.first.child",
    "type": "function",
    "syntax": "function long gbf.get.first.child (long obj.id, long force.read, ref long child.id, ref string child.key, ref long child.value, ref long child.type)",
    "description": "This function returns the first child of the given object if the children are read by the GBF (see below). The returned child.id is the GBF child identification, to be used on subsequent gbf.get.parent(), gbf.get.first.child(), gbf.get.next() and gbf.update.object() function calls. The child is further identified by the child.key and child.value, which have been given to the GBF on a preceding gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      },
      {
        "type": "long",
        "name": "force.read",
        "description": "Tells the GBF what to do when the children are not yet read. See table above with an explanation."
      },
      {
        "type": "ref long",
        "name": "child.id",
        "description": "Returns the unique child (object) identification."
      },
      {
        "type": "ref string",
        "name": "child.key",
        "description": "Returns the key of the child (object) by which it is known in the application."
      },
      {
        "type": "ref long",
        "name": "child.value",
        "description": "Returns the value of the child (object) that is used to further identify this object (in case the object is more than once in the tree). Note that a value of 0 means something special, see gbf.update.object()."
      },
      {
        "type": "ref long",
        "name": "child.type",
        "description": "The type of node child.id: GBF.HEADER the returned child.id is a header node GBF.INTERIOR the returned child.id is an interior node. GBF.LEAF the returned child.id is a leaf node"
      }
    ],
    "returnValue": "0 Successful completion GBF.CYCLE Successful completion, but child.id reflects the same object as obj.id in this subtree due to a cycle. GBF.LAST Successful completion, and child.id is the only child GBF.NO.CHILDREN Successful completion, but obj.id does not have any children GBF.NO.READ.CHILDREN Successful completion, but the children of obj.id are not yet read GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NO.MEMORY Not enough memory to store all children GBF.NOT.INTERIOR Given obj.id is not an interior node, so it has no children",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.key.desc.length": {
    "name": "gbf.get.key.desc.length",
    "type": "function",
    "syntax": "function long gbf.get.key.desc.length (ref long key.length, ref long desc.length)",
    "description": "Returns the length of the key of the object and the length of the description of the object. The default length for the object key is 64 and for the object description 60.",
    "arguments": [
      {
        "type": "ref long",
        "name": "key.length",
        "description": "Returns the length of the object key."
      },
      {
        "type": "ref long",
        "name": "desc.length",
        "description": "Returns the length of the object description."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.next": {
    "name": "gbf.get.next",
    "type": "function",
    "syntax": "function long gbf.get.next (long obj.id, ref long next.id, ref string next.key(), ref long next.value, ref long next.type)",
    "description": "Returns the next brother object of the given object. The returned next.id is the GBF identification, to be used on subsequent gbf.get.parent(), gbf.get.first.child() , gbf.get.next() and gbf.update.object() function calls. The next brother is further identified by the next.key and next.value, which have been given to the GBF on a preceding gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      },
      {
        "type": "ref long",
        "name": "next.id",
        "description": "Returns the unique child (object) identification."
      },
      {
        "type": "ref string",
        "name": "next.key()",
        "description": "Returns the key of the child (object) by which it is known in the application."
      },
      {
        "type": "ref long",
        "name": "next.value",
        "description": "Returns the value of the child (object) that is used to further identify this object (in case the object appears more than once in the tree). Note that a value of 0 means something special, see gbf.update.object()."
      },
      {
        "type": "ref long",
        "name": "next.type",
        "description": "The type of node child.id: GBF.HEADER the returned child.id is a header node GBF.INTERIOR the returned child.id is an interior node. GBF.LEAF the returned child.id is a leaf node"
      }
    ],
    "returnValue": "0 Successful completion GBF.LAST Successful completion, and next.id is the last brother GBF.ILL.OBJECT Illegal obj.id given, or obj.id has no further brothers GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.object.info": {
    "name": "gbf.get.object.info",
    "type": "function",
    "syntax": "function long gbf.get.object.info (long object.id, ref string key(), ref string description(), ref long value, ref long type)",
    "description": "This function returns the information of the object obj.id . The returned information is the information set at the call to gbf.add.object() .",
    "arguments": [
      {
        "type": "long",
        "name": "object.id",
        "description": "The unique object identification."
      },
      {
        "type": "ref string",
        "name": "key()",
        "description": "The key of the object by which it is known in the application."
      },
      {
        "type": "ref string",
        "name": "description()",
        "description": "The text that is displayed in the browser to describe the object."
      },
      {
        "type": "ref long",
        "name": "value",
        "description": "The value of the object that is used to further identify this object (in case the object appears more than once in the tree). Note that a value of 0 means something special, see gbf.update.object() * ."
      },
      {
        "type": "ref long",
        "name": "type",
        "description": "Specify the object type by choosing one of the following: GBF.HEADER GBF.INTERIOR GBF.LEAF"
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OBJECT GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.open.depth": {
    "name": "gbf.get.open.depth",
    "type": "function",
    "syntax": "function long gbf.get.open.depth (ref long open.depth)",
    "description": "Returns the current open and read depth. This open.depth is the number of levels the GBF will display when opening an interior node. When not all of these levels have been read yet, the GBF will read the necessary levels. The default value for open.depth is 1.",
    "arguments": [
      {
        "type": "ref long",
        "name": "open.depth",
        "description": "Returns the current open and read depth."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.open.strategy": {
    "name": "gbf.get.open.strategy",
    "type": "function",
    "syntax": "function long gbf.get.open.strategy (ref long open.type)",
    "description": "Returns the current automatic open and close schema.",
    "arguments": [
      {
        "type": "ref long",
        "name": "open.type",
        "description": "Returns the current automatic open and close schema."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.parent": {
    "name": "gbf.get.parent",
    "type": "function",
    "syntax": "function long gbf.get.parent (long obj.id, ref long parent.id, ref string parent.key(), ref long parent.value)",
    "description": "Returns the parent of the given object. The returned parent.id is the GBF parent identification, to be used on subsequent gbf.get.parent(), gbf.get.first.child() , gbf.get.next() and gbf.update.object() function calls. The parent is further identified by the parent.key and parent.value, which have been given to the GBF on a preceding gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      },
      {
        "type": "ref long",
        "name": "parent.id",
        "description": "Returns the parent object identification."
      },
      {
        "type": "ref string",
        "name": "parent.key()",
        "description": "Returns the parent object key."
      },
      {
        "type": "ref long",
        "name": "parent.value",
        "description": "Returns the parent object value."
      }
    ],
    "returnValue": "0 Successful completion GBF.TOP.LEVEL Successful completion, and parent.id is at top level GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.previous": {
    "name": "gbf.get.previous",
    "type": "function",
    "syntax": "function long gbf.get.previous (long obj.id, ref long prev.id, ref string prev.key, ref long prev.value, ref long prev.type)",
    "description": "This function returns the previous brother object of the given object. The returned prev.id is the GBF identification, to be used on subsequent gbf.get.parent() , gbf.get.first.child() , gbf.get.next() and gbf.update.object() * function call. The previous brother is further identified by the prev.key and prev.value , which have been given to the GBF on a preceding gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The unique object identification."
      },
      {
        "type": "ref long",
        "name": "prev.id",
        "description": "Returns the unique previous (object) identification."
      },
      {
        "type": "ref string",
        "name": "prev.key",
        "description": "Returns the key of the previous (object) by which it is known in the application."
      },
      {
        "type": "ref long",
        "name": "prev.value",
        "description": "Returns the value of the previous (object) that is used to further identify this object (in case the object is more than once in the tree). Note that a value of 0 means something special, see gbf.update.object() * ."
      },
      {
        "type": "ref long",
        "name": "prev.type",
        "description": "The type of node prev.id : GBF.HEADER the returned prev.id is a header node GBF.INTERIOR the returned prev.id is an interior node. GBF.LEAF the returned prev.id is a leaf node"
      }
    ],
    "returnValue": "0 Successful completion GBF.LAST Successful completion, and prev.id is the first previous brother GBF.ILL.OBJECT Illegal obj.id given, or obj.id has no further brothers GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.print.options": {
    "name": "gbf.get.print.options",
    "type": "function",
    "syntax": "function long gbf.get.print.options (ref long print.options)",
    "description": "Returns the current print options in print.options. For more details about the print.options see function gbf.set.print.options() .",
    "arguments": [
      {
        "type": "ref long",
        "name": "print.options",
        "description": "Returns the current print options."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.read.levels": {
    "name": "gbf.get.read.levels",
    "type": "function",
    "syntax": "function long gbf.get.read.levels (ref long read.levels [, ref long show.levels])",
    "description": "Returns the current number of levels that will be read (and shown) when an application returns one of the restart return values (see: gbf.menu.selected() : for example the GBF.DO.RESTART.TREE). Initially these values are set to the values as supplied with the gbf.start() function call and can be changed using: gbf.set.read.level().",
    "arguments": [
      {
        "type": "ref long",
        "name": "read.levels",
        "description": "Returns the current number of levels that will be read."
      },
      {
        "type": "[ref long",
        "name": "show.levels ]",
        "description": "Returns the current number of levels that will be shown."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.refresh.strategy": {
    "name": "gbf.get.refresh.strategy",
    "type": "function",
    "syntax": "function long gbf.get.refresh.strategy (ref long refresh.rate, ref long refresh.type)",
    "description": "Returns the current automatic refreshing schema. The two arguments will be used to store the values. If refresh.rate is 0, then the refresh.type may not be a valid type (see also gbf.set.refresh.strategy()).",
    "arguments": [
      {
        "type": "ref long",
        "name": "refresh.rate",
        "description": "Retuns the refresh rate."
      },
      {
        "type": "ref long",
        "name": "refresh.type",
        "description": "Returns the refresh type."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.resource": {
    "name": "gbf.get.resource",
    "type": "function",
    "syntax": "function long gbf.get.resource (long resource.type, ref void resource.value)",
    "description": "Returns the current value for the given resource types. The arguments are given in name value pairs. For the possible resources see gbf.set.resource() . In almost all cases the <type> will be long (or a domain of basic type int, long, enumerate, bitset and so on.), except when the resource.type is DsNtitle, since in this case the <type> must be multi-byte string.",
    "arguments": [
      {
        "type": "long",
        "name": "resource.type",
        "description": "The resource type that is used to get the value. For a list of resource types see gbf.set.resource() ."
      },
      {
        "type": "ref void",
        "name": "resource.value",
        "description": "Returns the current value of the resource type."
      }
    ],
    "returnValue": "0 Successful completion GBF.ARG.ERROR One or more of the given resource.value references is wrong GBF.ILL.RESOURCE. TYPE Unknown resource type specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.search.strategy": {
    "name": "gbf.get.search.strategy",
    "type": "function",
    "syntax": "function long gbf.get.search.strategy (ref long search.strategy)",
    "description": "Returns the current search strategy. The argument will be used to store the value. For more details about the search.strategy see function gbf.set.search.strategy().",
    "arguments": [
      {
        "type": "ref long",
        "name": "search.strategy",
        "description": "The current search strategy. For a list of search strategies, see gbf.set.search.strategy()."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.selected": {
    "name": "gbf.get.selected",
    "type": "function",
    "syntax": "function long gbf.get.selected (long index, ref long obj.id, string obj.key(), ref long obj.value, ref long obj.type)",
    "description": "This function must only be used when a call back to the main application indicates that there is one or more currently selected objects (see gbf.init() , gbf.menu.selected() , gbf.drag.drop() and so on). The function gbf.get.selected.nr() can be used to get the current number of selected objects. A further use of this function is immediately after the GBF has stopped (in other words the gbf.start() function call has completed) to get the current selected objects, so in this case the GBF can be used as zoom session to pick a specific object. This function then allows you to retrieve all the selected objects one by one as it returns the selected object at the given index. The returned obj.id is the GBF identification, to be used on subsequent gbf.get.parent(), gbf.get.first.child() , gbf.get.next() and gbf.update.object() * function call. The object is further identified by the obj.key and obj.value, which have been given to the GBF on a preceding gbf.add.object() call.",
    "arguments": [
      {
        "type": "long",
        "name": "index",
        "description": "The index in the range of selected objects"
      },
      {
        "type": "ref long",
        "name": "obj.id",
        "description": "Returns the object identification"
      },
      {
        "type": "string",
        "name": "obj.key()",
        "description": "Returns the object key"
      },
      {
        "type": "ref long",
        "name": "obj.value",
        "description": "Returns the object value"
      },
      {
        "type": "ref long",
        "name": "obj.type",
        "description": "Returns the object type"
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OBJECT Illegal index given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.selected.nr": {
    "name": "gbf.get.selected.nr",
    "type": "function",
    "syntax": "function long gbf.get.selected.nr ()",
    "description": "This function returns the current number of selected objects. It can be used to obtain the maximum allowed index for gbf.get.selected() .",
    "arguments": [],
    "returnValue": "> 0 Successful completion, the actual number of selected objects is returned = 0 Successful completion, but currently no objects are selected GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.sort.strategy": {
    "name": "gbf.get.sort.strategy",
    "type": "function",
    "syntax": "function long gbf.get.sort.strategy (ref long sort.strategy)",
    "description": "This function returns the current sort strategy in sort.strategy. For more details about the sort.strategy see function gbf.set.sort.strategy() .",
    "arguments": [
      {
        "type": "ref long",
        "name": "sort.strategy",
        "description": "Returns the current sort strategy. For more information on the sort strategies see the gbf.set.sort.strategy() call."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.top.level": {
    "name": "gbf.get.top.level",
    "type": "function",
    "syntax": "function long gbf.get.top.level ()",
    "description": "This function will be called by the GBF after it has been started to get the top level node(s).",
    "arguments": [],
    "returnValue": "GBF.DO.CONTINUE or 0 Successful completion, GBF will continue working GBF.DO.ABORT Abort GBF, which will end the GBF and return with an error, see gbf.start() GBF.DO.EXIT Finish GBF, which will end the GBF and return with 0, see gbf.start() Any return other that these values will be treated as if GBF.DO.ABORT has been returned.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.get.view.depth": {
    "name": "gbf.get.view.depth",
    "type": "function",
    "syntax": "function long gbf.get.view.depth (ref long view.depth)",
    "description": "Gets the current view depth.",
    "arguments": [
      {
        "type": "ref long",
        "name": "view.depth",
        "description": "The number of levels the GBF will display when the Open Level option in the File Menu is executed."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.help.selected": {
    "name": "gbf.help.selected",
    "type": "function",
    "syntax": "function void gbf.help.selected (long obj.id, const string object.key(), long object.value, long help.value)",
    "description": "This function will be called when the object has been selected followed by a menu selection or a keystroke.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "See above."
      },
      {
        "type": "const string",
        "name": "object.key()",
        "description": ""
      },
      {
        "type": "long",
        "name": "object.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "help.value",
        "description": ""
      }
    ],
    "returnValue": "None",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.init": {
    "name": "gbf.init",
    "type": "function",
    "syntax": "function long gbf.init (const string library(), const string title() [, long default.menu] [, long default.button] [, long default.options] [, long standard.buttons] [, long default.context])",
    "description": "This function must be the first to be called, it initializes the global data structures of the GBF. It is not forbidden to reactivate a new run of the GBF in a session after a previous run of the GBF has terminated, the GBF has to clear its global variables again. This cleaning of the global variables cannot be done when leaving the GBF as at that point in time it must still be possible to get some information about the settings in order for the application to save and restore some user preferences, see for example gbf.get.refresh.strategy() and gbf.get.sort.strategy() .",
    "arguments": [
      {
        "type": "const string",
        "name": "library()",
        "description": "The library should be the name of the library, in general this is the application itself, which may or should contain the following call back functions (see gbf.current.library() and gbf.file.to.library() for an easy way to retrieve the library name): Function"
      }
    ],
    "returnValue": "0 Success GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NO.GRAPHICS GBF can only run on graphical displays, not on ASCII only displays GBF.NO.MEMORY Not enough memory",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.is.displayed": {
    "name": "gbf.is.displayed",
    "type": "function",
    "syntax": "function long gbf.is.displayed (const long obj.id)",
    "description": "Returns whether or not the given object is currently displayed. That is whether the obj.id can be seen and is not hidden because its parent is closed. This function can be used when walking through the object tree (see gbf.get.first.child() , gbf.get.next() , gbf.get.parent() and so on.). It is only checked whether the Generic Browser Framework has drawn the object on the virtual window, but note that it may not actually be visible (on the physical window) because the current view is currently displaying another part of that virtual window.",
    "arguments": [
      {
        "type": "const long",
        "name": "obj.id",
        "description": "The object identification."
      }
    ],
    "returnValue": "true Successful completion, obj.id is currently displayed false Successful completion, obj.id is currently not displayed GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.menu.selected": {
    "name": "gbf.menu.selected",
    "type": "function",
    "syntax": "function long gbf.menu.selected (long obj.id, const string object.key(), long object.value, long menu.option)",
    "description": "This function will be called when the object has been selected followed by a menu selection or a keystroke.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "See above."
      },
      {
        "type": "const string",
        "name": "object.key()",
        "description": ""
      },
      {
        "type": "long",
        "name": "object.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "menu.option",
        "description": ""
      }
    ],
    "returnValue": "category define description redraw GBF.DO.REDRAW.TREE redraw the whole tree refresh GBF.DO.REFRESH.NONE no refresh needed GBF.DO.REFRESH.CURRENT refresh everything under the current selected object GBF.DO.REFRESH.LEVEL refresh level on which current selected object resides GBF.DO.REFRESH.TREE refresh the whole tree restart GBF.DO.RESTART.NONE no restart needed GBF.DO.RESTART.CURRENT restart everything under the current selected object GBF.DO.RESTART.LEVEL restart level or which current selected object resides GBF.DO.RESTART.TREE restart the whole tree cut,. copy GBF.DO.CUTCOPY.NONE do nothing with the cut, copy paste buffers & paste GBF.DO.CUTCOPY.CLEAR clear the cut, copy and paste buffers GBF.DO.CUTCOPY.INSERT replace the contents of the cut, copy and clear buffers with the current selected objects Note: not needed after a GBF.BUTTON.CUT or GBF.BUTTON.COPY menu.option. delete GBF.DO.DELETE.NONE do not delete object GBF.DO.DELETE.CURRENT delete this occurrence of object, and if interior node all underlying nodes in this tree only GBF.DO.DELETE.GLOBAL delete all occurrences of object from tree, and if interior node all underlying nodes in these trees only level GBF.DO.LEVEL.NONE do not open or close anything GBF.DO.LEVEL.OPEN open level only done for closed interior node, no operation in all other cases GBF.DO.LEVEL.CLOSE close level only done for open interior node, no operation in all other cases terminate GBF.DO.CONTINUE continue normal processing GBF.DO.ABORT abort GBF, which will end the GBF and return with an error, see gbf.start() GBF.DO.EXIT finish GBF, which will end the GBF and return with 0, see gbf.start() GBF.DO.NOT.EXIT continue with processing (do NOT stop the GBF) rather than stopping. This should only be used when: gbf.save(�,�,�, GBF.MENU.FILE.QUIT) has been called. The defines will be chosen such that a value of 0 means: do nothing special (not even a redraw or refresh of current object). In general all the above groups are mutual exclusive, that is using a member of one group does not affect using members from any other group. The only exception is that a member of the refresh group is ignored when a member of the restart group (other than GBF.DO.RESTART.NONE) is used. In case of a multiple select, these options apply to all currently selected items except when one of the refresh or restart categories is used, as in this case always GBF.DO.REFRESH.TREE or GBF.DO.RESTART.TREE is used. The difference between GBF.DO.RESTART.TREE and GBF.DO.REFRESH.TREE is that a GBF.DO.REFRESH.TREE tries to keep the current view as similar as it is now on the screen. This is merge the (new) data from the application with which is already available in the GBF, and delete unretrieved data GBF.DO.RESTART.TREE restarts the GBF from fresh, that is as if a gbf.start() has been executed, but see also: gbf.get.read.level() and gbf.set.read.level(). When no object is currently selected then also the GBF.DO.REFRESH.CURRENT and GBF.DO.REFRESH.LEVEL behave the same as a GBF.DO.REFRESH.TREE (refresh the whole tree). Similar when no object is currently selected then also the GBF.DO.RESTART.CURRENT and GBF.DO.RESTART.LEVEL behave the same as a GBF.DO.RESTART.TREE (restart the whole tree). The difference between GBF.DO.REFRESH.CURRENT (or GBF.DO.REFRESH.LEVEL) is that the first one refreshes (or restarts) everything under the current selected object, excluding the current object, and the latter does a refresh (or restarts) on the parent object of the current selected object. So a GBF.DO.REFRESH.LEVEL does not refresh that parent, but refreshes all of its children, which includes the current selected object and all of its brother objects. Note that the current selected object can be updated using gbf.update() functions. The same applies to GBF.DO.RESTART.CURRENT and GBF.DO.RESTART.LEVEL.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.on.drag": {
    "name": "gbf.on.drag",
    "type": "function",
    "syntax": "function long gbf.on.drag (long to.pid, const string to.session, long drag.obj, const string drag.key, long drag.value, long drag.type, reference long collection)",
    "description": "This function will be called by the GBF when one or more GBF objects are dragged from this session and dropped on another composite child session. This function will only be called when dragging to other sessions is enabled (see gbf.init() default.options, GBF.OPT.SESSION.DRAG ).",
    "arguments": [
      {
        "type": "long",
        "name": "to.pid",
        "description": "the process id of the session on which the GBF objects are dropped"
      },
      {
        "type": "const string",
        "name": "to.session",
        "description": "the code of the session on which the GBF objects are dropped"
      },
      {
        "type": "long",
        "name": "drag.obj",
        "description": "See the meaning of the argument drag.obj in the function description of gbf.drag.drop()"
      },
      {
        "type": "const string",
        "name": "drag.key",
        "description": "GBF key related to drag.obj"
      },
      {
        "type": "long",
        "name": "drag.value",
        "description": "GBF value related to drag.obj"
      },
      {
        "type": "long",
        "name": "drag.type",
        "description": "GBF object type to drag.obj"
      },
      {
        "type": "reference long",
        "name": "collection",
        "description": "This function is responsible for creating a collection of key field objects which are dragged from this session. The id of the created collection must be set in the collection argument. The GBF framework will make sure this collection is deleted when it is not needed anymore."
      }
    ],
    "returnValue": "GBF.DO.CONTINUE To indicate to the GBF framework that the drag/drop operation should continue with the passed key fields collection. GBF.DO.ABORT To indicate to the GBF framework that the drag/drop operation should be aborted.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.on.drop": {
    "name": "gbf.on.drop",
    "type": "function",
    "syntax": "function long gbf.on.drop (long from.pid, long collection, long drop.obj, const string drop.key, long drop.value, long drop.type, boolean copy)",
    "description": "Call back function which is passed in function gbf.enable.drop() This function will be called when a drop event from the associated session arrives. In this function the business logic related to the drop operation must be implemented.",
    "arguments": [
      {
        "type": "long",
        "name": "from.pid",
        "description": "the process id of the session from which the objects are dropped"
      },
      {
        "type": "long",
        "name": "collection",
        "description": "collection of key fields objects which are dropped on this session"
      },
      {
        "type": "long",
        "name": "drop.obj",
        "description": "object identifier of GBF object on which the collection is dropped"
      },
      {
        "type": "const string",
        "name": "drop.key",
        "description": "GBF key related to drop.obj"
      },
      {
        "type": "long",
        "name": "drop.value",
        "description": "GBF value related to drop.obj"
      },
      {
        "type": "long",
        "name": "drop.type",
        "description": "GBF object type related to drop.obj"
      },
      {
        "type": "boolean",
        "name": "copy",
        "description": "when true, the user indicated that a copy operation is requested (CTRL key pressed during drop operation). Otherwise a move operation is required"
      }
    ],
    "returnValue": "The return value is treated in the same way as with the gbf.menu.selected() function and it applies the drop object.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.on.selection": {
    "name": "gbf.on.selection",
    "type": "function",
    "syntax": "function void gbf.on.selection (long obj.id, long obj.type, long transition)",
    "description": "This function will be called when the user clicks on an object. It has been made to create an extra possibility for the user to manipulate the state of the standard buttons through the function gbf.set.buttonstate() . It is recommended to use this function only for these purposes. The obj.id gives the id of the selected object and obj.type contains the type of the object, for example, GBF.LEAF, GBF.INTERIOR or GBF.HEADER. When an end user selects an object, the programmer wants to know to which state the object is moving. For example, when an object is selected and the end user clicks on the object again, then its transition state is that the object is moving from the selected state to the deselected state, thus the transition is GBF.DESELECT. When an object is not yet selected and the end user clicks on it, the transition state is from the unselected state to the selected state, thus the transition is GBF.SELECT.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The obj.id of the selected object."
      },
      {
        "type": "long",
        "name": "obj.type",
        "description": "The type of object, GBF.LEAF, GBF.INTERIOR or GBF.HEADER."
      },
      {
        "type": "long",
        "name": "transition",
        "description": "The new state, GBF.SELECT or GBF.DESELECT"
      }
    ],
    "returnValue": "None.",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.save": {
    "name": "gbf.save",
    "type": "function",
    "syntax": "function long gbf.save (long obj.id, const string object.key(), long object.value, long save.type)",
    "description": "This function will be called when the Save or Save+Exit menu has been called. The idea is that the main application should now save any unsaved data.",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "See above."
      },
      {
        "type": "const string",
        "name": "object.key()",
        "description": ""
      },
      {
        "type": "long",
        "name": "object.value",
        "description": ""
      },
      {
        "type": "long",
        "name": "save.type",
        "description": ""
      }
    ],
    "returnValue": "See gbf.menu.selected()",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.button": {
    "name": "gbf.set.button",
    "type": "function",
    "syntax": "function long gbf.set.button (const string button.group(), const string normal.button(), const string selected.button(), const string insensitive.button(), const string button.name(), long menu.item, long add.space)",
    "description": "Adds a button to the button bar.",
    "arguments": [
      {
        "type": "const string",
        "name": "button.group()",
        "description": "A group name for the normal, selected and insensitive icon."
      },
      {
        "type": "const string",
        "name": "normal.button()",
        "description": "Baan(IV) The icon(20x20) to represent a button in its normal state Baan (V) The icon (16x15) to represent all states."
      },
      {
        "type": "const string",
        "name": "selected.button()",
        "description": "Baan(IV) The icon(20x20) to represent a button in its selected state Baan(V) -"
      },
      {
        "type": "const string",
        "name": "insensitive.button()",
        "description": "Baan(IV) The icon(20x20) to represent a button in its insensitive (not selectable) state Baan (V) -"
      },
      {
        "type": "const string",
        "name": "button.name()",
        "description": "The name of the button that is shown when the cursor is above this button or when help is asked on this button and No menu item is associated with this button."
      },
      {
        "type": "long",
        "name": "menu.item",
        "description": "The associated menu command. This menu.item should be a valid value from a preceding call to the function: gbf.set.menu.item() ."
      },
      {
        "type": "long",
        "name": "add.space",
        "description": "When the add.space is TRUE, then some extra white space is added before the button. When the add.space is FALSE then no extra white space is added before this new button."
      }
    ],
    "returnValue": "> 0 Successful completion, actual button identification is returned 0 Should never happen GBF.NO.MEMORY Not enough memory GBF.ILL.MENU.ID Illegal menu.item value given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.buttonstate": {
    "name": "gbf.set.buttonstate",
    "type": "function",
    "syntax": "function long gbf.set.buttonstate (long button.id, long button.state)",
    "description": "This function regulates the state of the standard buttons. This function can only be used if the default.button mask in the function gbf.init() is set with the standard buttons that need to be controlled. The old behavour of this option was that all the standard buttons were shown but disabled. This is still the case but now it is possible to enable or disable these buttons. When, however, the standard.button mask is used then it is not possible to adjust the standard buttons using this function. The GBF will then take over controll of these buttons. This is also default behaviour. To improve the accessibility to the buttons the application function gbf.on.selection() can be used. This function is called whenever a selection is made. It is clear that the user of this function is fully responsible for the behaviour of the buttons. The following table gives the buttons that can be manipulated through this function:",
    "arguments": [
      {
        "type": "long",
        "name": "button.id",
        "description": "The identification of the button. See the list above."
      },
      {
        "type": "long",
        "name": "button.state",
        "description": "The state of the buttons or button.state can be either GBF.DISABLED or GBF.ENABLED."
      }
    ],
    "returnValue": "0 Success GBF.NO.BUTTON The requested button does not exist GBF.ILL.BUTTON The given button is illegal or not supported yet GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.child.function": {
    "name": "gbf.set.child.function",
    "type": "function",
    "syntax": "function long gbf.set.child.function (const string dll_id(), const string child.function.name(), long is.default)",
    "description": "Adds a function to get children, to the set of all get children functions. If the child.function.name resides in the same source file as in which the call to this gbf.set.child.function() is made, then the function gbf.current.library() can be used, so use: gbf.set.child.function(gbf.current.library(), �).",
    "arguments": [
      {
        "type": "const string",
        "name": "dll_id()",
        "description": "The name of the DLL."
      },
      {
        "type": "const string",
        "name": "child.function.name()",
        "description": "The name of the child function to find in the DLL."
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "If set to true this child function is set as the default child function. Only if it is successfully added."
      }
    ],
    "returnValue": "> 1 The identification of this child function = 1 Should never be returned, as 1 is the GBF default GBF.ILL.DLL llegal DLL specified GBF.ILL.FUNCTION Illegal function specified, or function not known in given DLL GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NO.MEMORY Not enough memory",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.color": {
    "name": "gbf.set.color",
    "type": "function",
    "syntax": "function long gbf.set.color (long color, const string color.desc())",
    "description": "Adds a description to the given color. This color.desc should be a message, which will be displayed when the Help on colors (Help -> Color Descriptions�) is activated. These colors are the colors with which the actual object have been added to the GBF. See the text.color argument of the gbf.add.object() function. When using the same color then only the last color.description of this color will be remembered, even when this color.description is empty when a preceding color.description was not empty.",
    "arguments": [
      {
        "type": "long",
        "name": "color",
        "description": "The color RGB value"
      },
      {
        "type": "const string",
        "name": "color.desc()",
        "description": "The description for this color"
      }
    ],
    "returnValue": "0 Success GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.desc.length": {
    "name": "gbf.set.desc.length",
    "type": "function",
    "syntax": "function long gbf.set.desc.length (long desc.length)",
    "description": "The following functions are actually defines and they are defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "desc.length",
        "description": "The new description length."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LENGTH Key.length and/or desc.length < not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.drop.function": {
    "name": "gbf.set.drop.function",
    "type": "function",
    "syntax": "function long gbf.set.drop.function (const string dll_id(), const string drop.function.name(), long is.default)",
    "description": "Adds a new drag and drop function to the drag and drop functions. If the drop.function.name resides in the same source file as in which the call to this gbf.set.drop.function() is made, then the function gbf.current.library() can be used, so use: gbf.set.drop.function(gbf.current.library(), �). Note that the drop.function.name function must be defined as:",
    "arguments": [
      {
        "type": "const string",
        "name": "dll_id()",
        "description": "The name of the DLL."
      },
      {
        "type": "const string",
        "name": "drop.function.name()",
        "description": "The name of the drag and drop function to find in the DLL."
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "If set to true this drag and drop function is used as the default, instead of a previous defined default drag and drop function or the standard gbf.drag.drop() function."
      }
    ],
    "returnValue": "> 1 The identification of this drag and drop function = 1 Should never be returned, as 1 is the GBF default GBF.ILL.DLL Illegal DLL specified GBF.ILL.FUNCTION Illegal function specified, or function not known in given DLL GBF.NO.MEMORY Not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.header.icon": {
    "name": "gbf.set.header.icon",
    "type": "function",
    "syntax": "function long gbf.set.header.icon (const string icon.group(), const string icon(), long is.default [, const string icon.desc()])",
    "description": "Adds a header node icon to the set of header node icons. The value, if non negative, which is returned must be used in subsequent calls to identify this icon set. Empty icons, in other words empty strings, are not allowed.",
    "arguments": [
      {
        "type": "const string",
        "name": "icon.group()",
        "description": "The icon.group must be a valid icon group as defined in table ttdsk900 Icon Groups using session ttdsk9100m000 Icon Groups."
      },
      {
        "type": "const string",
        "name": "icon()",
        "description": "Also the icon should be a valid icon as defined in table ttdsk903 Icons using session ttdsk9103m000 Icons."
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "If set to true this icon is used as the default header icon and the previous default header icon is overruled."
      },
      {
        "type": "[const string",
        "name": "icon.desc() ]",
        "description": "The icon.desc should be a message containing the description of the icon. This icon.desc will be used when the GBF tree is printed. If not given or the message is empty then nothing will be printed. Also this text will be shown when help on icons is asked for via the Help -> Icon Descriptions."
      }
    ],
    "returnValue": "> 1 The identification of this new icon set = 1 Should never be returned, as 1 is the GBF default GBF.NO.MEMORY Not enough memory GBF.ICON.EMPTY Empty icon strings are not allowed GBF.ICON.LOAD.ERROR Could not load the icon GBF.ILL.BITMAP Illegal bitmap for icon (not a GIF file) GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.help.function": {
    "name": "gbf.set.help.function",
    "type": "function",
    "syntax": "function long gbf.set.help.function (const string dll_id(), const string help.function.name(), long is.default)",
    "description": "This function adds a new help function to the help functions. If the help.function.name resides in the same source file as in which the call to this gbf.set.help.function() is made, then the function gbf.current.library() can be used, so use: gbf.set.help.function(gbf.current.library(), �). Note that the help.function.name function must be defined as:",
    "arguments": [
      {
        "type": "const string",
        "name": "dll_id()",
        "description": "The name of the DLL."
      },
      {
        "type": "const string",
        "name": "help.function.name()",
        "description": "The name of the help function to find in the DLL."
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "If set to true the function is used as the default help function instead of a previous defined default or the standard gbf.help.selected() function."
      }
    ],
    "returnValue": "> 1 The identification of this help function = 1 Should never be returned, as 1 is the GBF default GBF.ILL.DLL Illegal DLL specified GBF.ILL.FUNCTION Illegal function specified, or function not known in given DLL GBF.NO.MEMORY Not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.interior.icon": {
    "name": "gbf.set.interior.icon",
    "type": "function",
    "syntax": "function long gbf.set.interior.icon (const string icon.group(), const string unselected.closed(), const string unselected.open(), const string selected.closed(), string selected.open(), long is.default [, const string icon.desc()] [, long context.menu])",
    "description": "This function adds an interior node icon to the set of interior node icons. The return value, if non negative, must be used in subsequent gbf.add.object() calls to identify this icon set. Empty icons, in other words empty strings, are not allowed. It is not checked whether the icons are different, so for example it is allowed to have the same icon for both selected.open and selected.closed.",
    "arguments": [
      {
        "type": "const string",
        "name": "icon.group()",
        "description": "The icon.group must be a valid icon group as defined in table ttdsk900 Icon Groups using session ttdsk9100m000 Icon Groups."
      },
      {
        "type": "const string",
        "name": "unselected.closed()",
        "description": "The unselected.closed, unselected.open, selected.closed, selected.open should be valid icons as defined in table ttdsk903 Icons using session ttdsk9103m000 Icons."
      },
      {
        "type": "const string",
        "name": "unselected.open()",
        "description": ""
      },
      {
        "type": "const string",
        "name": "selected.closed()",
        "description": ""
      },
      {
        "type": "string",
        "name": "selected.open()",
        "description": ""
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "If set to true this icon is used as the default interior node icon and the previous default interior node icon is overruled."
      },
      {
        "type": "[const string",
        "name": "icon.desc() ]",
        "description": "The icon.desc should be a message that contains the description of the icon. This icon.desc will be used when the GBF tree is printed. If not given or the message is empty then nothing will be printed. Also this text will be shown when help on icons is asked for via the Help -> Icon Descriptions."
      },
      {
        "type": "[long",
        "name": "context.menu ]",
        "description": "The argument is used when the user wants to couple a context menu to the icon (see gbf.create.context.menu() ). Every icon can have it�s own context.menu. This option will be overruled by the context menu given by gbf.add.object()"
      }
    ],
    "returnValue": "> 1 The identification of this new icon set = 1 Should never be returned, as 1 is the GBF default GBF.NO.MEMORY Not enough memory GBF.ICON.EMPTY Empty icon strings are not allowed GBF.ICON.LOAD.ERROR Could not load the icon GBF.ILL.BITMAP Illegal bitmap for icon (not a GIF file) GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.key.desc.length": {
    "name": "gbf.set.key.desc.length",
    "type": "function",
    "syntax": "function long gbf.set.key.desc.length (long key.length, long desc.length)",
    "description": "This function is used to define:",
    "arguments": [
      {
        "type": "long",
        "name": "key.length",
        "description": "The new key length. If 0 nothing happens."
      },
      {
        "type": "long",
        "name": "desc.length",
        "description": "The new description length. If 0 nothing happens."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LENGTH Key.length and/or desc.length < not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.key.length": {
    "name": "gbf.set.key.length",
    "type": "function",
    "syntax": "function long gbf.set.key.length (long key.length)",
    "description": "The following functions are actually defines and they are defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "key.length",
        "description": "The new key length."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LENGTH Key.length and/or desc.length < not enough memory GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.label *": {
    "name": "gbf.set.label *",
    "type": "function",
    "syntax": "function long gbf.set.label (const string label1, const string label2, const string label3, const string label4, const string label5)",
    "description": "The gbf.set.label<nr>() functions are actually defines and they are defined as:",
    "arguments": [
      {
        "type": "const string",
        "name": "label1",
        "description": "current action, like searching�, loading� and so"
      },
      {
        "type": "const string",
        "name": "label2",
        "description": "key of the current selected item"
      },
      {
        "type": "const string",
        "name": "label3",
        "description": "company number"
      },
      {
        "type": "const string",
        "name": "label4",
        "description": "company description"
      },
      {
        "type": "const string",
        "name": "label5",
        "description": "current date"
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NO.LABEL Trying to change a non existing label",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.leaf.icon": {
    "name": "gbf.set.leaf.icon",
    "type": "function",
    "syntax": "function long gbf.set.leaf.icon (const string icon.group(), string unselected(), const string selected(), long is.default [, const string icon.desc()] [, long context.menu])",
    "description": "Adds a leaf node icon to the set of leaf node icons. The return value, if positive, must be used in subsequent calls to identify this icon set. Empty icons, that is empty strings, are not allowed. It is not checked whether the icons are different, so for example it is allowed to have the same icon for both selected and unselected.",
    "arguments": [
      {
        "type": "const string",
        "name": "icon.group()",
        "description": "The icon.group must be a valid icon group as defined in table ttdsk900 Icon Groups using session ttdsk9100m000 Icon Groups."
      },
      {
        "type": "string",
        "name": "unselected()",
        "description": "The unselected and selected should be valid icons as defined in table ttdsk903 Icons using session ttdsk9103m000 Icons."
      },
      {
        "type": "const string",
        "name": "selected()",
        "description": ""
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "Indicates whether (if the value is true) or not (if the value is false) to use this icon set (if it could successfully be added) as the default leaf node icon set. If is.default is true then the previous default icon set is overruled."
      },
      {
        "type": "[const string",
        "name": "icon.desc() ]",
        "description": "A message that contains the description of the icon. This icon.desc will be used when the GBF tree is printed. If not given or the message is empty then nothing will be printed. Also this text will be shown when help on icons is asked for via the Help -> Icon Descriptions."
      },
      {
        "type": "[long",
        "name": "context.menu ]",
        "description": "The context.menu is used when the user wants to couple a context menu to the icon (see gbf.create.context.menu() ). Every icon can have it�s own context.menu. This option will be overruled by the context menu given by gbf.add.object()"
      }
    ],
    "returnValue": "> 1 The identification of this new icon set = 1 Should never be returned, as 1 is the GBF default GBF.NO.MEMORY Not enough memory GBF.ICON.EMPTY Empty icon strings are not allowed GBF.ICON.LOAD. ERROR Could not load the icon GBF.ILL.BITMAP Illegal bitmap for icon (not a GIF file) GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.checked": {
    "name": "gbf.set.menu.checked",
    "type": "function",
    "syntax": "function long gbf.set.menu.checked ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.disabled": {
    "name": "gbf.set.menu.disabled",
    "type": "function",
    "syntax": "function long gbf.set.menu.disabled ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.enabled": {
    "name": "gbf.set.menu.enabled",
    "type": "function",
    "syntax": "function long gbf.set.menu.enabled ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.function": {
    "name": "gbf.set.menu.function",
    "type": "function",
    "syntax": "function long gbf.set.menu.function (const string dll_id(), const string menu.function.id(), long is.default)",
    "description": "This function adds a function to the menu functions. For more information about dll_id and menu.function.id see the standard dll manual page in the programmers manual. The dll_id is tried to be loaded with the load_dll() function call, without overload. The return value, if positive, may be used in subsequent gbf.set.menu.item() calls to identify this special menu function.",
    "arguments": [
      {
        "type": "const string",
        "name": "dll_id()",
        "description": "The name of the DLL."
      },
      {
        "type": "const string",
        "name": "menu.function.id()",
        "description": "The menu function to find in the DLL."
      },
      {
        "type": "long",
        "name": "is.default",
        "description": "Indicates whether (if the value is true) or not (if the value is false) to use this menu function (if it could successfully be added) as the default menu function instead of a previous defined default or the standard gbf.menu.selected() function."
      }
    ],
    "returnValue": "> 1 The identification of this menu function = 1 Should never be returned, as 1 is the GBF default GBF.ILL.DLL Illegal DLL specified GBF.ILL.FUNCTION Illegal function specified, or function not known in given DLL GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.NO.MEMORY Not enough memory",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.head": {
    "name": "gbf.set.menu.head",
    "type": "function",
    "syntax": "function long gbf.set.menu.head (string menu.text [, long maskbit] [, long multi.mask])",
    "description": "Adds a menu header to the menu bar.",
    "arguments": [
      {
        "type": "string",
        "name": "menu.text",
        "description": "The menu.text should be a message. In this case the message is first translated to its actual value. So for example when menu.text is �ttgbfl0006� then this value will be: �File�. See also: gbf.set.menu.item() . The rest of this section keeps using the menu.text as if this is the actual menu header text."
      },
      {
        "type": "[long",
        "name": "maskbit ]",
        "description": "The maskbit can be used to disable a menu head depending on the menumask set with gbf.add.object() . The default value is 0."
      },
      {
        "type": "[long",
        "name": "multi.mask ]",
        "description": "The multi.mask is used to indicate what should happen when zero or more than one objects are selected. The least significant bit (lsb) is used to indicate whether the menu head should be disabled when no objects are selected. The second bit is used to indicate whether the menu head should be disabled when more than one objects are selected. The default value is GBF.ZERO.ENABLE + GBF.MULTI.ENABLE. The following defines should be used: � � GBF.ZERO.ENABLE menu head is enabled when zero objects are selected � � GBF.ZERO.DISABLE menu head is disabled when zero objects are selected � � GBF.MULTI.ENABLE menu head is enabled when more than one object is selected � � GBF.MULTI.DISABLE menu head is disabled when more than one object is selected"
      }
    ],
    "returnValue": "� 0 The identification of this new menu head GBF.NO.MEMORY Not enough memory GBF.MENU.EMPTY Empty menu text is not allowed GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.MAX.MENU Too many menus defined",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.state": {
    "name": "gbf.set.menu.state",
    "type": "function",
    "syntax": "function long gbf.set.menu.state (long menu.id, long item.id, long disable, long checked [, long radio])",
    "description": "The following functions are in fact defines and they are defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "menu.id",
        "description": "The menu identification"
      },
      {
        "type": "long",
        "name": "item.id",
        "description": "The return value of the function gbf.set.menu.item() when that function was successful completed."
      },
      {
        "type": "long",
        "name": "disable",
        "description": "When disable is set to true then the menu.id (if not 0) and item.id (if not 0) will become insensitive, that is white, which does not allow the end-user to select it. Also the associated keystroke with this item.id is not useable as long as this menu.id is disabled. The menu.id and item.id can become selectable again by using false for disable."
      },
      {
        "type": "long",
        "name": "checked",
        "description": "When checked is true a ticmark will be added in front of the menu.id (if not 0) and item.id (if not 0). When checked is false these ticmarks will be removed again."
      },
      {
        "type": "[long",
        "name": "radio ]",
        "description": "When radio is given and true and checked is false and item.id is not 0, then a radio button (small circle) will be added in front of this menu.id. These radio buttons should be used to indicate which of the possible alternatives is the current selected option. See, for example, the standard Find or Sort menu."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.item": {
    "name": "gbf.set.menu.item",
    "type": "function",
    "syntax": "function long gbf.set.menu.item (long menu.id, const string menu.text(), const string keystroke() [, long is.default] [, long menu.function.id], long maskbit [, long multi.mask], long std.button)",
    "description": "Adds a menu item to the set of menu items under the heading as identified by menu.id, as well as it allows to assign a keystroke combination (such as <Ctrl>+A and so on.) and connect it to a standard GBF button which the GBF does not service itself.",
    "arguments": [
      {
        "type": "long",
        "name": "menu.id",
        "description": "The menu identification."
      },
      {
        "type": "const string",
        "name": "menu.text()",
        "description": "Both menu.text and keystroke should be messages. In this case the message is first translated to its actual value. So for example when menu.text is �ttgbfl0006� then this value will be: �File�. The reason why messages are preferred over (hard coded) text is that help associated to that message will be called when the context help is asked for for this menu or keystroke. The rest of this section keeps using the menu.text and keystroke as if these are the actual menu texts and keystrokes. At least menu.text or keystroke must be specified: � � If the menu.text is �---� (3 minutes) then only a menu separator line is drawn in the menu which can never be selected and will generate a 0 return value. Note that the keystroke should be empty in this case. Also only BW supports these menu separator lines, but no error is generated when using this under BX. Note that for these menu separator also the function gbf.set.menu.seperator() should be used. � � If the menu.text is non empty then the menu.id must be a value returned by a preceding gbf.set.menu.head() call."
      },
      {
        "type": "const string",
        "name": "keystroke()",
        "description": "The keystroke may be empty, in which case no special keystroke recognition is done for this menu item. The keystroke will be added to the menu on the right hand side of the menu entry. The first character in the menu.id which is preceded by an �&� will become underscored which allows you to select that menu item by typing that underscored character at the moment the menu is dropped down. This however is not considered to be a keystroke in this manual. � � If the menu.text is empty, then the keystroke is added to an anonymous menu (menu.id is ignored in this case). The return value of this function (if > 0) will be the value which is used when the menu is activated or the keystroke is recognized. The GBF does not check whether this keystroke is already in use (when the specified keystroke is not empty), and it is left undetermined which value will be given when the keystroke is recognized, in this ambiguous case. The format of the keystroke is: [Ctrl+][Shift+][Alt+](<single char>|F<nr>|<special key>) where: Ctrl"
      }
    ],
    "returnValue": "> 1 The identification of this new menu entry = 1 Should never be returned, as 1 is the GBF default 0 Menu separator line added GBF.NO.MEMORY Not enough memory GBF.MENU.EMPTY Empty menu text is not allowed GBF.ILL.MENU.ID Illegal menu.id value GBF.ILL.FUNCTION Illegal menu.function.id value GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.MAX.MENU Too many submenus for this menu defined",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.not.checked": {
    "name": "gbf.set.menu.not.checked",
    "type": "function",
    "syntax": "function long gbf.set.menu.not.checked ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.not.radio": {
    "name": "gbf.set.menu.not.radio",
    "type": "function",
    "syntax": "function long gbf.set.menu.not.radio ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.radio": {
    "name": "gbf.set.menu.radio",
    "type": "function",
    "syntax": "function long gbf.set.menu.radio ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.MENU.ID Unknown menu.id or item.id specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.menu.separator": {
    "name": "gbf.set.menu.separator",
    "type": "function",
    "syntax": "function long gbf.set.menu.separator (long menu.id)",
    "description": "This function (actually: define) adds a separator to the given menu. A menu separator line is drawn in the menu which can never be selected and will generate a 0 return value. Also only BW supports these menu separator lines, but no error is generated when using this under BX.",
    "arguments": [
      {
        "type": "long",
        "name": "menu.id",
        "description": "The menu identification."
      }
    ],
    "returnValue": "0 Menu separator line added GBF.NO.MEMORY Not enough memory GBF.MENU.EMPTY Empty menu text is not allowed GBF.ILL.MENU.ID Illegal menu.id value GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.MAX.MENU Too many submenus for this menu defined",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.open.child *": {
    "name": "gbf.set.open.child *",
    "type": "function",
    "syntax": "function long gbf.set.open.child (long open.strategy)",
    "description": "gbf.set.open.child() The function gbf.set.open.child() deals with what to do with the children when reopening an interior node. The open.strategy in this case may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "open.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OPEN.TYPE Unknown open.strategy specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.open.depth": {
    "name": "gbf.set.open.depth",
    "type": "function",
    "syntax": "function long gbf.set.open.depth (long open.depth)",
    "description": "Sets the current open and read depth.",
    "arguments": [
      {
        "type": "long",
        "name": "open.depth",
        "description": "The number of levels the GBF will display when opening an interior node (double click on interior node or select one and press ENTER etc). When not all these levels have been read yet, the GBF will read the necessary levels. The default value for open.depth is 1. The special mnemonic GBF.READ.ALL can be used to identify that all available levels are read and opened, that is all the way down to either a cycle has been detected or a leaf node has been reached."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LEVEL Open.depth is not a valid number of levels: < 0 GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.open.strategy *": {
    "name": "gbf.set.open.strategy *",
    "type": "function",
    "syntax": "function long gbf.set.open.strategy (long open.strategy)",
    "description": "These functions set the open or close strategy, which is what the GBF should do when an interior node is closed and opened again as well as what should be done on the Open All menu item or Ctrl+O keystroke.",
    "arguments": [
      {
        "type": "long",
        "name": "open.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OPEN.TYPE Unknown open.strategy specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.open.read *": {
    "name": "gbf.set.open.read *",
    "type": "function",
    "syntax": "function long gbf.set.open.read (long open.strategy)",
    "description": "gbf.set.open.read() The function gbf.set.open.read() deals with the Open All (Ctrl+O) menu item (keystroke) action. It determines what should be done on this action. The open.strategy in this case may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "open.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OPEN.TYPE Unknown open.strategy specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.open.what *": {
    "name": "gbf.set.open.what *",
    "type": "function",
    "syntax": "function long gbf.set.open.what (long open.strategy)",
    "description": "gbf.set.open.what() The function gbf.set.open.what() determines on which object the Open All (Ctrl+O) menu item (keystroke) action works. The open.strategy in this case may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "open.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.OPEN.TYPE Unknown open.strategy specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.print.options": {
    "name": "gbf.set.print.options",
    "type": "function",
    "syntax": "function long gbf.set.print.options (long print.options)",
    "description": "This function sets the print options.",
    "arguments": [
      {
        "type": "long",
        "name": "print.options",
        "description": "The print.options is a combination of the following options. All these options should be added (bitwise) to construct the actual print.options value: Whether or not icon descriptions must be printed: GBF.PRINT.NO.ICONS"
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.read.levels": {
    "name": "gbf.set.read.levels",
    "type": "function",
    "syntax": "function long gbf.set.read.levels (long read.levels [, long show.levels])",
    "description": "Sets the current number of levels that will be read (and shown) when an application returns one of the restart return values (see: gbf.menu.selected() : for example the GBF.DO.RESTART.TREE).",
    "arguments": [
      {
        "type": "long",
        "name": "read.levels",
        "description": "The number of levels that will be read."
      },
      {
        "type": "[long",
        "name": "show.levels ]",
        "description": "The number of levels that will be shown. (if not given show.levels will be set to the value of read.levels)"
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LEVEL Read.levels and/or show.levels < 0 GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.refresh.strategy": {
    "name": "gbf.set.refresh.strategy",
    "type": "function",
    "syntax": "function long gbf.set.refresh.strategy (long refresh.rate, long refresh.type)",
    "description": "Sets the automatic refresh rate and strategy, which means that after refresh.rate milliseconds the tree as maintained by GBF will be refreshed using the indicated strategy. A value of 0 for refresh.rate means no automatic refreshing and that refresh.type is ignored. The timing starts immediately after this function call when the GBF is already active, or immediately after the gbf.start() call.",
    "arguments": [
      {
        "type": "long",
        "name": "refresh.rate",
        "description": "The number of milliseconds between refreshes. A value of 0 means no automatic refreshing and that the refresh.type may be ignored."
      },
      {
        "type": "long",
        "name": "refresh.type",
        "description": "The refresh.type may be one of the following: GBR.REFRESH.ALL refresh the whole tree, including what is not open GBF.REFRESH.OPEN refresh only what is open, so when an interior node is closed, its child nodes will not be updated."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.REFRESH. RATE Illegal (negative) refresh.rate GBF.ILL.REFRESH. TYPE Unknown refresh.type specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.resource": {
    "name": "gbf.set.resource",
    "type": "function",
    "syntax": "function long gbf.set.resource (long resource.type, void resource.value)",
    "description": "This function sets the resources given by resource.type to the given resource.value. The arguments are given in name value pairs.",
    "arguments": [
      {
        "type": "long",
        "name": "resource.type",
        "description": "The resource type of which to set the value."
      },
      {
        "type": "void",
        "name": "resource.value",
        "description": "The value for the resource type."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.RESOURCE. TYPE Unknown resource type specified GBF.ILL.RESOURCE. VALUE Value for given resource type is not valid GBF.ILL.STATE GBF is not in the right state to deal with this function gbf.get.resource() Generic Browser Framework (GBF) overview Generic Browser Framework (GBF) synopsis Typical usage Getting started Example Generic Browser Framework error codes and return values standard menu items and function keys Messages and questions",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.search.headers *": {
    "name": "gbf.set.search.headers *",
    "type": "function",
    "syntax": "function long gbf.set.search.headers (long search.strategy)",
    "description": "gbf.set.search.headers() Finally the function gbf.set.search.headers() defines whether header objects (see: gbf.add.header() ) should be included or excluded from the search. The search.strategy may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "search.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SEARCH. TYPE Unknown search strategy GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.search.sensitive *": {
    "name": "gbf.set.search.sensitive *",
    "type": "function",
    "syntax": "function long gbf.set.search.sensitive (long search.strategy)",
    "description": "gbf.set.search.sensitive() The function gbf.set.search.sensitive() defines whether or not the case must match. The search.strategy may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "search.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SEARCH. TYPE Unknown search strategy GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.search.set *": {
    "name": "gbf.set.search.set *",
    "type": "function",
    "syntax": "function long gbf.set.search.set (long search.strategy)",
    "description": "gbf.set.search.set() The function gbf.set.search.set() defines the set in which the wanted object is to be searched in. The search.strategy may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "search.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SEARCH. TYPE Unknown search strategy GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.search.what *": {
    "name": "gbf.set.search.what *",
    "type": "function",
    "syntax": "function long gbf.set.search.what (long search.strategy)",
    "description": "gbf.set.search.what() The function gbf.set.search.what() defines what to search for. The search.strategy may be one of:",
    "arguments": [
      {
        "type": "long",
        "name": "search.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SEARCH. TYPE Unknown search strategy GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.search.strategy *": {
    "name": "gbf.set.search.strategy *",
    "type": "function",
    "syntax": "function long gbf.set.search.strategy (long search.strategy)",
    "description": "The function gbf.set.search.strategy sets the search strategy, which means that starting with the next search, this strategy will be used.",
    "arguments": [
      {
        "type": "long",
        "name": "search.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SEARCH. TYPE Unknown search strategy GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.selected": {
    "name": "gbf.set.selected",
    "type": "function",
    "syntax": "function void gbf.set.selected (long obj.id)",
    "description": "This function can be used to set the selected object in a GBF",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      }
    ],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.sort.strategy": {
    "name": "gbf.set.sort.strategy",
    "type": "function",
    "syntax": "function long gbf.set.sort.strategy (long sort.strategy)",
    "description": "This function sets the automatic sort strategy, which tells the GBF how to sort the child nodes of an interior node. The sort.strategy is the same for the whole tree, that is it is not possible to define different sort strategies for different interior nodes. If this is really wanted, then the application should be doing the sorting.",
    "arguments": [
      {
        "type": "long",
        "name": "sort.strategy",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.SORT.TYPE Unknown sort strategy specified GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.std.menu.checked *": {
    "name": "gbf.set.std.menu.checked *",
    "type": "function",
    "syntax": "function long gbf.set.std.menu.checked ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.std.menu.disabled *": {
    "name": "gbf.set.std.menu.disabled *",
    "type": "function",
    "syntax": "function long gbf.set.std.menu.disabled ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.std.menu.enabled *": {
    "name": "gbf.set.std.menu.enabled *",
    "type": "function",
    "syntax": "function long gbf.set.std.menu.enabled ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.std.menu *": {
    "name": "gbf.set.std.menu *",
    "type": "function",
    "syntax": "function long gbf.set.std.menu (long menu.pattern, long disabled, checked Parameter)",
    "description": "The following functions are in fact defines and they are defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "menu.pattern",
        "description": "The menu.pattern holds the pattern of all standard menu items which should be updated."
      },
      {
        "type": "long",
        "name": "disabled",
        "description": "When disable is set to true all of the specified standard GBF menu items and headings will be disabled. Also the associated keystroke with this menu.pattern is not usable as long as these menu items are disabled. These standard GBF menu items can become selectable again by setting this parameter to false."
      },
      {
        "type": "checked",
        "name": "Parameter",
        "description": "If true a ticmark will be added in front of all of the specified standard GBF menu items and headings. When checked is set to false these ticmarks will be removed again."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.std.menu.not.checked *": {
    "name": "gbf.set.std.menu.not.checked *",
    "type": "function",
    "syntax": "function long gbf.set.std.menu.not.checked ()",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [],
    "returnValue": "0 Successful completion GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.tree.report.subtitle": {
    "name": "gbf.set.tree.report.subtitle",
    "type": "function",
    "syntax": "function void gbf.set.tree.report.subtitle (const string sub.title(80) mb)",
    "description": "This function can be used to set the subtitle for the ASCII print report. The default value for this variable, which represents a subtitle for this report, is",
    "arguments": [
      {
        "type": "const string",
        "name": "sub.title(80) mb",
        "description": "The subtitle for the ASCII print report."
      }
    ],
    "returnValue": "None",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.set.view.depth": {
    "name": "gbf.set.view.depth",
    "type": "function",
    "syntax": "function long gbf.set.view.depth (long view.depth)",
    "description": "Sets the current view depth.",
    "arguments": [
      {
        "type": "long",
        "name": "view.depth",
        "description": "The number of levels the GBF will display when the Open Level option in the File Menu is executed. The value must be > 0. If the value is 1, only the top-level node with its direct children remain open. Special value GBF.READ.ALL can be specified to open all levels."
      }
    ],
    "returnValue": "0 Successful completion GBF.ILL.LEVEL Open.depth is not a valid number of levels: < 0",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.start": {
    "name": "gbf.start",
    "type": "function",
    "syntax": "function long gbf.start (long read.levels, long show.levels)",
    "description": "Activates the GBF,in other words it takes over control from the application. See also gbf.init() for more information.",
    "arguments": [
      {
        "type": "long",
        "name": "read.levels",
        "description": "See above."
      },
      {
        "type": "long",
        "name": "show.levels",
        "description": "See above."
      }
    ],
    "returnValue": "0 Successful completion GBF.NO.MEMORY Not enough memory GBF.ILL.LEVEL Illegal read.levels or show.levels given GBF.ILL.STATE GBF is not in the right state to deal with this function GBF.CHILD.ABORT Exited on a child request, see gbf.menu.action()",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.deffunc": {
    "name": "gbf.update.deffunc",
    "type": "function",
    "syntax": "function long gbf.update.deffunc (long obj.id, long def.func)",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "long",
        "name": "def.func",
        "description": "If GBF.USE.DEF.FUNC then use the default function, otherwise If GBF.NO.UPD.FUNC, then this function will not be changed, else this function will be used as the new default function (see gbf.add.object() for what the default function is supposed to do)."
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.desc": {
    "name": "gbf.update.desc",
    "type": "function",
    "syntax": "function long gbf.update.desc (long obj.id, string object.description() mb)",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "string",
        "name": "object.description() mb",
        "description": "If GBF.NO.UPD.DESC, then the description will not be changed. Otherwise this will be the new description for this object. Note that any other value for which isspace() returns true, such as for example: � �, the description will be invisible on the screen"
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.dropfunc": {
    "name": "gbf.update.dropfunc",
    "type": "function",
    "syntax": "function long gbf.update.dropfunc (long obj.id, long drop.function.id)",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "long",
        "name": "drop.function.id",
        "description": "If GBF.USE.DEF.FUNC then use the default function, otherwise If GBF.NO.UPD.FUNC, then this function will not be changed, else this function will be used as the new drag and drop function (see gbf.add.object() for what the drag and drop function is supposed to do)."
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.object *": {
    "name": "gbf.update.object *",
    "type": "function",
    "syntax": "function long gbf.update.object (long obj.id, string object.description() mb [, long icon.set] [, long default.function.id] [, long drop.function.id] [, long menumask] [, long text.color] [, long line.style])",
    "description": "All but gbf.update.object() are defines and these functions are defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "string",
        "name": "object.description() mb",
        "description": "If GBF.NO.UPD.DESC, then the description will not be changed. Otherwise this will be the new description for this object. Note that any other value for which isspace() returns true, such as for example: � �, the description will be invisible on the screen"
      },
      {
        "type": "[long",
        "name": "icon.set ]",
        "description": "If GBF.USE.DEF.ICON then use the default icon, otherwise If GBF.NO.UPD.ICON, then the icon will not be changed, else this icon set will now be used"
      },
      {
        "type": "[long",
        "name": "default.function.id ]",
        "description": "If GBF.USE.DEF.FUNC then use the default function, otherwise If GBF.NO.UPD.FUNC, then this function will not be changed, else this function will be used as the new default function (see gbf.add.object() for what the default function is supposed to do)."
      },
      {
        "type": "[long",
        "name": "drop.function.id ]",
        "description": "If GBF.USE.DEF.FUNC then use the default function, otherwise If GBF.NO.UPD.FUNC, then this function will not be changed, else this function will be used as the new drag and drop function (see gbf.add.object() for what the drag and drop function is supposed to do)."
      },
      {
        "type": "[long",
        "name": "menumask ]",
        "description": "If GBF.NO.UPD.MENU then the menumask will not be changed, otherwise this will be the new menu mask"
      },
      {
        "type": "[long",
        "name": "text.color ]",
        "description": "If 0 then the color of the text will not be changed (note: not even set to the default color), otherwise this will be the new color of the object.description text."
      },
      {
        "type": "[long",
        "name": "line.style ]",
        "description": "If given and GBF.LINE.SOLID (which happens to be 0) then a solid line will be used, otherwise a GBF.LINE.DASHED will draw dashed line to the parent. When this item is not given the object will use the line style it already had."
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.icon": {
    "name": "gbf.update.icon",
    "type": "function",
    "syntax": "function long gbf.update.icon (long obj.id, long icon.set)",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "long",
        "name": "icon.set",
        "description": "If GBF.USE.DEF.ICON then use the default icon, otherwise If GBF.NO.UPD.ICON, then the icon will not be changed, else this icon set will now be used"
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "gbf.update.menumask": {
    "name": "gbf.update.menumask",
    "type": "function",
    "syntax": "function long gbf.update.menumask (long obj.id, long menumask)",
    "description": "This function is in fact a define and is defined as:",
    "arguments": [
      {
        "type": "long",
        "name": "obj.id",
        "description": "The object identification"
      },
      {
        "type": "long",
        "name": "menumask",
        "description": "If GBF.NO.UPD.MENU then the menumask will not be changed, otherwise this will be the new menu mask"
      }
    ],
    "returnValue": "= 0 Successful completion GBF.ILL.ICON Illegal icon.set identification GBF.ILL.FUNCTION Illegal default.function.id or drop.function.id value GBF.ILL.OBJECT Illegal obj.id given GBF.ILL.STATE GBF is not in the right state to deal with this function",
    "category": "functions_generic_browser_frameworkf"
  },
  "messages and questions": {
    "name": "Messages and questions",
    "type": "function",
    "syntax": "function Messages and questions()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "generic browser framework (gbf) overview": {
    "name": "Generic Browser Framework (GBF) overview",
    "type": "function",
    "syntax": "function Generic Browser Framework (GBF) overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "standard menu items and function keys": {
    "name": "standard menu items and function keys",
    "type": "function",
    "syntax": "function standard menu items and function keys()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "generic browser framework (gbf) synopsis": {
    "name": "Generic Browser Framework (GBF) synopsis",
    "type": "function",
    "syntax": "function Generic Browser Framework (GBF) synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "typical usage": {
    "name": "Typical usage",
    "type": "function",
    "syntax": "function Typical usage()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_generic_browser_frameworkf"
  },
  "get.bi.server.location": {
    "name": "get.bi.server.location",
    "type": "function",
    "syntax": "function string get.bi.server.location ()",
    "description": "This function returns the location of the BI Server linked to the current package combination. If the current package combination has no specific BI server linked to it, the function returns the BI server that is not linked to any package combination.",
    "arguments": [],
    "returnValue": "filled URL of the BI Server. empty If BI Server not configured.",
    "category": "functions_graph"
  },
  "is.graph.present": {
    "name": "is.graph.present",
    "type": "function",
    "syntax": "function boolean is.graph.present ()",
    "description": "This function indicates whether there are active graph defined for this session. This function can be used to determine if additional operations/calculations are needed for a graph.",
    "arguments": [],
    "returnValue": "true the session is part of an active graph false otherwise",
    "category": "functions_graph"
  },
  "graph on form overview": {
    "name": "Graph on Form Overview",
    "type": "function",
    "syntax": "function Graph on Form Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_graph"
  },
  "refresh.graph": {
    "name": "refresh.graph",
    "type": "function",
    "syntax": "function void refresh.graph ()",
    "description": "This function forces the display of all graph fields based on the most recent data (the current record buffer, the calculations made based on the current record buffer) of the session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_graph"
  },
  "graph on form synopsis": {
    "name": "Graph on Form synopsis",
    "type": "function",
    "syntax": "function Graph on Form synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_graph"
  },
  "http client examples": {
    "name": "HTTP Client examples",
    "type": "function",
    "syntax": "function HTTP Client examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.connect": {
    "name": "http.connect",
    "type": "function",
    "syntax": "function long http.connect (const string url, ... )",
    "description": "Sends a CONNECT HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.delete": {
    "name": "http.delete",
    "type": "function",
    "syntax": "function long http.delete (const string url, ... )",
    "description": "Sends a DELETE HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.get": {
    "name": "http.get",
    "type": "function",
    "syntax": "function long http.get (const string url, ... )",
    "description": "Sends a GET HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.head": {
    "name": "http.head",
    "type": "function",
    "syntax": "function long http.head (const string url, ... )",
    "description": "Sends a HEAD HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.header.name": {
    "name": "http.header.name",
    "type": "function",
    "syntax": "function string http.header.name (long object.header)",
    "description": "Returns the HTTP header name of an http.header object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.header",
        "description": "http header object"
      }
    ],
    "returnValue": "the HTTP header name",
    "category": "functions_http_client"
  },
  "http.header.next": {
    "name": "http.header.next",
    "type": "function",
    "syntax": "function long http.header.next (long object.header)",
    "description": "Returns an http.header object's next http.header object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.header",
        "description": "http header object"
      }
    ],
    "returnValue": "the next http.header object, or 0 if there is no next http.header",
    "category": "functions_http_client"
  },
  "http.header.value": {
    "name": "http.header.value",
    "type": "function",
    "syntax": "function string header.value (long object.header)",
    "description": "Returns the HTTP header value of an http.header object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.header",
        "description": "http header object"
      }
    ],
    "returnValue": "the HTTP header value",
    "category": "functions_http_client"
  },
  "http.headerlist.add": {
    "name": "http.headerlist.add",
    "type": "function",
    "syntax": "function void http.headerlist.add (long object.headerlist, const string name, const string value)",
    "description": "Adds a name-value HTTP header pair to an http.headerlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.headerlist",
        "description": "an http.headerlist object"
      },
      {
        "type": "const string",
        "name": "name",
        "description": "an HTTP header name"
      },
      {
        "type": "const string",
        "name": "value",
        "description": "the value of the HTTP header"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.headerlist.add_list": {
    "name": "http.headerlist.add_list",
    "type": "function",
    "syntax": "function void http.headerlist.add_list (long object.headerlist, long list)",
    "description": "Adds the contents of another http.headerlist to an http.headerlist object. When an HTTP header already exists, it is overwritten.",
    "arguments": [
      {
        "type": "long",
        "name": "object.headerlist",
        "description": "an http.headerlist object"
      },
      {
        "type": "long",
        "name": "list",
        "description": "another http.headerlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.headerlist.delete": {
    "name": "http.headerlist.delete",
    "type": "function",
    "syntax": "function void http.headerlist.delete (long object.headerlist)",
    "description": "Deletes an http.headerlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.headerlist",
        "description": "an http.headerlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.headerlist.first": {
    "name": "http.headerlist.first",
    "type": "function",
    "syntax": "function long http.headerlist.first (long object.headerlist)",
    "description": "Returns the first http.header object of an http.headerlist. This can be used to iterate all HTTP headers in the list.",
    "arguments": [
      {
        "type": "long",
        "name": "object.headerlist",
        "description": "an http.headerlist object"
      }
    ],
    "returnValue": "the first http.header object in the list, or 0 if the list is empty",
    "category": "functions_http_client"
  },
  "http.headerlist.get": {
    "name": "http.headerlist.get",
    "type": "function",
    "syntax": "function long http.headerlist.get (long object.headerlist)",
    "description": "Gets the HTTP header with the specified name from an http.headerlist object. The HTTP header is returned as an http.header object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.headerlist",
        "description": "an http.headerlist object"
      }
    ],
    "returnValue": "the first http.header object in the list, or 0 if the list is empty",
    "category": "functions_http_client"
  },
  "http.headerlist.new": {
    "name": "http.headerlist.new",
    "type": "function",
    "syntax": "function long http.headerlist.new (... )",
    "description": "Constructs a new http.headerlist object. It is possible to initialize the http.headerlist object with HTTP header name-value pairs.",
    "arguments": [
      {
        "type": "...",
        "name": "",
        "description": "pairs of name and value parameters; they can be of any type but will be converted to strings"
      }
    ],
    "returnValue": "a new http.headerlist object, or 0 in case of an error",
    "category": "functions_http_client"
  },
  "http.options": {
    "name": "http.options",
    "type": "function",
    "syntax": "function long http.options (const string url, ... )",
    "description": "Sends an OPTIONS HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.patch": {
    "name": "http.patch",
    "type": "function",
    "syntax": "function long http.patch (const string url, ... )",
    "description": "Sends a PATCH HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.post": {
    "name": "http.post",
    "type": "function",
    "syntax": "function long http.post (const string url, ... )",
    "description": "Sends a POST HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.put": {
    "name": "http.put",
    "type": "function",
    "syntax": "function long http.put (const string url, ... )",
    "description": "Sends a PUT HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.queryparamlist.add": {
    "name": "http.queryparamlist.add",
    "type": "function",
    "syntax": "function void http.queryparamlist.add (long object.queryparamlist, const string name, const string value)",
    "description": "Adds a name-value query parameter pair to an http.queryparamlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.queryparamlist",
        "description": "an http.queryparamlist object"
      },
      {
        "type": "const string",
        "name": "name",
        "description": "the name of a query parameter"
      },
      {
        "type": "const string",
        "name": "value",
        "description": "the value of a query parameter"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.queryparamlist.add_list": {
    "name": "http.queryparamlist.add_list",
    "type": "function",
    "syntax": "function void http.queryparamlist.add_list (long object.queryparamlist, long name)",
    "description": "Adds the contents of another http.queryparamlist to an http.queryparamlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.queryparamlist",
        "description": "an http.queryparamlist object"
      },
      {
        "type": "long",
        "name": "name",
        "description": "another http.queryparamlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.queryparamlist.delete": {
    "name": "http.queryparamlist.delete",
    "type": "function",
    "syntax": "function void http.queryparamlist.delete (long object.queryparamlist)",
    "description": "Deletes an http.queryparamlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.queryparamlist",
        "description": "an http.queryparamlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.queryparamlist.new": {
    "name": "http.queryparamlist.new",
    "type": "function",
    "syntax": "function long http.queryparamlist.new (... )",
    "description": "Constructs a new http.queryparamlist object. It is possible to initialize the http.queryparamlist object with name-value query parameter pairs. When the http.queryparamlist object is passed to eg. http.get(), the name and value pairs will be used to build a url-encoded querystring. The querystring is then appended to the url after the '?' sign. Example:",
    "arguments": [
      {
        "type": "...",
        "name": "",
        "description": "pairs of name and value parameters; they can be of any type and should not yet have been url-encoded"
      }
    ],
    "returnValue": "a new http.queryparamlist object, or 0 in case of an error",
    "category": "functions_http_client"
  },
  "http.response.bodystream": {
    "name": "http.response.bodystream",
    "type": "function",
    "syntax": "function long http.response.bodystream (long object.response)",
    "description": "Returns the body stream id of the response. It is not necessary to rewind the stream, the position is already at the start of the data retrieved from the server. In case a stream id was passed using the HTTP_RESPONSE_BODY option, this returns that stream id.",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "a stream id",
    "category": "functions_http_client"
  },
  "http.response.curlcode": {
    "name": "http.response.curlcode",
    "type": "function",
    "syntax": "function long http.response.curlcode (long object.response)",
    "description": "Returns the cURL code stored in the response object. A cURL code of 0 means OK. Any other code indicates that the HTTP request did not succeed. Use function http.response.error_message() to retrieve an english description of the error.",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "a cURL code",
    "category": "functions_http_client"
  },
  "http.response.delete": {
    "name": "http.response.delete",
    "type": "function",
    "syntax": "function void http.response.delete (long object.response)",
    "description": "Deletes an http.response object. If the response object contains a body stream that was automatically opened, the stream will be closed as well.",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.response.error_message": {
    "name": "http.response.error_message",
    "type": "function",
    "syntax": "function string http.response.error_message (long object.response)",
    "description": "Call this to retrieve an error message in case there was an error while sending the request. In case the cURL code is zero (0), this returns \"No error\"",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "an error message",
    "category": "functions_http_client"
  },
  "http.response.headerlist": {
    "name": "http.response.headerlist",
    "type": "function",
    "syntax": "function long http.response.headerlist (long object.response)",
    "description": "Returns the list of HTTP headers received from the server.",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "an http.headerlist object",
    "category": "functions_http_client"
  },
  "http.response.request_method": {
    "name": "http.response.request_method",
    "type": "function",
    "syntax": "function string http.response.request_method (long object.response)",
    "description": "Returns the HTTP method of the request for which the response was created. The HTTP method and the URL are stored to identify to what request the response object belongs",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "the HTTP request method, like \"GET\", \"POST\" etc.",
    "category": "functions_http_client"
  },
  "http.response.request_url": {
    "name": "http.response.request_url",
    "type": "function",
    "syntax": "function string http.response.request_url (long object.response)",
    "description": "Returns the URL of the request for which the response was created. The HTTP method and the URL are stored to identify to what request the response object belongs",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "the request URL",
    "category": "functions_http_client"
  },
  "http.response.statuscode": {
    "name": "http.response.statuscode",
    "type": "function",
    "syntax": "function long http.response.statuscode (long object.response)",
    "description": "Returns the HTTP response statuscode, like 200, 404 or 500, etc.",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "an HTTP statuscode",
    "category": "functions_http_client"
  },
  "http.response.statustext": {
    "name": "http.response.statustext",
    "type": "function",
    "syntax": "function string http.response.statustext (long object.response)",
    "description": "Returns the HTTP response status text, like \"OK\" (for 200), \"Not Found\" (for 404), \"Internal Server Error\" (for 500), etc",
    "arguments": [
      {
        "type": "long",
        "name": "object.response",
        "description": "an http.response object"
      }
    ],
    "returnValue": "an HTTP status text",
    "category": "functions_http_client"
  },
  "http.routeparamlist.add": {
    "name": "http.routeparamlist.add",
    "type": "function",
    "syntax": "function void http.routeparamlist.add (long object.routeparamlist, const string name, const string value)",
    "description": "Adds a name-value route parameter pair to an http.routeparamlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.routeparamlist",
        "description": "an http.routeparamlist object"
      },
      {
        "type": "const string",
        "name": "name",
        "description": "the name of a route parameter"
      },
      {
        "type": "const string",
        "name": "value",
        "description": "the value of a route parameter"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.routeparamlist.add_list": {
    "name": "http.routeparamlist.add_list",
    "type": "function",
    "syntax": "function void http.routeparamlist.add_list (long object.routeparamlist, long list)",
    "description": "Adds the contents of another http.routeparamlist to an http.routeparamlist object. If route parameters already exist, they are replaced.",
    "arguments": [
      {
        "type": "long",
        "name": "object.routeparamlist",
        "description": "an http.routeparamlist object"
      },
      {
        "type": "long",
        "name": "list",
        "description": "another http.routeparamlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.routeparamlist.delete": {
    "name": "http.routeparamlist.delete",
    "type": "function",
    "syntax": "function void http.routeparamlist.delete (long object.routeparamlist)",
    "description": "Deletes an http.routeparamlist object.",
    "arguments": [
      {
        "type": "long",
        "name": "object.routeparamlist",
        "description": "an http.routeparamlist object"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.routeparamlist.new": {
    "name": "http.routeparamlist.new",
    "type": "function",
    "syntax": "function void http.routeparamlist.new (... )",
    "description": "Constructs a new http.routeparamlist object. It is possible to initialize the http.routeparamlist object with name-value route parameter pairs. When the http.routeparamlist object is passed to eg. http.get(), the name and value pairs will be used to fill in route parameters in the url. Example:",
    "arguments": [
      {
        "type": "...",
        "name": "",
        "description": "pairs of name and value parameters"
      }
    ],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http.send": {
    "name": "http.send",
    "type": "function",
    "syntax": "function long http.send (const string method, const string url, ... )",
    "description": "Sends an HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "method",
        "description": "an HTTP method, like \"GET\", \"POST\", \"PUT\", etc."
      },
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http.trace": {
    "name": "http.trace",
    "type": "function",
    "syntax": "function long http.trace (const string url, ... )",
    "description": "Sends a TRACE HTTP request to a URL.",
    "arguments": [
      {
        "type": "const string",
        "name": "url",
        "description": "the URL to send the request to"
      },
      {
        "type": "...",
        "name": "",
        "description": "see http.send() for more information."
      }
    ],
    "returnValue": "an http.response object; check the response object for information about whether the request succeeded",
    "category": "functions_http_client"
  },
  "http client overview": {
    "name": "HTTP Client overview",
    "type": "function",
    "syntax": "function HTTP Client overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "http client synopsis": {
    "name": "HTTP Client synopsis",
    "type": "function",
    "syntax": "function HTTP Client synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_http_client"
  },
  "bind.image": {
    "name": "bind.image",
    "type": "function",
    "syntax": "function boolean bind.image (string fieldname, string guidField [, string tablename])",
    "description": "This function is used bind an image form field to the (table) field which holds the application GUID value. This function must be called from the after.form.read: section in the application UI script.",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname",
        "description": "The name of the image field on the form. This field must be declared as an external field of domain: ttdyf.picture ."
      },
      {
        "type": "string",
        "name": "guidField",
        "description": "The name of the field which will hold the GUID value used to link an image set to the application table. Usually this is a field in the current maintable."
      },
      {
        "type": "[string",
        "name": "tablename ]",
        "description": "Optional argument in which the name of the table to which this image is linked is passed. The default value is the current maintable."
      }
    ],
    "returnValue": "true When successful false When an error occurred",
    "category": "functions_images"
  },
  "check.image.present": {
    "name": "check.image.present",
    "type": "function",
    "syntax": "function boolean check.image.present (string guid [, string tablename] [, long width] [, long height])",
    "description": "This function will check if an image set is already present in the repository.",
    "arguments": [
      {
        "type": "string",
        "name": "guid",
        "description": "The unique identification which is assigned to this image set"
      },
      {
        "type": "[string",
        "name": "tablename ]",
        "description": "Optional argument in which the name of the table to which this image is linked is passed. The default value is the current maintable."
      },
      {
        "type": "[long",
        "name": "width ]",
        "description": "Optional argument for the width of the image."
      },
      {
        "type": "[long",
        "name": "height ]",
        "description": "Optional argument for the height of the image."
      }
    ],
    "returnValue": "true When this image set is present in the repository false otherwise",
    "category": "functions_images"
  },
  "copy.image": {
    "name": "copy.image",
    "type": "function",
    "syntax": "function long copy.image (string source.guid, string source.tablename, string target.guid, string target.tablename [, boolean overwrite])",
    "description": "This function will copy an image or set of images based on its guid into then image repository refered by the target guid. This function can be used when copying records.",
    "arguments": [
      {
        "type": "string",
        "name": "source.guid",
        "description": "The unique identification of an image existing in the repository."
      },
      {
        "type": "string",
        "name": "source.tablename",
        "description": "The name of that table to which the source image is linked."
      },
      {
        "type": "string",
        "name": "target.guid",
        "description": "The unique identification for the copy of the image."
      },
      {
        "type": "string",
        "name": "target.tablename",
        "description": "The name of that table to which the target image should be linked."
      },
      {
        "type": "[boolean",
        "name": "overwrite ]",
        "description": "If for the target guid/table already an image or set of images exist then these will be deleted and overwritten with the image (set) referred by the source.guid. Default value for overwrite is true."
      }
    ],
    "returnValue": "0 Successful -1 The target exist and overwrite was false -2 The source Image does not exist -3 The copy of the image failed",
    "category": "functions_images"
  },
  "copy.image.to.company": {
    "name": "copy.image.to.company",
    "type": "function",
    "syntax": "function long copy.image.to.company (long source.company, string source.guid, string source.tablename, long target.company, string target.guid, string target.tablename [, boolean overwrite] [, boolean omit.transaction])",
    "description": "This function will copy an image or set of images based on its guid into the image repository referred to by the target guid and company. This function can be used when copying records to a different company.",
    "arguments": [
      {
        "type": "long",
        "name": "source.company",
        "description": "The company for which the existing image is stored."
      },
      {
        "type": "string",
        "name": "source.guid",
        "description": "The unique identification of an image existing in the repository."
      },
      {
        "type": "string",
        "name": "source.tablename",
        "description": "The name of the table to which the source image is linked."
      },
      {
        "type": "long",
        "name": "target.company",
        "description": "The company to which the image should be copied."
      },
      {
        "type": "string",
        "name": "target.guid",
        "description": "The unique identification for the copy of the image."
      },
      {
        "type": "string",
        "name": "target.tablename",
        "description": "The name of the table to which the target image should be linked."
      },
      {
        "type": "[boolean",
        "name": "overwrite ]",
        "description": "If for the target guid/table image set already exists then these will be deleted and overwritten with the image set referred to by the source.guid. Default value for overwrite is true."
      },
      {
        "type": "[boolean",
        "name": "omit.transaction ]",
        "description": "If this function is called inside of a transaction, this argument must be set to true. Otherwise this function will start a new transaction, which will lead to errors. The default value for omit.transaction is false."
      }
    ],
    "returnValue": "0 Successful -1 The target exist and overwrite was false -2 The source Image does not exist -3 The copy of the image failed -4 Failed to call the copy function -5 The source and target image sets are equivalent after mapping logical tables",
    "category": "functions_images"
  },
  "discard.changed.image": {
    "name": "discard.changed.image",
    "type": "function",
    "syntax": "function void discard.changed.image (string fieldname)",
    "description": "This function will discard an image which was possibly dropped on an image control and discard the saved backup image after a delete. This function is usually called from the after.choice section of choice: recover.set .",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname",
        "description": "The name of the image field on the form."
      }
    ],
    "returnValue": "",
    "category": "functions_images"
  },
  "images on forms examples": {
    "name": "Images on Forms Examples",
    "type": "function",
    "syntax": "function Images on Forms Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_images"
  },
  "get.image.path": {
    "name": "get.image.path",
    "type": "function",
    "syntax": "function string get.image.path (string guid, long sequ [, string tablename] [, long width] [, long height])",
    "description": "This function will get the full path for an image.",
    "arguments": [
      {
        "type": "string",
        "name": "guid",
        "description": "The unique identification which is assigned to this image set"
      },
      {
        "type": "long",
        "name": "sequ",
        "description": "The one based image sequence number within the image set"
      },
      {
        "type": "[string",
        "name": "tablename ]",
        "description": "Optional argument in which the name of the table to which this image is linked is passed. The default value is the current maintable."
      },
      {
        "type": "[long",
        "name": "width ]",
        "description": "Optional argument for the width of the image."
      },
      {
        "type": "[long",
        "name": "height ]",
        "description": "Optional argument for the height of the image."
      }
    ],
    "returnValue": "The path for the requested image, empty string if the requested image cannot be found.",
    "category": "functions_images"
  },
  "is.image.changed": {
    "name": "is.image.changed",
    "type": "function",
    "syntax": "function boolean is.image.changed (string fieldname)",
    "description": "This function can be used to check if an image has been changed onto the image field or the image is changed which is not yet saved or discarded.",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname",
        "description": "The name of the image field on the form."
      }
    ],
    "returnValue": "true When an image is changed for this image field. false When no image is changed for this image field.",
    "category": "functions_images"
  },
  "is.image.dropped": {
    "name": "is.image.dropped",
    "type": "function",
    "syntax": "function boolean is.image.dropped (string fieldname)",
    "description": "This function can be used to check if an image has been dropped onto the image field or the image is deleted which is not yet saved or discarded.",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname",
        "description": "The name of the image field on the form."
      }
    ],
    "returnValue": "true When an image is changed for this image field. false When no image is changed for this image field.",
    "category": "functions_images"
  },
  "images on forms overview": {
    "name": "Images on Forms Overview",
    "type": "function",
    "syntax": "function Images on Forms Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_images"
  },
  "save.image.field": {
    "name": "save.image.field",
    "type": "function",
    "syntax": "function boolean save.image.field (string fieldname)",
    "description": "This function is used to save an image, which is dropped onto the image control, into the repository or delete the image from the repository if deleted by the user. When an image with the bound guid already exists, it will be overwritten. This function should be called from the after.update.db.commit: section in a UI script and is only allowed when the image field is bound using bind.image()",
    "arguments": [
      {
        "type": "string",
        "name": "fieldname",
        "description": "The name of the image field on the form."
      }
    ],
    "returnValue": "true When successful false When an error occurred",
    "category": "functions_images"
  },
  "save.image.file": {
    "name": "save.image.file",
    "type": "function",
    "syntax": "function boolean save.image.file (string guid, long sequence, string pathname [, string tablename])",
    "description": "This function will save an image file into the image repository (put it at proper place in directory and update the image table). This function can be used by an image import application.",
    "arguments": [
      {
        "type": "string",
        "name": "guid",
        "description": "The unique identification which will be assigned to this image set."
      },
      {
        "type": "long",
        "name": "sequence",
        "description": "A one based sequence number to identify a specific image in the set."
      },
      {
        "type": "string",
        "name": "pathname",
        "description": "The absolute pathname of the image file to be saved in the repository"
      },
      {
        "type": "[string",
        "name": "tablename ]",
        "description": "Optional argument in which the name of the table to which this image is linked is passed. The default value is the current maintable."
      }
    ],
    "returnValue": "true When successful false When an error occurred",
    "category": "functions_images"
  },
  "images on forms synopsis": {
    "name": "Images on Forms synopsis",
    "type": "function",
    "syntax": "function Images on Forms synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_images"
  },
  "byte arrays overview": {
    "name": "Byte arrays overview",
    "type": "function",
    "syntax": "function Byte arrays overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_ims"
  },
  "byte arrays synopsis": {
    "name": "Byte arrays synopsis",
    "type": "function",
    "syntax": "function Byte arrays synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_ims"
  },
  "ims.clearerr": {
    "name": "ims.clearerr",
    "type": "function",
    "syntax": "function long ims.clearerr (long bytearray)",
    "description": "Resets the error and end-of-byte-array indicator.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.close": {
    "name": "ims.close",
    "type": "function",
    "syntax": "function long ims.close (long bytearray)",
    "description": "Closes the byte array. This is done automaticallly when you leave your process.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.eof": {
    "name": "ims.eof",
    "type": "function",
    "syntax": "function long ims.eof (long bytearray)",
    "description": "Detects if the end of the byte array is reached.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Not at the end of the byte array. >0 The end of the byte array is detected.",
    "category": "functions_ims"
  },
  "ims.error": {
    "name": "ims.error",
    "type": "function",
    "syntax": "function long ims.error (long bytearray)",
    "description": "Detects if an error has occurred while reading from or writing to the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 No errors. >0 An error occurred.",
    "category": "functions_ims"
  },
  "ims.getc$": {
    "name": "ims.getc$",
    "type": "function",
    "syntax": "function string ims.getc$ (long bytearray)",
    "description": "Returns the next character from the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "If an empty string is returned, either the end of the string has been reached or an error has occurred.",
    "category": "functions_ims"
  },
  "ims.getproperties": {
    "name": "ims.getproperties",
    "type": "function",
    "syntax": "function long ims.getproperties (long bytearray, ref string buffer [, ref long size])",
    "description": "Returns the properties of the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      },
      {
        "type": "ref string",
        "name": "buffer",
        "description": "The contents of the byte array, this buffer must be declared BASED."
      },
      {
        "type": "[ref long",
        "name": "size ]",
        "description": "The number of bytes in the byte array, if specified."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.gets": {
    "name": "ims.gets",
    "type": "function",
    "syntax": "function long ims.gets (ref string line, long size, long bytearray [, long skip.mode] [, long there.was.more])",
    "description": "Reads characters from the byte array into a buffer ( line ).",
    "arguments": [
      {
        "type": "ref string",
        "name": "line",
        "description": "Stores the retrieved characters."
      },
      {
        "type": "long",
        "name": "size",
        "description": "The maximum number of bytes to be read. Note that the function stops retrieving characters when a new line character is read or when the end-of-file is reached."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      },
      {
        "type": "[long",
        "name": "skip.mode ]",
        "description": "If skip.mode is set to: 0: read until a new-line character 1: read until size or until end-of-byte-array is reached."
      },
      {
        "type": "[long",
        "name": "there.was.more ]",
        "description": "There are more characters in the byte array than there were read."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.openfba": {
    "name": "ims.openfba",
    "type": "function",
    "syntax": "function long ims.openfba (string buffer, long size, string type)",
    "description": "Opens a Fixed Byte Array (FBA).",
    "arguments": [
      {
        "type": "string",
        "name": "buffer",
        "description": "Stores the byte array. It may already contain information before the invocation of this function."
      },
      {
        "type": "long",
        "name": "size",
        "description": "Size of the buffer."
      },
      {
        "type": "string",
        "name": "type",
        "description": "The mode in which the byte array must be opened. This can be one of the following options: \"r\": Open for reading. The current position is placed at the start of the byte array. \"w\": Open for writing. The byte array is created if it does not already exist. The current position is placed at the start of the byte array. \"a\": Open for writing. The byte array is created if it does not already exist. The current position is placed at the end of the byte array. \"x\": Open for writing. This is the same as \"w\", except that the function fails if the byte array already exists. \"r+\": Same as \"r\", but it can also be written to. \"w+\": Same as \"w\", but it can also be read. \"a+\": Same as \"a\", but it can also be read. \"x+\": Same as \"x\", but it can also be read."
      }
    ],
    "returnValue": "-1 Error, most probably buffer is not a valid stream, the type is invalid or the byte array is full. >0 Success. A byte array identifier was returned..",
    "category": "functions_ims"
  },
  "ims.openvba": {
    "name": "ims.openvba",
    "type": "function",
    "syntax": "function long ims.openvba (string type [, long initialSize] [, long increment])",
    "description": "Opens a Variable Byte Array (VBA).",
    "arguments": [
      {
        "type": "string",
        "name": "type",
        "description": "The mode in which the byte array must be opened. This can be one of the following options: \"r\": Open for reading. The current position is placed at the start of the byte array. \"w\": Open for writing. The byte array is created if it does not already exist. The current position is placed at the start of the byte array. \"a\": Open for writing. The byte array is created if it does not already exist. The current position is placed at the end of the byte array. \"x\": Open for writing. This is the same as \"w\", except that the function fails if the byte array already exists. \"r+\": Same as \"r\", but it can also be written to. \"w+\": Same as \"w\", but it can also be read. \"a+\": Same as \"a\", but it can also be read. \"x+\": Same as \"x\", but it can also be read."
      },
      {
        "type": "[long",
        "name": "initialSize ]",
        "description": "The initial buffer size for the VBA. If not specified, the initial buffer size is 4096 bytes."
      },
      {
        "type": "[long",
        "name": "increment ]",
        "description": "Specifies the number of bytes to increment the VBA with, in case the VBA is full. If not specified, the buffer will be doubled in size."
      }
    ],
    "returnValue": "-1 Error, most probably bytearrray is not a valid stream or the byte array is full. >0 Success. A byte array identifier was returned.",
    "category": "functions_ims"
  },
  "ims.putc$": {
    "name": "ims.putc$",
    "type": "function",
    "syntax": "function string ims.putc$ (string char, long bytearray)",
    "description": "Writes a character to the current position in the byte array.",
    "arguments": [
      {
        "type": "string",
        "name": "char",
        "description": "The character to write to the byte array."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success. If no error occurs, the written character is returned. Otherwise, an empty string is returned.",
    "category": "functions_ims"
  },
  "ims.puts": {
    "name": "ims.puts",
    "type": "function",
    "syntax": "function long ims.puts (string line, long bytearray)",
    "description": "Writes a line (and a new-line character) to the byte array.",
    "arguments": [
      {
        "type": "string",
        "name": "line",
        "description": "The line to write to the byte array."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.r.long": {
    "name": "ims.r.long",
    "type": "function",
    "syntax": "function long ims.r.long (long bytearray)",
    "description": "Reads a 32-bit value from the byte array. The 4 bytes read from the byte array are interpreted as the 32-bit two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function reads 4 bytes from the byte array."
      }
    ],
    "returnValue": "return_value = -1 Error, most probably bytearray is not a valid stream, or end-of-byte-array reached. Notice that this error value -1 cannot be distinguished from normal value -1. This is problematic, unless it is known that value -1 is not expected as a normal value to be read from the byte array. -2^31 &#8804; return_value &#8804; 2^31 - 1 The numerical value of the first 4 bytes of the supplied byte array. This is a value in the signed 32-bit range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647]).",
    "category": "functions_ims"
  },
  "ims.r.short": {
    "name": "ims.r.short",
    "type": "function",
    "syntax": "function long ims.r.short (long bytearray)",
    "description": "Reads a 16-bit value from the byte array. The 2 bytes read from the byte array are interpreted as the 16-bit binary representation of an unsigned integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function reads 2 bytes from the byte array."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream, or end-of-byte-array reached. >=0 The numerical value of the first 2 bytes of the supplied byte array. This is a value in the unsigned 16-bit range [0 � 2^16 - 1] (i.e. [0 � 65,535]).",
    "category": "functions_ims"
  },
  "ims.r.utc": {
    "name": "ims.r.utc",
    "type": "function",
    "syntax": "function long ims.r.utc (long bytearray [, long byte.count])",
    "description": "Reads a specified amount of bytes from the byte array. The bytes read from the byte array are interpreted as the two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function reads an amount of bytes from the byte array as specified by byte.count ."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be read from the byte array. Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the (big endian) byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used."
      }
    ],
    "returnValue": "return_value = -1 Error, most probably bytearray is not a valid stream, or end-of-byte-array reached. Notice that this error value -1 cannot be distinguished from normal value -1. This is problematic, unless it is known that value -1 is not expected as a normal value to be read from the byte array. -(256^ byte.count )/2 &#8804; return_value &#8804; (256^ byte.count )/2 - 1 The numerical value of the bytes read from the supplied byte array. Typically, this is a (non-negative) UTC long format value stored earlier by the function ims.w.utc() , or prepared by any other means. This function does not perform any value check.",
    "category": "functions_ims"
  },
  "ims.read": {
    "name": "ims.read",
    "type": "function",
    "syntax": "function long ims.read (ref string buffer, long nrBytes, long bytearray)",
    "description": "Reads a number of bytes from the byte array into a buffer.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "The buffer that stores the bytes read from the byte array."
      },
      {
        "type": "long",
        "name": "nrBytes",
        "description": "The number of bytes to read from the byte array into the buffer."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 End-of-byte-array. >0 Number of bytes actually read.",
    "category": "functions_ims"
  },
  "ims.rewind": {
    "name": "ims.rewind",
    "type": "function",
    "syntax": "function long ims.rewind (long bytearray)",
    "description": "Sets the position in byte array to the beginning.",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.seek": {
    "name": "ims.seek",
    "type": "function",
    "syntax": "function long ims.seek (long offset, long opt, long bytearray)",
    "description": "Changes the current position within the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "offset",
        "description": "The number of bytes"
      },
      {
        "type": "long",
        "name": "opt",
        "description": "Can be set to the following values: 0 New position is set offset bytes from the beginning of the bytearray . 1 New position is set offset bytes from the current position. 2 New position is set offset bytes from the end of the bytearray ."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. >=0 New offset position from beginning of the byte array.",
    "category": "functions_ims"
  },
  "ims.setvbaproperties": {
    "name": "ims.setvbaproperties",
    "type": "function",
    "syntax": "function long ims.setvbaproperties (long bytearray, long increment)",
    "description": "Sets the properties of the Variable Byte Array (VBA).",
    "arguments": [
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba."
      },
      {
        "type": "long",
        "name": "increment",
        "description": "The number of bytes to increase the VBA with when needed."
      }
    ],
    "returnValue": "-1 Error, most probably bytearrray is not a variable byte array . 0 Success.",
    "category": "functions_ims"
  },
  "ims.skip": {
    "name": "ims.skip",
    "type": "function",
    "syntax": "function long ims.skip (long nrbytes, long bytearray)",
    "description": "Skips forward a number of bytes in the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "nrbytes",
        "description": "The number of bytes to skip in the byte array"
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.spool.line": {
    "name": "ims.spool.line",
    "type": "function",
    "syntax": "function long ims.spool.line (ref string line, long bytearray)",
    "description": "Spools a line and writes it to the byte array. The characters in the line are copied to the byte array until the last non-white character in the line is encountered. After that, the contents of the line is cleared.",
    "arguments": [
      {
        "type": "ref string",
        "name": "line",
        "description": "The line to spool to the byte array."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.tell": {
    "name": "ims.tell",
    "type": "function",
    "syntax": "function long ims.tell (long byetarray)",
    "description": "Returns the current offset within the byte array relative to the begin of the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "byetarray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. >=0 Offset, in number of bytes, within the byte array.",
    "category": "functions_ims"
  },
  "ims.w.long": {
    "name": "ims.w.long",
    "type": "function",
    "syntax": "function long ims.w.long (long value, long bytearray)",
    "description": "Writes a 32-bit integer value into the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the byte array. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-0x80000000 � 0x7fffffff] or [-2,147,483,648 � 2,147,483,647]). See store.long() for a description of explicit wrapping that might be done beforehand."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function writes 4 bytes into the byte array."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.w.short": {
    "name": "ims.w.short",
    "type": "function",
    "syntax": "function long ims.w.short (long value, long bytearray)",
    "description": "Writes a 16-bit integer value into the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the byte array It is not an error (but it is not encouraged) to supply a value outside the unsigned 16-bit value range [0 � 2^16 - 1] (i.e. [0 � 0xffff] or [0 � 65,535]), for which the inverse function ims.r.short() will retrieve the original supplied integer value. Explicit wrapping of the input value may be done beforehand by means of the 'remainder after division by 0x10000' operator \\ 0x10000 . However, for a negative input value, the result of the expression value \\ 0x10000 is still not in the desired range [0 � 0xffff] but in the range [-0xffff] � 0]. For complete wrapping to the desired range [0 � 0xffff], the following expression may be used: (value \\ 0x10000 + 0x10000) \\ 0x10000 . In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647])."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function writes 2 bytes into the byte array."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.w.utc": {
    "name": "ims.w.utc",
    "type": "function",
    "syntax": "function long ims.w.utc (long value, long bytearray [, long byte.count])",
    "description": "Writes an integer value into the byte array.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the byte array. Typically, this is a (non-negative) UTC long format value. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a negative value . When the bshell is in 64-bit mode, it is a fatal error to supply a value which cannot be stored in the available byte.count bytes without loss of information. Typically, this is the case when byte.count is 4 and the supplied value is outside the signed 32-bit value range, i.e. is greater than 2,147,483,647 (0x7fff,ffff), which corresponds to January 19, 2038, 03:14:07 UTC. When the bshell is in 64-bit mode, it is a fatal error to supply a value which is a UTC long format value greater than the current maximum DB.TIME domain value. Typically, this maximum is 253,402,214,400 (0x3a,fff2,f000), which corresponds to the begin of the last day of the last four-digit year, i.e. December 31, 9999, 00:00:00 UTC."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba. This function writes an amount of bytes to the byte array as specified by byte.count ."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be written to the byte array. Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the (big endian) byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 Success.",
    "category": "functions_ims"
  },
  "ims.write": {
    "name": "ims.write",
    "type": "function",
    "syntax": "function long ims.write (string buffer, long nrBytes, long bytearray)",
    "description": "Appends a given number of bytes from the buffer into the byte array, beginning at the current position in the byte array.",
    "arguments": [
      {
        "type": "string",
        "name": "buffer",
        "description": "The buffer that contains the bytes to write into the byte array relative to the current position in the byte array."
      },
      {
        "type": "long",
        "name": "nrBytes",
        "description": "The number of bytes to write from the buffer into the byte array."
      },
      {
        "type": "long",
        "name": "bytearray",
        "description": "The byte array identifier that is returned by ims.openvba or ims.openfba."
      }
    ],
    "returnValue": "-1 Error, most probably bytearray is not a valid stream. 0 End-of-byte-array. >0 Number of bytes actually written.",
    "category": "functions_ims"
  },
  "bms.add.mask": {
    "name": "bms.add.mask",
    "type": "function",
    "syntax": "function void bms.add.mask (string mask [, long processno])",
    "description": "This adds the specified mask to a process. If you specify a process number, the mask is added to that process. Otherwise, the mask is added to the current process.",
    "arguments": [
      {
        "type": "string",
        "name": "mask",
        "description": ""
      },
      {
        "type": "[long",
        "name": "processno ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "bms.delete.mask": {
    "name": "bms.delete.mask",
    "type": "function",
    "syntax": "function void bms.delete.mask (string mask [, long processno])",
    "description": "This removes the specified mask from a process. If you specify a process number, the mask is removed from that process. Otherwise, the mask is removed from the current process.",
    "arguments": [
      {
        "type": "string",
        "name": "mask",
        "description": ""
      },
      {
        "type": "[long",
        "name": "processno ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "bms.receive.buffer": {
    "name": "bms.receive.buffer",
    "type": "function",
    "syntax": "function long bms.receive.buffer (ref string broadcast, ref long no.bytes [, long level] [, long wait.flag] [, ref string mask])",
    "description": "Use this to receive a broadcast message. The function can retrieve a complete record, including �\\0� characters.",
    "arguments": [
      {
        "type": "ref string",
        "name": "broadcast",
        "description": "This returns the received broadcast message."
      },
      {
        "type": "ref long",
        "name": "no.bytes",
        "description": "This returns the number of bytes in the broadcast message."
      },
      {
        "type": "[long",
        "name": "level ]",
        "description": "This optional argument specifies a message level. The following values are available: 0 the function returns the first broadcast message sent to the process >0 the function returns the first broadcast message sent with the specified level <0 the function returns the first broadcast message sent with a level less than or equal to the absolute value of the specified level"
      },
      {
        "type": "[long",
        "name": "wait.flag ]",
        "description": "This optional argument indicates whether the process must wait for a broadcast message if no message has yet been sent: 0 wait <>0 do not wait If you include this argument, you must also include the level argument."
      },
      {
        "type": "[ref string",
        "name": "mask ]",
        "description": "This optional argument returns the mask (if any) sent with the message."
      }
    ],
    "returnValue": "The ID of the sending process.",
    "category": "functions_interprocess_communication_bshell"
  },
  "bms.receive$": {
    "name": "bms.receive$",
    "type": "function",
    "syntax": "function string bms.receive$ ( [ref long level] [, long wait.flag] [, ref string mask])",
    "description": "Use this to receive a broadcast message. If no arguments are included, the function returns the first broadcast message sent to the process.",
    "arguments": [
      {
        "type": "[ref long",
        "name": "level ]",
        "description": "This optional argument specifies a message level. The following values are available: 0 the function returns the first broadcast message sent to the process >0 the function returns the first broadcast message sent with the specified level <0 the function returns the first broadcast message sent with a level less than or equal to the absolute value of the specified level This argument returns the process ID of the sending process. The process ID overwrites the specified level."
      },
      {
        "type": "[long",
        "name": "wait.flag ]",
        "description": "This optional argument indicates whether the process must wait for a broadcast message if no message has yet been sent: 0 wait <>0 do not wait If you include this argument, you must also include the level argument."
      },
      {
        "type": "[ref string",
        "name": "mask ]",
        "description": "This optional argument returns the mask (if any) sent with the message."
      }
    ],
    "returnValue": "The received broadcast message.",
    "category": "functions_interprocess_communication_bshell"
  },
  "bms.send": {
    "name": "bms.send",
    "type": "function",
    "syntax": "function long bms.send (string broadcast, long level_or_evt, string mask, long processno [, long no.bytes])",
    "description": "Use this to send a broadcast message to one or more processes.",
    "arguments": [
      {
        "type": "string",
        "name": "broadcast",
        "description": "The message that must be sent."
      },
      {
        "type": "long",
        "name": "level_or_evt",
        "description": "Use this either to specify a level for the message (1 or 2, for example) or to specify an event array with the following information: evt.type( event ) this is always EVTBUCKETMESSAGE evt.bms.sender( event ) sender ID (this is filled automatically) evt.bms.command( event ) command ID evt.bms.argument( event ) some argument The specified event is sent to each process to which the broadcast message is sent."
      },
      {
        "type": "string",
        "name": "mask",
        "description": "If you specify a mask in this argument, the message is sent to all processes to which that mask has been added. If you also specify a process ID in the processno argument, the process is sent only to the specified process."
      },
      {
        "type": "long",
        "name": "processno",
        "description": "If you specify a process ID in this argument, the broadcast message is sent only to that process. If you specify 0 for this argument, the argument is used to indicate the processes to which the message is sent."
      },
      {
        "type": "[long",
        "name": "no.bytes ]",
        "description": "The size of the broadcast message, in bytes."
      }
    ],
    "returnValue": "0 error >0 the process ID of the last process to which the broadcast message was sent",
    "category": "functions_interprocess_communication_bshell"
  },
  "bms messages: sample programs": {
    "name": "BMS messages: sample programs",
    "type": "function",
    "syntax": "function BMS messages: sample programs()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "interprocess communication (bshell) overview": {
    "name": "Interprocess communication (bshell) overview",
    "type": "function",
    "syntax": "function Interprocess communication (bshell) overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "receive.bucket$": {
    "name": "receive.bucket$",
    "type": "function",
    "syntax": "function string receive.bucket$ (long processno)",
    "description": "This waits for a bucket message to be sent to the calling process by another process. It then returns that message. The processno argument returns the process ID of the sending process.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "send.bucket": {
    "name": "send.bucket",
    "type": "function",
    "syntax": "function long send.bucket (long processno, string bucket)",
    "description": "This sends a bucket message to a specified process. If the specified process is sleeping, it is automatically started. It can retrieve the message by calling receive.bucket$() .",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": "The process ID of the process to which the message must be sent, as returned by functions such as activate() and act.and.sleep() . In subprocesses, the predefined variable parent indicates the process ID of the parent process."
      },
      {
        "type": "string",
        "name": "bucket",
        "description": "The message string."
      }
    ],
    "returnValue": ">0 the process ID of the called process -1 error",
    "category": "functions_interprocess_communication_bshell"
  },
  "send.wait": {
    "name": "send.wait",
    "type": "function",
    "syntax": "function long send.wait (ref long processno, string bucket)",
    "description": "This sends a bucket message to a specified process and waits for a reply. The receiving process must send a reply by using send.bucket() or send.wait() . Note that the waiting process cannot receive any message string contained in the reply.",
    "arguments": [
      {
        "type": "ref long",
        "name": "processno",
        "description": "The process ID of the process to which the message must be sent, as returned by functions such as activate() and act.and.sleep() . In subprocesses, the predefined variable parent indicates the process ID of the parent process. Note that the actual process id returning the message will be returned in argument processno ."
      },
      {
        "type": "string",
        "name": "bucket",
        "description": "The message string."
      }
    ],
    "returnValue": ">0 the process ID of the process that sends the reply - 1 error",
    "category": "functions_interprocess_communication_bshell"
  },
  "interprocess communication (bshell) synopsis": {
    "name": "Interprocess communication (bshell) synopsis",
    "type": "function",
    "syntax": "function Interprocess communication (bshell) synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_interprocess_communication_bshell"
  },
  "close.message": {
    "name": "close.message",
    "type": "function",
    "syntax": "function void close.message (long key [, long fast])",
    "description": "This removes the specified mailbox. All messages in the mailbox are also automatically removed.",
    "arguments": [
      {
        "type": "long",
        "name": "key",
        "description": "The mailbox key, as returned by open.message() ."
      },
      {
        "type": "[long",
        "name": "fast ]",
        "description": "Set this optional argument to 1 if you are using the UNIX message queue ID instead of the mailbox key to identify the mailbox."
      }
    ],
    "returnValue": "",
    "category": "functions_interprocess_communication_os_level"
  },
  "open.message": {
    "name": "open.message",
    "type": "function",
    "syntax": "function long open.message (long project, string name$, long action [, long fast])",
    "description": "Use this to create a new mailbox or to connect to an existing mailbox. You must call this function before you can read from or write to the mailbox.",
    "arguments": [
      {
        "type": "long",
        "name": "project",
        "description": "A number in the range 1 to 255 that indicates the project to which the mailbox belongs."
      },
      {
        "type": "string",
        "name": "name$",
        "description": "This identifies a particular mailbox within the specified project. The argument must contain the name of a file that can be read by all processes that want to use the mailbox. The function uses the specified project number and some attribute of the specified file to generate a mailbox key that uniquely identifies the mailbox. The contents of the file are not used or changed by the function. Note that within a project, the specified file must be clearly associated with a particular mailbox."
      },
      {
        "type": "long",
        "name": "action",
        "description": "This argument can have one of the following values: 0 If the mailbox does not already exist, a new one is created. 1 This is similar to 0, except that instead of using a file name specified in name$ , the system creates a unique file name (\"$BSE/TMP/PostB<pid>\"). When specifying this option, specify name$ as an empty string (\"\"). 2 If the mailbox does not already exist, a new one is not created."
      },
      {
        "type": "[long",
        "name": "fast ]",
        "description": "Set this optional argument to 1 if you are using the UNIX message queue ID instead of the mailbox key to identify the mailbox."
      }
    ],
    "returnValue": "This returns a unique key for the opened mailbox. It returns -1 if an error occurs (the predefined variable e contains the error number).",
    "category": "functions_interprocess_communication_os_level"
  },
  "interprocess communication (os level) overview": {
    "name": "Interprocess communication (OS level) overview",
    "type": "function",
    "syntax": "function Interprocess communication (OS level) overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.clearerr": {
    "name": "pipe.clearerr",
    "type": "function",
    "syntax": "function long pipe.clearerr (long pipe_id)",
    "description": "This resets the error and end-of-file indicators on the specified pipe.",
    "arguments": [
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "0 success -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.close": {
    "name": "pipe.close",
    "type": "function",
    "syntax": "function long pipe.close (long pipe_id)",
    "description": "This clears any buffers associated with the specified pipe and closes the file. Buffers allocated by the standard input/output system are also cleared. Note that pipe.close() is performed automatically when the process exits.",
    "arguments": [
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "-1 error -2 child process is not allowed to read/write anymore >=0 exit value of child process (0 is OK)",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.eof": {
    "name": "pipe.eof",
    "type": "function",
    "syntax": "function long pipe.eof (long pipe_id)",
    "description": "This checks the end-of-file indicator on the specified pipe. Note that the end-of-file indicator lasts until the pipe is closed, unless you explicitly clear it by calling pipe.clearerr() .",
    "arguments": [
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "<>0 end-of-file indicator read on specified pipe 0 end-of-file indicator not read",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.error": {
    "name": "pipe.error",
    "type": "function",
    "syntax": "function long pipe.error (long pipe_id)",
    "description": "This checks the error indicator on the specified pipe to determine whether an error has occurred when reading or writing to the pipe. Note that the error indicator lasts until the pipe is closed, unless you explicitly clear it by calling pipe.clearerr() .",
    "arguments": [
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "<>0 error has occurred when reading or writing to the pipe 0 no error has occurred",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.flush": {
    "name": "pipe.flush",
    "type": "function",
    "syntax": "function long pipe.flush (long pipe_id)",
    "description": "This writes any buffered data associated with a pipe to the related file. The stream remains open.",
    "arguments": [
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "0 success -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.gets": {
    "name": "pipe.gets",
    "type": "function",
    "syntax": "function long pipe.gets (ref string line, long nr_of_bytes, long pipe_id)",
    "description": "This reads a maximum of one line from the specified pipe.",
    "arguments": [
      {
        "type": "ref string",
        "name": "line",
        "description": "This stores the characters read from the pipe."
      },
      {
        "type": "long",
        "name": "nr_of_bytes",
        "description": "This specifies the maximum number of bytes to be read from the pipe. The function stops reading when it encounters a newline character or when it has read the number of bytes specified by this argument, whichever comes first."
      },
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "0 success -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.open": {
    "name": "pipe.open",
    "type": "function",
    "syntax": "function long pipe.open (string pathnm, string openmode)",
    "description": "This creates a UNIX process with the specified name and links an input and/or output stream to it. It returns a pointer to the pipe; this is used to identify the pipe in subsequent operations.",
    "arguments": [
      {
        "type": "string",
        "name": "pathnm",
        "description": "The path name for the UNIX process."
      },
      {
        "type": "string",
        "name": "openmode",
        "description": "Use this to specify whether the pipe is opened for reading, writing, or both. The possible values are: \"r\" create for reading \"w\" create for writing \"rw\" create for reading and writing"
      }
    ],
    "returnValue": ">=1 success; a pointer to the pipe is returned <1 error; that is, the negative value of the system error (for example, for a permission error, the system returns 13 and the function returns -13, or if the internal table is full, the function returns -EAGAIN).",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.puts": {
    "name": "pipe.puts",
    "type": "function",
    "syntax": "function long pipe.puts (string line, long pipe_id)",
    "description": "This writes data to the specified pipe. It automatically appends a newline character to the data.",
    "arguments": [
      {
        "type": "string",
        "name": "line",
        "description": "The data to be written to the pipe."
      },
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": "0 success -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.read": {
    "name": "pipe.read",
    "type": "function",
    "syntax": "function long pipe.read (ref string buffer, long nr_of_bytes, long pipe_id)",
    "description": "This reads a specified number of bytes from the specified pipe.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "This stores the characters read from the pipe."
      },
      {
        "type": "long",
        "name": "nr_of_bytes",
        "description": "This specifies the maximum number of bytes to be read from the pipe. The function stops reading when it has read the number of bytes specified by this argument or when it reaches the end of the file, whichever comes first."
      },
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": ">0 the number of bytes read 0 end-of-file -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "pipe.write": {
    "name": "pipe.write",
    "type": "function",
    "syntax": "function long pipe.write (string buffer, long nr_of_bytes, long pipe_id)",
    "description": "This appends a specified number of bytes to the specified pipe.",
    "arguments": [
      {
        "type": "string",
        "name": "buffer",
        "description": "This stores the characters that must be written to the pipe."
      },
      {
        "type": "long",
        "name": "nr_of_bytes",
        "description": "This specifies the maximum number of bytes to be written to the pipe. The function stops writing to the pipe when it has written this number of bytes or when it reaches the end of the file, whichever comes first."
      },
      {
        "type": "long",
        "name": "pipe_id",
        "description": "The pipe ID, as returned by pipe.open() ."
      }
    ],
    "returnValue": ">0 the number of bytes written 0 end-of-file -1 error; most probably no connected stream on pipe_id pipe_id",
    "category": "functions_interprocess_communication_os_level"
  },
  "recv.message": {
    "name": "recv.message",
    "type": "function",
    "syntax": "function long recv.message (long key, long sender.key, long time, ref string message$ [, long fast])",
    "description": "This reads a message from the specified mailbox. The process must previously have connected to the mailbox by calling open.message() .",
    "arguments": [
      {
        "type": "long",
        "name": "key",
        "description": "The mailbox key, as returned by open.message() ."
      },
      {
        "type": "long",
        "name": "sender.key",
        "description": "Messages sent with the send.message() function have an associated sender key which identifies the sender. To retrieve the next message from a particular sender, specify that sender's key here. Otherwise specify zero � in this case the function retrieves the next message in the mailbox, regardless of the sender."
      },
      {
        "type": "long",
        "name": "time",
        "description": "Use this to specify the maximum time that the function must wait before returning. If you set this to -1, the function waits until a message arrives in the mailbox."
      },
      {
        "type": "ref string",
        "name": "message$",
        "description": "This stores the retrieved message."
      },
      {
        "type": "[long",
        "name": "fast ]",
        "description": "Set this optional argument to 1 if you are using the UNIX message queue ID instead of the mailbox key to identify the mailbox."
      }
    ],
    "returnValue": "This returns the sender key. It returns -1 if an error occurs (the predefined variable e contains the error number).",
    "category": "functions_interprocess_communication_os_level"
  },
  "send.message": {
    "name": "send.message",
    "type": "function",
    "syntax": "function long send.message (long dest.key, long sender.key, string message$, long fast)",
    "description": "This stores a message in the specified mailbox. The process must previously have connected to the mailbox by calling open.message() .",
    "arguments": [
      {
        "type": "long",
        "name": "dest.key",
        "description": "The mailbox key, as returned by open.message() ."
      },
      {
        "type": "long",
        "name": "sender.key",
        "description": "This is a unique key that identifies the sender of the message. Processes reading from the mailbox can use this filter out messages from other senders."
      },
      {
        "type": "string",
        "name": "message$",
        "description": "This is the message to be sent to the mailbox."
      },
      {
        "type": "long",
        "name": "fast",
        "description": "Set this optional argument to 1 if you are using the UNIX message queue ID instead of the mailbox key to identify the mailbox."
      }
    ],
    "returnValue": "This returns 0 when successful. Otherwise it returns an error number.",
    "category": "functions_interprocess_communication_os_level"
  },
  "interprocess communication (os level) synopsis": {
    "name": "Interprocess communication (OS level) synopsis",
    "type": "function",
    "syntax": "function Interprocess communication (OS level) synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_interprocess_communication_os_level"
  },
  "ibaanvm interface": {
    "name": "IBaanVM interface",
    "type": "function",
    "syntax": "function IBaanVM interface()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "ibucket interface": {
    "name": "IBucket Interface",
    "type": "function",
    "syntax": "function IBucket Interface()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "iqueuelistener interface": {
    "name": "IQueueListener Interface",
    "type": "function",
    "syntax": "function IQueueListener Interface()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.destroy.queue": {
    "name": "java.destroy.queue",
    "type": "function",
    "syntax": "function long java.destroy.queue (long Queue.id)",
    "description": "Removes a queue, given the queue id. This will also remove all buckets on that queue!!",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "id of the queue to be removed"
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.execute.static.application.method": {
    "name": "java.execute.static.application.method",
    "type": "function",
    "syntax": "function long java.execute.static.application.method (long Handle, ref string JavaReturnValue, string class.name, string method.name [, void ...])",
    "description": "Executes a versioned, dynamically loaded, Java method. These Java mehods can also return a (string) value to the 3 GL.",
    "arguments": [
      {
        "type": "long",
        "name": "Handle",
        "description": "A handle to a loaded application, obtained by a previous successful call to java.load.application ."
      },
      {
        "type": "ref string",
        "name": "JavaReturnValue",
        "description": "The Java method can return any type that supports the toString() method. All return values are converted to a string. When an invoked metod returns a null, this is converted to the empty string (the bshell does not have the concept of null pointers). So everything is returned as a string value to the bshell: a long is returned as a decimal string, a string is returned \"as is\", etc. This parameter is passed by reference and only valid when the return code of the function is 0 (success). A non-zero return value indicates a problem and in that case the JavaReturnValue is not used."
      },
      {
        "type": "string",
        "name": "class.name",
        "description": "The Name of the Java class to call (e.g.: com.baan.baanvm.Test). This must be the name of a valid Java class in the (currently loaded) version of the application."
      },
      {
        "type": "string",
        "name": "method.name",
        "description": "Name of the static Java method in that class to call (e.g.: runMe). This must be the name of a static method, returning a type that can be converted to a string (all return values are cast to a string). The selected class must have a parameter signature that matches the parameters that you specify. When one of these restrictions is violated, the function will return a non-zero value and the log will provide more details."
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "Optional parameters for that method. All BaanC types at this time (string, long, double) are supported. The 3GL type BOOLEAN is supported, but it maps to an int in Java. Also, it is worthwhile noting that the 3GL type LONG maps to the int type in Java. The signature of the method that you are calling must match the signature used by the 3GL call. It is supported to have several methods with the same name and different signatures. The matching method is selected automatically."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.execute.static.method.sync": {
    "name": "java.execute.static.method.sync",
    "type": "function",
    "syntax": "function long java.execute.static.method.sync (string class.name, string method.name [, void ...])",
    "description": "Executes a Java static method, with no return type, within the JavaVM.",
    "arguments": [
      {
        "type": "string",
        "name": "class.name",
        "description": "name of the Java class to call (e.g.: com.baan.baanvm.Test)"
      },
      {
        "type": "string",
        "name": "method.name",
        "description": "name of the static Java method in that class to call (e.g.: runMe)."
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "Optional parameters for that method. All BaanC types at this time (string, long, double) are supported. The 3GL type BOOLEAN is supported, but it maps to an int in Java. Also, it is worthwhile noting that the 3GL type LONG maps to the int type in Java."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.get.bucket": {
    "name": "java.get.bucket",
    "type": "function",
    "syntax": "function long java.get.bucket (long Queue.id, ref string body, long length [, ref string header])",
    "description": "Retrieves a bucket from the queue (if available). The message is removed from the queue afterwards.",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "id of the queue to retrieve the message from"
      },
      {
        "type": "ref string",
        "name": "body",
        "description": "upon return, contains the received body"
      },
      {
        "type": "long",
        "name": "length",
        "description": "length of the data in body"
      },
      {
        "type": "[ref string",
        "name": "header ]",
        "description": "upon return, contains the received header"
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.install.listener": {
    "name": "java.install.listener",
    "type": "function",
    "syntax": "function long java.install.listener (long Queue.id [, long become.owner])",
    "description": "Installs a listener at the Infor ERP Enterprise side. Whenever a message arrives on the queue specified by queue.id, the 3GL process will be notified by an EVT_CHANNEL_EVENT event. For installation of a listener at the Java side, see the Java IQeueListener interface definition.",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "id of the queue"
      },
      {
        "type": "[long",
        "name": "become.owner ]",
        "description": "1 (default) if the 3GL process becomes the new owner of the queue itself. This basically means the queue will be removed whenever the 3GL process that called this function exits. 0 : the process will NOT become the new owner of this queue. The queue is removed automatically when the 3GL process that called java.new.queue exists."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.load.application": {
    "name": "java.load.application",
    "type": "function",
    "syntax": "function long java.load.application (string Application.Name)",
    "description": "Load the most recent version of a Java application and return a handle to be used in subsequent operations. A Java virtual machine (JVM) is started when required (or an existing one is used), see Java VM integration - Infor ERP Enterprise Server 3GL for details.",
    "arguments": [
      {
        "type": "string",
        "name": "Application.Name",
        "description": "Name of the Java program to load. The system will look for this name in the \"java/application\" subdirectory of the (landlord) BSE. There must be a file there called <package_comb>.pacc, which lists the details of the installed java applications) one per line) for that package combination in the given BSE and current package combination. The string you pass as Application.Name must be listed in this file at least once. Every line in the .pacc file consists of a tag name (the argument specified as Application.Name), a vertical bar (|) followed by the name of the directory the application is installed in. Each application can have multiple versions installed, the java.load.application will automatically determine the most recent version (the last matching line in the .pacc file) and use that. Every application can have dependent applications which are loaded recursively until all dependencies are satisfied. The application must have an application.xml file installed for this in the (versioned) application directory that lists the dependencies (even when there are none). When the loading process is succesful, a handle is returned (a positive integer value). When problems are detected, a negative value is returned and one or more log messages are generated."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.lookup.queue": {
    "name": "java.lookup.queue",
    "type": "function",
    "syntax": "function long java.lookup.queue (long Queue.id [, ref string header])",
    "description": "Checks whether a queue is still valid and, if so, if the queue contains a message. The message is not removed from the queue.",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "id of the queue to verify."
      },
      {
        "type": "[ref string",
        "name": "header ]",
        "description": "contains the header of the first message on the queue."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.new.queue": {
    "name": "java.new.queue",
    "type": "function",
    "syntax": "function long java.new.queue ()",
    "description": "Creates a new queue for buckets. Upon return, the new queue.id is returned, or an error code is presented. NOTE: queues are removed automatically if the process that created it (or the process that called java.install.listener(�) on that queue) is finished !! See also the 3GL function java.install.listener.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.put.bucket": {
    "name": "java.put.bucket",
    "type": "function",
    "syntax": "function long java.put.bucket (long Queue.id, string body, long length [, string header])",
    "description": "Places a message onto a queue. The message contains a header (of type string) and a body (which can contain any character).",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "Id of the queue to write the message to."
      },
      {
        "type": "string",
        "name": "body",
        "description": "Data to be placed into the body of the message."
      },
      {
        "type": "long",
        "name": "length",
        "description": "Length of the data in body."
      },
      {
        "type": "[string",
        "name": "header ]",
        "description": "A string containing the header of the message (optional)."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.uninstall.listener": {
    "name": "java.uninstall.listener",
    "type": "function",
    "syntax": "function long java.uninstall.listener (long Queue.id)",
    "description": "Uninstalls a listener at the Infor ERP Enterprise side. All buckets on this queue will remain available. The listener can only be uninstalled by the process that installed the listener.",
    "arguments": [
      {
        "type": "long",
        "name": "Queue.id",
        "description": "id of the queue from which to remove the listener"
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java.unload.application": {
    "name": "java.unload.application",
    "type": "function",
    "syntax": "function long java.unload.application (long handle)",
    "description": "Unloads an application loaded by java.load.application .",
    "arguments": [
      {
        "type": "long",
        "name": "handle",
        "description": "The handle of the application to unload, previously obtained by a successful call to java.load.application ."
      }
    ],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "java vm integration - infor erp enterprise server 3gl": {
    "name": "Java VM integration - Infor ERP Enterprise Server 3GL",
    "type": "function",
    "syntax": "function Java VM integration - Infor ERP Enterprise Server 3GL()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_javavm"
  },
  "add a value to a json arry": {
    "name": "Add a value to a JSon arry",
    "type": "function",
    "syntax": "function long Json.add (long json, long value)",
    "description": "Adds a JSON value at the end of a JSON array.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "value",
        "description": "value is the new JSON value to set."
      }
    ],
    "returnValue": "Optional, the new JSON value which has been added to the JSON array.",
    "category": "functions_json"
  },
  "add a boolean object to a json object": {
    "name": "Add a boolean object to a JSon object",
    "type": "function",
    "syntax": "function long Json.addBoolean (long json, boolean value)",
    "description": "Convenience function for directly adding a 3GL boolean value to a JSON array. The 3GL boolean value is first converted to a JSON boolean value which is then added to the array. The function is a shorthand for: Json.add(json, Json.newBoolean(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "boolean",
        "name": "value",
        "description": "value is the 3GL boolean value for which a JSON boolean value is created, which is then added to the array."
      }
    ],
    "returnValue": "Optional, the new JSON boolean value which has been added to the JSON array.",
    "category": "functions_json"
  },
  "add a null object to a json object": {
    "name": "Add a null object to a JSon object",
    "type": "function",
    "syntax": "function long Json.addNull (long json)",
    "description": "Convenience function for adding a JSON null value to a JSON array. The function is a shorthand for: Json.add(json, Json.newNull())",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      }
    ],
    "returnValue": "Optional, the new JSON null value which has been added to the JSON array.",
    "category": "functions_json"
  },
  "add a number object to a json object": {
    "name": "Add a number object to a JSon object",
    "type": "function",
    "syntax": "function long Json.addNumber (long json, ... value)",
    "description": "Convenience function for directly adding a 3GL long or double value to a JSON array. The 3GL long or double value is first converted to a JSON number value which is then added to the array. The function is a shorthand for: Json.add(json, Json.newNumber(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "...",
        "name": "value",
        "description": "value is the 3GL long or double value for which a JSON number value is created, which is then added to the array."
      }
    ],
    "returnValue": "Optional, the new JSON number value which has been added to the JSON array.",
    "category": "functions_json"
  },
  "add a string object to a json object": {
    "name": "Add a string object to a JSon object",
    "type": "function",
    "syntax": "function long Json.addString (long json, string value)",
    "description": "Convenience function for directly adding a 3GL string value to a JSON array. The 3GL string value is first converted to a JSON string value which is then added to the array. The function is a shorthand for: Json.add(json, Json.newString(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "string",
        "name": "value",
        "description": "value is the 3GL string value for which a JSON string value is created, which is then added to the array."
      }
    ],
    "returnValue": "Optional, the new JSON string value which has been added to the JSON array.",
    "category": "functions_json"
  },
  "return a json object in a json array": {
    "name": "Return a JSon object in a JSon array",
    "type": "function",
    "syntax": "function long Json.at (long json, long idx)",
    "description": "Returns the JSON value that is stored at the specified index in a JSON array.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index in the array to get the value from."
      }
    ],
    "returnValue": "The JSON value that is stored in the JSON array at the specified index.",
    "category": "functions_json"
  },
  "get the boolean value of a json object": {
    "name": "Get the boolean value of a Json object",
    "type": "function",
    "syntax": "function boolean Json.boolean (long json)",
    "description": "Returns the value of a JSON boolean value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a handle to a JSON boolean object."
      }
    ],
    "returnValue": "The boolean value of the JSon object, true of false.",
    "category": "functions_json"
  },
  "return a boolean in a json array": {
    "name": "Return a boolean in a JSon array",
    "type": "function",
    "syntax": "function boolean Json.booleanAt (long json, long idx)",
    "description": "Convenience function for directly returning the 3GL boolean value of the JSON boolean value that is stored at the specified index in a JSON array. The function is a shorthand for: Json.boolean(Json.at(json, idx))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index in the array to get the value from."
      }
    ],
    "returnValue": "The 3GL boolean value stored at the specified index.",
    "category": "functions_json"
  },
  "copy a json value": {
    "name": "Copy a JSon value",
    "type": "function",
    "syntax": "function long Json.copy (long json)",
    "description": "Returns a (deep) copy of a JSON value. In case the JSON value is of type JSON_TYPE_OBJECT or JSON_TYPE_ARRAY, all contained members are copied as well.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "A (deep) copy of the passed JSON value.",
    "category": "functions_json"
  },
  "count the elements in a json array": {
    "name": "Count the elements in a JSon array",
    "type": "function",
    "syntax": "function long Json.count (long json)",
    "description": "Returns the number of JSON values stored in a JSON array.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      }
    ],
    "returnValue": "The number of JSON values in the JSON array.",
    "category": "functions_json"
  },
  "delete a key from a json object": {
    "name": "Delete a key from a JSon object",
    "type": "function",
    "syntax": "function void Json.del (long json, string key)",
    "description": "Deletes the specified key from a JSON object. The associated JSON value is deleted as well.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key to delete from the JSON object."
      }
    ],
    "returnValue": "",
    "category": "functions_json"
  },
  "delete a json value": {
    "name": "Delete a JSon value",
    "type": "function",
    "syntax": "function void Json.delete (long json)",
    "description": "Deletes a JSON value. In case the JSON value is of type JSON_TYPE_OBJECT or JSON_TYPE_ARRAY all contained members are deleted as well.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "",
    "category": "functions_json"
  },
  "detach a json value from its parent": {
    "name": "Detach a JSon value from its Parent",
    "type": "function",
    "syntax": "function long Json.detach (long json)",
    "description": "Detaches a JSON value from its parent JSON object or JSON array. After calling this function, the JSON value is no longer a member of its parent. The member of the parent JSON object or array is assigned the JSON null value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "Optional, the detached JSON value.",
    "category": "functions_json"
  },
  "get key from a json object": {
    "name": "Get key from a JSon object",
    "type": "function",
    "syntax": "function long Json.get (long json, string key)",
    "description": "Returns the JSON value associated with the specified key of a JSON object.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key of the value to get."
      }
    ],
    "returnValue": "The JSON value associated with the specified key.",
    "category": "functions_json"
  },
  "get a boolean from a json object": {
    "name": "Get a boolean from a JSon object",
    "type": "function",
    "syntax": "function long Json.getBoolean (long json, string key)",
    "description": "Convenience function for directly returning the 3GL boolean value of the JSON boolean value associated with the specified key of a JSON object. The function is a shorthand for: Json.boolean(Json.get(json, key))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key of the boolean value to get."
      }
    ],
    "returnValue": "The 3GL boolean value associated with the specified key.",
    "category": "functions_json"
  },
  "get a number from a json object": {
    "name": "Get a number from a JSon object",
    "type": "function",
    "syntax": "function long Json.getNumber (long json, string key)",
    "description": "Convenience function for directly returning the 3GL long or double value of the JSON number value associated with the specified key of a JSON object. The function is a shorthand for: Json.number(Json.get(json, key))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key of the number value to get."
      }
    ],
    "returnValue": "The 3GL double or long value associated with the specified key.",
    "category": "functions_json"
  },
  "get a string from a json object": {
    "name": "Get a string from a JSon object",
    "type": "function",
    "syntax": "function string Json.getString (long json, string key)",
    "description": "Convenience function for directly returning the 3GL string value of the JSON string value associated with the specified key of a JSON object. The function is a shorthand for: Json.string(Json.get(json, key))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key of the string value to get."
      }
    ],
    "returnValue": "The 3GL string value associated with the specified key.",
    "category": "functions_json"
  },
  "contains the json object this key": {
    "name": "Contains the JSon object this key",
    "type": "function",
    "syntax": "function boolean Json.has (long json, string key)",
    "description": "Tests whether a JSON object contains the specified key.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "string",
        "name": "key",
        "description": "key is the key to check."
      }
    ],
    "returnValue": "True if the specified key exists, else false",
    "category": "functions_json"
  },
  "test json value": {
    "name": "Test JSon value",
    "type": "function",
    "syntax": "function boolean Json.isJson (long json)",
    "description": "Tests whether parameter 'json' is a JSON value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "True if parameter 'json' is a JSON value, else false.",
    "category": "functions_json"
  },
  "test json null value": {
    "name": "Test JSon null value",
    "type": "function",
    "syntax": "function boolean Json.isNull (long json)",
    "description": "Tests whether a JSON value is a JSON null value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "True if the JSON value is of type JSON_TYPE_NULL, else false.",
    "category": "functions_json"
  },
  "the iterator of a json object": {
    "name": "The iterator of a JSon object",
    "type": "function",
    "syntax": "function long Json.iter (long json)",
    "description": "Returns an iterator which can be used to traverse the members of a JSON object or JSON array. On return the iterator points to the first member.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object or array."
      }
    ],
    "returnValue": "An iterator pointing to the first member of a JSON object or JSON array, or 0 in case the JSON object or JSON array has no members.",
    "category": "functions_json"
  },
  "the key value of a current json iterator": {
    "name": "The key value of a current JSon iterator",
    "type": "function",
    "syntax": "function string Json.iterKey (long json, long iter)",
    "description": "Returns the key name to which the specified iterator is pointing.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "long",
        "name": "iter",
        "description": "iter is a JSON iterator."
      }
    ],
    "returnValue": "The key name to which the specified iterator is pointing.",
    "category": "functions_json"
  },
  "the next element from a json iterator": {
    "name": "The next element from a JSon iterator",
    "type": "function",
    "syntax": "function long Json.iterNext (long json, long iter)",
    "description": "Moves the iterator to the next member of a JSON object or JSON array.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object or array."
      },
      {
        "type": "long",
        "name": "iter",
        "description": "iter is a JSON iterator."
      }
    ],
    "returnValue": "An iterator pointing to the next member of a JSON object or JSON array, or 0 in case the JSON object or JSON array has no more members",
    "category": "functions_json"
  },
  "the json value of a current json iterator": {
    "name": "The JSon value of a current JSon iterator",
    "type": "function",
    "syntax": "function long Json.iterValue (long json, long iter)",
    "description": "Returns the JSon value to which the specified iterator is pointing.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object or array."
      },
      {
        "type": "long",
        "name": "iter",
        "description": "iter is a JSON iterator."
      }
    ],
    "returnValue": "The JSON value to which the specified iterator is pointing.",
    "category": "functions_json"
  },
  "create a new json array": {
    "name": "Create a new JSon array",
    "type": "function",
    "syntax": "function long Json.newArray ()",
    "description": "Creates a new empty JSON array.",
    "arguments": [],
    "returnValue": "A new empty JSON value of type JSON_TYPE_ARRAY.",
    "category": "functions_json"
  },
  "create a new json boolean object": {
    "name": "Create a new JSon boolean object",
    "type": "function",
    "syntax": "function long Json.newBoolean (boolean value)",
    "description": "Creates a new JSON boolean value, containing the passed boolean value.",
    "arguments": [
      {
        "type": "boolean",
        "name": "value",
        "description": "value a boolean, either true of false."
      }
    ],
    "returnValue": "A new JSON boolean value, containing the passed boolean value.",
    "category": "functions_json"
  },
  "create a json null object": {
    "name": "Create a JSon Null object",
    "type": "function",
    "syntax": "function long Json.newNull ()",
    "description": "Creates a new JSON null value.",
    "arguments": [],
    "returnValue": "A new JSON null value.",
    "category": "functions_json"
  },
  "create a json number object": {
    "name": "Create a JSon number object",
    "type": "function",
    "syntax": "function long Json.newNumber (... value)",
    "description": "Creates a new JSON number value, containing the passed long or double value. Internally the value is stored with a precision of 15 digits.",
    "arguments": [
      {
        "type": "...",
        "name": "value",
        "description": "value a long or a double."
      }
    ],
    "returnValue": "A new JSON number value, containing the passed long or double value.",
    "category": "functions_json"
  },
  "create a json object": {
    "name": "Create a JSon object",
    "type": "function",
    "syntax": "function long Json.newObject ()",
    "description": "Creates a new empty JSON object.",
    "arguments": [],
    "returnValue": "A new empty JSON value of type JSON_TYPE_OBJECT.",
    "category": "functions_json"
  },
  "create a json string value": {
    "name": "Create a JSon string value",
    "type": "function",
    "syntax": "function long Json.newString (const string value)",
    "description": "Creates a new JSON string value, containing the passed string value.",
    "arguments": [
      {
        "type": "const string",
        "name": "value",
        "description": "value a string."
      }
    ],
    "returnValue": "A new JSON string value, containing the passed string value.",
    "category": "functions_json"
  },
  "get json number value": {
    "name": "Get JSon number value",
    "type": "function",
    "syntax": "function double Json.number (long json)",
    "description": "Returns the value of a JSON number value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is the handle to a JSON number value."
      }
    ],
    "returnValue": "The value contained in the JSON number value as a double.",
    "category": "functions_json"
  },
  "returns a number from a json array": {
    "name": "Returns a number from a JSon array",
    "type": "function",
    "syntax": "function long Json.numberAt (long json, long idx)",
    "description": "Convenience function for directly returning the 3GL long or double value of the JSON number value that is stored at the specified index in a JSON array. The function is a shorthand for: Json.number(Json.at(json, idx))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index in the array to get the value from."
      }
    ],
    "returnValue": "The 3GL number value stored at the specified index.",
    "category": "functions_json"
  },
  "json object overview": {
    "name": "JSON object overview",
    "type": "function",
    "syntax": "function JSON object overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_json"
  },
  "the json object at the end of the path": {
    "name": "The JSon object at the end of the path",
    "type": "function",
    "syntax": "function long Json.path (long json, ... ...)",
    "description": "Returns the JSON value in a JSON object or array, which is located at the specified path. The parameters passed to this function determine the path that is chosen to locate the the JSON value. Example:",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object or array."
      },
      {
        "type": "...",
        "name": "...",
        "description": "The key names and/or array indices which together form the path to a JSON value in the given JSON object or array."
      }
    ],
    "returnValue": "The JSON value requested.",
    "category": "functions_json"
  },
  "put a json object in a json array": {
    "name": "Put a JSon object in a JSon array",
    "type": "function",
    "syntax": "function long Json.put (long json, long idx, long value)",
    "description": "Puts a JSON value at the specified index in a JSON array. The existing JSON value is deleted and replaced with the new JSON value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index to put the JSON value in."
      },
      {
        "type": "long",
        "name": "value",
        "description": "value is the new JSON value to set."
      }
    ],
    "returnValue": "Optional, the new JSON value which has been put into the JSON array.",
    "category": "functions_json"
  },
  "put a json boolean object in a json array": {
    "name": "Put a JSon boolean object in a JSon array",
    "type": "function",
    "syntax": "function long Json.putBoolean (long json, long idx, boolean value)",
    "description": "Convenience function for directly putting a 3GL boolean value at the specified index in a JSON array. The 3GL boolean value is first converted to a JSON boolean value which is then put into the array. The function is a shorthand for: Json.put(json, idx, Json.newBoolean(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index to put the JSON boolean value in."
      },
      {
        "type": "boolean",
        "name": "value",
        "description": "value is the 3GL boolean value for which a JSON boolean value is created, which is then put into the array."
      }
    ],
    "returnValue": "Optional, the new JSON boolean value which has been put into the JSON array.",
    "category": "functions_json"
  },
  "put a json null object in a json array": {
    "name": "Put a JSon null object in a JSon array",
    "type": "function",
    "syntax": "function long Json.putNull (long json, long idx)",
    "description": "Convenience function for putting a JSON null value at the specified index in a JSON array. The function is a shorthand for: Json.put(json, idx, Json.newNull())",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index to put the JSON null value in."
      }
    ],
    "returnValue": "Optional, the new JSON null value which has been put into the JSON array.",
    "category": "functions_json"
  },
  "put a json number object in a json array": {
    "name": "Put a JSon number object in a JSon array",
    "type": "function",
    "syntax": "function long Json.putNumber (long json, long idx, ... value)",
    "description": "Convenience function for directly putting a 3GL long or double value at the specified index in a JSON array. The 3GL long or double value is first converted to a JSON number value which is then put into the array. The function is a shorthand for: Json.put(json, idx, Json.newNumber(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index to put the JSON number value in."
      },
      {
        "type": "...",
        "name": "value",
        "description": "value is the 3GL long or double value for which a JSON number value is created, which is then put into the array."
      }
    ],
    "returnValue": "Optional, the new JSON number value which has been put into the JSON array.",
    "category": "functions_json"
  },
  "put a json string object in a json array": {
    "name": "Put a JSon string object in a JSon array",
    "type": "function",
    "syntax": "function long Json.putString (long json, long idx, string value)",
    "description": "Convenience function for directly putting a 3GL string value at the specified index in a JSON array. The 3GL string value is first converted to a JSON string value which is then put into the array. The function is a shorthand for: Json.put(json, idx, Json.newString(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index to put the JSON string value in."
      },
      {
        "type": "string",
        "name": "value",
        "description": "value is the 3GL string value for which a JSON string value is created, which is then put into the array."
      }
    ],
    "returnValue": "Optional, the new JSON string value which has been put into the JSON array.",
    "category": "functions_json"
  },
  "read a json object from a stream": {
    "name": "Read a JSon object from a stream",
    "type": "function",
    "syntax": "function long Json.read (long stream, ref string errStr [, long options])",
    "description": "Reads JSON text from a stream, parses it and creates a JSON value object from it. The stream can be an already opened file, or an in-memory stream. By default:",
    "arguments": [
      {
        "type": "long",
        "name": "stream",
        "description": "stream is the stream to read the JSON text from."
      },
      {
        "type": "ref string",
        "name": "errStr",
        "description": "errStr is a description of the error in case a parsing error occurs. This is an english text which can be used for logging and debugging purposes."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are the options to use when reading the JSON text; the following options can be specified: JSON_READ_UTF8 - specify this when the JSON text is encoded as UTF-8. JSON_READ_TSS - specify this when the JSON text is encoded as TSS. By default, the data is interpreted as UTF-8 text."
      }
    ],
    "returnValue": "A JSON value, or 0 in case of an error.",
    "category": "functions_json"
  },
  "read a json object from a file": {
    "name": "Read a JSon object from a file",
    "type": "function",
    "syntax": "function long Json.readFile (const string path, ref string errStr [, long options])",
    "description": "Reads JSON text from a file, parses it and creates a JSON value object from it. By default:",
    "arguments": [
      {
        "type": "const string",
        "name": "path",
        "description": "path is the path to the file to read the JSON text from."
      },
      {
        "type": "ref string",
        "name": "errStr",
        "description": "errStr is a description of the error in case a parsing error occurs. This is an english text which can be used for logging and debugging purposes."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are options to use when reading the JSON text; the following options can be specified: JSON_READ_UTF8 - specify this when the JSON text is encoded as UTF-8. JSON_READ_TSS - specify this when the JSON text is encoded as TSS. By default, the data is interpreted as UTF-8 text."
      }
    ],
    "returnValue": "A JSON value, or 0 in case of an error.",
    "category": "functions_json"
  },
  "read a json object from a string": {
    "name": "Read a JSon object from a string",
    "type": "function",
    "syntax": "function long Json.readString (const string jsonStr, ref string errStr [, long options])",
    "description": "Reads JSON text from a string, parses it and creates a JSON value object from it. By default:",
    "arguments": [
      {
        "type": "const string",
        "name": "jsonStr",
        "description": "jsonStr is the string to read the JSON text from."
      },
      {
        "type": "ref string",
        "name": "errStr",
        "description": "errStr is a description of the error in case a parsing error occurs. This is an english text which can be used for logging and debugging purposes."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are options to use when reading the JSON text; the following options can be specified: JSON_READ_UTF8 - specify this when the JSON text is encoded as UTF-8. JSON_READ_TSS - specify this when the JSON text is encoded as TSS. By default, the data is interpreted as TSS text."
      }
    ],
    "returnValue": "A JSON value, or 0 in case of an error.",
    "category": "functions_json"
  },
  "set a json object with a key in another json object": {
    "name": "Set a JSon object with a key in another JSon object",
    "type": "function",
    "syntax": "function long Json.set (long json, const string key, long value)",
    "description": "Associates a JSON value with a key in a JSON object. In case the key does not yet exist, it is created first. In case the key already exists, its current JSON value is deleted and replaced by the new value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "const string",
        "name": "key",
        "description": "key is the key to associate a JSON value with."
      },
      {
        "type": "long",
        "name": "value",
        "description": "value is the new JSON value to associate with the key."
      }
    ],
    "returnValue": "Optional: the new JSON value which has been associated with the key.",
    "category": "functions_json"
  },
  "set a json boolean object": {
    "name": "Set a JSon boolean object",
    "type": "function",
    "syntax": "function long Json.setBoolean (long json, const string key, boolean value)",
    "description": "Convenience function for directly associating a 3GL boolean value with a key in a JSON object. The 3GL boolean value is first converted to a JSON boolean value which is then associated with the specified key. The function is a shorthand for: Json.set(json, key, Json.newBoolean(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "const string",
        "name": "key",
        "description": "key is a key to associate the JSON boolean value with."
      },
      {
        "type": "boolean",
        "name": "value",
        "description": "value the 3GL boolean value for which a JSON boolean value is created, which is then associated with the key."
      }
    ],
    "returnValue": "Optional, the new JSON boolean value which has been associated with the key.",
    "category": "functions_json"
  },
  "set a json null object": {
    "name": "Set a JSon Null object",
    "type": "function",
    "syntax": "function long Json.setNull (long json, const string key)",
    "description": "Convenience function for associating a JSON null value with a key in a JSON object. The function is a shorthand for: Json.set(json, key, Json.newNull())",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "const string",
        "name": "key",
        "description": "key is a key to associate the JSON null value with."
      }
    ],
    "returnValue": "Optional, the new JSON null value which has been associated with the key.",
    "category": "functions_json"
  },
  "set a json number object": {
    "name": "Set a JSon number object",
    "type": "function",
    "syntax": "function long Json.setNumber (long json, const string key, ... value)",
    "description": "Convenience function for directly associating a 3GL long or double value with a key in a JSON object. The 3GL long or double value is first converted to a JSON number value which is then associated with the specified key. The function is a shorthand for: Json.set(json, key, Json.newNumber(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "const string",
        "name": "key",
        "description": "key is a key to associate the JSON number value with."
      },
      {
        "type": "...",
        "name": "value",
        "description": "value the 3GL long or double value for which a JSON number value is created, which is then associated with the key."
      }
    ],
    "returnValue": "Optional, the new JSON number value which has been associated with the key.",
    "category": "functions_json"
  },
  "set a json string object": {
    "name": "Set a JSon string object",
    "type": "function",
    "syntax": "function long Json.setString (long json, const string key, const string value)",
    "description": "Convenience function for directly associating a 3GL string value with a key in a JSON object. The 3GL string value is first converted to a JSON string value which is then associated with the specified key. The function is a shorthand for: Json.set(json, key, Json.newString(value))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON object."
      },
      {
        "type": "const string",
        "name": "key",
        "description": "key is a key to associate the JSON string value with."
      },
      {
        "type": "const string",
        "name": "value",
        "description": "value the 3GL string value for which a JSON string value is created, which is then associated with the key."
      }
    ],
    "returnValue": "Optional, the new JSON string value which has been associated with the key.",
    "category": "functions_json"
  },
  "return string from a json object": {
    "name": "Return string from a JSon object",
    "type": "function",
    "syntax": "function string Json.string (long json)",
    "description": "Returns the value of a JSON string value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json a handle to a JSON string value."
      }
    ],
    "returnValue": "The string contained in the JSON string value.",
    "category": "functions_json"
  },
  "returns a string from a json array": {
    "name": "Returns a string from a JSon array",
    "type": "function",
    "syntax": "function string Json.stringAt (long json, long idx)",
    "description": "Convenience function for directly returning the 3GL string value of the JSON string value that is stored at the specified index in a JSON array. The function is a shorthand for: Json.string(Json.at(json, idx))",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON array."
      },
      {
        "type": "long",
        "name": "idx",
        "description": "idx is the index in the array to get the value from."
      }
    ],
    "returnValue": "The 3GL string value stored at the specified index.",
    "category": "functions_json"
  },
  "get the json object type": {
    "name": "Get the JSon object type",
    "type": "function",
    "syntax": "function long Json.type (long json)",
    "description": "Gets the type of a JSON value.",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      }
    ],
    "returnValue": "The type of the JSON value. One of { JSON_TYPE_OBJECT, JSON_TYPE_ARRAY, JSON_TYPE_BOOLEAN, JSON_TYPE_NUMBER, JSON_TYPE_STRING, JSON_TYPE_NULL, JSON_TYPE_UNKNOWN }.",
    "category": "functions_json"
  },
  "write a json value object to a stream as json text": {
    "name": "Write a JSON value object to a stream as JSON text",
    "type": "function",
    "syntax": "function long Json.write (long json, long stream [, long options])",
    "description": "Writes a JSON value object to a stream as JSON text. This can be an already opened file, or an in-memory stream. By default:",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      },
      {
        "type": "long",
        "name": "stream",
        "description": "stream is the stream to write the JSON text to."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are the options to use when writing the JSON text; the following options can be specified: JSON_WRITE_UTF8 - converts the JSON text to UTF-8. JSON_WRITE_PRETTY - adds new-lines and indents to make the output human readable. JSON_WRITE_COMPACT - no whitespace is added between JSON tokens. By default, the file is written in compact mode and in UTF-8 format."
      }
    ],
    "returnValue": ">= 0 the number of bytes written to the stream when successful < 0 in case of a failure [e.g. when the string to write to is too small] variable 'e' contains an error code, [e.g. ENOSPC]",
    "category": "functions_json"
  },
  "write a json value object to a file as json text": {
    "name": "Write a JSON value object to a file as JSON text",
    "type": "function",
    "syntax": "function long Json.writeFile (long json, const string path [, long options])",
    "description": "Writes a JSON value object to a file as JSON text. By default:",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      },
      {
        "type": "const string",
        "name": "path",
        "description": "path is the path to the file to write the JSON text to; if the file already exists it is overwritten."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are the options to use when writing the JSON text; the following options can be specified: JSON_WRITE_UTF8 - converts the JSON text to UTF-8. JSON_WRITE_PRETTY - adds new-lines and indents to make the output human readable. JSON_WRITE_COMPACT - no whitespace is added between JSON tokens. By default, the file is written in pretty mode and in UTF-8 format."
      }
    ],
    "returnValue": ">= 0 the number of bytes written to the string when successful < 0 in case of a failure [e.g. when the string to write to is too small] variable 'e' contains an error code [e.g. ENOSPC]",
    "category": "functions_json"
  },
  "writes a json value object to a string as json text": {
    "name": "Writes a JSON value object to a string as JSON text",
    "type": "function",
    "syntax": "function long Json.writeString (long json, ref string str [, long options])",
    "description": "Writes a JSON value object to a string as JSON text. By default:",
    "arguments": [
      {
        "type": "long",
        "name": "json",
        "description": "json is a JSON value."
      },
      {
        "type": "ref string",
        "name": "str",
        "description": "str is the string to write the JSON text to; this string should be large enough to contain the complete JSON text; in case it is hard to tell the size upfront, it is advised to use function Json.write() instead."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "options are the optional options to use when writing the JSON text; the following options can be specified: JSON_WRITE_UTF8 - converts the JSON text to UTF-8. JSON_WRITE_PRETTY - adds new-lines and indents to make the output human readable. JSON_WRITE_COMPACT - no whitespace is added between JSON tokens. By default none of these options are enabled, meaning the JSON text is written in TSS encoding, not pretty and not compact."
      }
    ],
    "returnValue": ">= 0 the number of bytes written to the string when successful < 0 in case of a failure [e.g. when the string to write to is too small] variable 'e' contains an error code, [e.g. ENOSPC]",
    "category": "functions_json"
  },
  "json object synopsis": {
    "name": "JSon object synopsis",
    "type": "function",
    "syntax": "function JSon object synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_json"
  },
  "create.keyfields.collection": {
    "name": "create.keyfields.collection",
    "type": "function",
    "syntax": "function long create.keyfields.collection ()",
    "description": "Create an object which can hold a collection of key fields objects",
    "arguments": [],
    "returnValue": "<>0 The id of the created collection. This id must be used in subsequent calls to other key fields collection related calls. 0 When this function fails",
    "category": "functions_keyfields"
  },
  "create.keyfields.object": {
    "name": "create.keyfields.object",
    "type": "function",
    "syntax": "function long create.keyfields.object (const string tablename [, long collection])",
    "description": "Create an object which can hold the key fields and the corresponding values referring to one record of the passed database table. The key fields of index 1 are used.",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename",
        "description": "the name of the table for which the key fields will be stored"
      },
      {
        "type": "[long",
        "name": "collection ]",
        "description": "optional id of a key fields collection to which this key field object will be added. A key fields collection must be created with the function: create.keyfields.collection()"
      }
    ],
    "returnValue": "<>0 The id of the created key fields object 0 When this function fails",
    "category": "functions_keyfields"
  },
  "delete.keyfields.collection": {
    "name": "delete.keyfields.collection",
    "type": "function",
    "syntax": "function void delete.keyfields.collection (long object)",
    "description": "Delete the indicated key fields collection including all key field objects which are currently stored in this collection",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields collection which must be returned by a previous call to create.keyfields.collection()"
      }
    ],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "delete.keyfields.object": {
    "name": "delete.keyfields.object",
    "type": "function",
    "syntax": "function void delete.keyfields.object (long object)",
    "description": "Delete the indicated key fields object. When this object is currently part of a collection it will also be removed from this collection.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields object which must be returned by a previous call to create.keyfields.object()"
      }
    ],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "get.first.keyfields.object": {
    "name": "get.first.keyfields.object",
    "type": "function",
    "syntax": "function long get.first.keyfields.object (long object)",
    "description": "Get the first key fields object in this collection.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields collection which must be returned by a previous call to create.keyfields.collection()"
      }
    ],
    "returnValue": "<>0 The id of the first key fields object 0 When this collection does not contain any objects",
    "category": "functions_keyfields"
  },
  "get.keyfields.table": {
    "name": "get.keyfields.table",
    "type": "function",
    "syntax": "function string get.keyfields.table (long object)",
    "description": "Return the name of the table associated with the passed key fields object.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields object which must be returned by a previous call to create.keyfields.object()"
      }
    ],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "get.next.keyfields.object": {
    "name": "get.next.keyfields.object",
    "type": "function",
    "syntax": "function long get.next.keyfields.object (long object)",
    "description": "Get the next key fields object in a collection.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of a key fields object which is part of a collection"
      }
    ],
    "returnValue": "<>0 The id of the next key fields object 0 When this collection does not contain more objects",
    "category": "functions_keyfields"
  },
  "get.num.keyfields.object": {
    "name": "get.num.keyfields.object",
    "type": "function",
    "syntax": "function long get.num.keyfields.object (long object)",
    "description": "Get the number of key field objects in this collection.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields collection which must be returned by a previous call to create.keyfields.collection()"
      }
    ],
    "returnValue": ">=0 the number of child nodes. <0 when an invalid collection id is passed",
    "category": "functions_keyfields"
  },
  "keyfields.to.object": {
    "name": "keyfields.to.object",
    "type": "function",
    "syntax": "function void keyfields.to.object (long object)",
    "description": "Store the current value of the key fields to the passed key field object.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields object which must be returned by a previous call to create.keyfields.object()"
      }
    ],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "object.to.keyfields": {
    "name": "object.to.keyfields",
    "type": "function",
    "syntax": "function void object.to.keyfields (long object)",
    "description": "Restore the value of the key fields from the passed key field object.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "ID of the key fields object which must be returned by a previous call to create.keyfields.object()"
      }
    ],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "key fields object overview": {
    "name": "Key fields Object overview",
    "type": "function",
    "syntax": "function Key fields Object overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "key fields object synopsis": {
    "name": "Key fields object synopsis",
    "type": "function",
    "syntax": "function Key fields object synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_keyfields"
  },
  "abs": {
    "name": "abs",
    "type": "function",
    "syntax": "function double abs (void value)",
    "description": "This function returns the absolute value of the supplied numeric value.",
    "arguments": [
      {
        "type": "void",
        "name": "value",
        "description": "Numeric value of which the absolute value must be returned."
      }
    ],
    "returnValue": "If the type of the input value is not double , then implicit type conversion of the input value to type long is performed. Then, if the resulting value (of type double or of type long) is negative, the unary minus operator is applied to it. Finally, the resulting value (of type double or of type long) is returned. Notice that, even though the return type is specified as 'double', the run time type of the return value can be 'long'. No implicit type conversion to double is performed at this point!",
    "category": "functions_mathematical_operations"
  },
  "acos": {
    "name": "acos",
    "type": "function",
    "syntax": "function double acos (double x)",
    "description": "This computes the arc cosine of x. The value of x must be in the range [-1, 1].",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The arc cosine of x , expressed as a floating point number in the range [0, p] radians.",
    "category": "functions_mathematical_operations"
  },
  "asin": {
    "name": "asin",
    "type": "function",
    "syntax": "function double asin (double x)",
    "description": "This computes the arc sine of x. The value of x must be in the range [-1, 1].",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The arc sine of x , expressed as a floating point number in the range [-p/2, p/2] radians.",
    "category": "functions_mathematical_operations"
  },
  "atan": {
    "name": "atan",
    "type": "function",
    "syntax": "function double atan (double x)",
    "description": "This computes the arc tangent of x.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The arc tangent of x , expressed as a floating point number in the range [-p/2, p/2] radians.",
    "category": "functions_mathematical_operations"
  },
  "cos": {
    "name": "cos",
    "type": "function",
    "syntax": "function double cos (double x)",
    "description": "This computes the cosine of x , in radians. The x argument can be a long or a double.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The cosine of x .",
    "category": "functions_mathematical_operations"
  },
  "cosh": {
    "name": "cosh",
    "type": "function",
    "syntax": "function double cosh (double x)",
    "description": "This computes the hyperbolic cosine of x .",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The hyperbolic cosine of x .",
    "category": "functions_mathematical_operations"
  },
  "double.cmp": {
    "name": "double.cmp",
    "type": "function",
    "syntax": "function long double.cmp (double double1, double double2, double tolerance)",
    "description": "",
    "arguments": [
      {
        "type": "double",
        "name": "double1",
        "description": "A double value."
      },
      {
        "type": "double",
        "name": "double2",
        "description": "A double value."
      },
      {
        "type": "double",
        "name": "tolerance",
        "description": "Specifies a tolerance value for the function. If the difference between the two doubles is less than this value, the doubles are considered equal. Do not use a tolerance of 0. Also, do not use a negative tolerance."
      }
    ],
    "returnValue": "0 the difference between the doubles is less than the tolerance. -1 double1 is less than double2 (the difference is greater than the tolerance). 1 double1 is greater than or equal to double2 (the difference is greater than the tolerance).",
    "category": "functions_mathematical_operations"
  },
  "exp": {
    "name": "exp",
    "type": "function",
    "syntax": "function double exp (double x)",
    "description": "This returns the exponent of x . That is, it computes the value of the mathematical constant e (2.7182818) raised to the power of x .",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The exponent of x.",
    "category": "functions_mathematical_operations"
  },
  "format.round": {
    "name": "format.round",
    "type": "function",
    "syntax": "function double format.round (double value, string format [, long mode])",
    "description": "The rounds a value according to a specified format.",
    "arguments": [
      {
        "type": "double",
        "name": "value",
        "description": "The value to be rounded."
      },
      {
        "type": "string",
        "name": "format",
        "description": "The format for the returned value. For example %10.5f or %5.10g. See sprintf$() ."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This argument is optional. If it is not included, the default mode is 1. 0: truncate (for example, both 1.5 and 1.49 are rounded down to 1) 1: normal round (for example, 1.5 is rounded up to 2; 1.49 is rounded down to 1) 2: round up (for example, both 1.5 and 1.49 are rounded up to 2)"
      }
    ],
    "returnValue": "The rounded value.",
    "category": "functions_mathematical_operations"
  },
  "halfadj": {
    "name": "halfadj",
    "type": "function",
    "syntax": "function double halfadj (double value, long diga)",
    "description": "This rounds a given value to a specified number of decimal places.",
    "arguments": [
      {
        "type": "double",
        "name": "value",
        "description": "The value to be rounded."
      },
      {
        "type": "long",
        "name": "diga",
        "description": "The number of decimal places to which value is to be rounded."
      }
    ],
    "returnValue": "The rounded value. Or the original value ( value ) if an error occurs. Because the return value is of type double, the number of digits after the decimal sign is always 6. For example, halfadj(1.345, 2) returns 1.350000. The function is identical to round( value, diga, 1)",
    "category": "functions_mathematical_operations"
  },
  "int": {
    "name": "int",
    "type": "function",
    "syntax": "function long int (double x)",
    "description": "The function int() performs explicit double to long type conversion .",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The long value resulting from the described explicit double to long type conversion applied to the supplied input value.",
    "category": "functions_mathematical_operations"
  },
  "log": {
    "name": "log",
    "type": "function",
    "syntax": "function double log (double x)",
    "description": "This computes the natural logarithm of x . The value of x must be greater than zero.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The log of x .",
    "category": "functions_mathematical_operations"
  },
  "log10": {
    "name": "log10",
    "type": "function",
    "syntax": "function double log10 (double x)",
    "description": "This computes the base 10 logarithm of x . The value of x must be greater than zero.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The base 10 log of x .",
    "category": "functions_mathematical_operations"
  },
  "lpow": {
    "name": "lpow",
    "type": "function",
    "syntax": "function long lpow (long x, long y)",
    "description": "This computes the value of x raised to the power of y . The y argument must be positive.",
    "arguments": [
      {
        "type": "long",
        "name": "x",
        "description": ""
      },
      {
        "type": "long",
        "name": "y",
        "description": ""
      }
    ],
    "returnValue": "The value of x^y, (i.e. x to the power of y ). If y is zero, the return value is always 1. When the exact resulting value is outside the signed BitCountOfLong -bit value range, then the result is undefined.",
    "category": "functions_mathematical_operations"
  },
  "max": {
    "name": "max",
    "type": "function",
    "syntax": "function double max (double x, double y)",
    "description": "This compares the values of the two arguments and returns whichever is the greatest. The arguments can be of type long or double or can contain any numeric expression.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      },
      {
        "type": "double",
        "name": "y",
        "description": ""
      }
    ],
    "returnValue": "The greatest of the two values.",
    "category": "functions_mathematical_operations"
  },
  "min": {
    "name": "min",
    "type": "function",
    "syntax": "function double min (double x, double x)",
    "description": "This compares the values of the two arguments and returns whichever is the smallest. The arguments can be of type long or double or can contain any numeric expression.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      },
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The lesser of the two values.",
    "category": "functions_mathematical_operations"
  },
  "mathematical operations overview": {
    "name": "Mathematical operations overview",
    "type": "function",
    "syntax": "function Mathematical operations overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "pow": {
    "name": "pow",
    "type": "function",
    "syntax": "function double pow (double x, double y)",
    "description": "This computes the value of x raised to the power of y . If x is zero, y must be positive. If x is negative, y must be an integer.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      },
      {
        "type": "double",
        "name": "y",
        "description": ""
      }
    ],
    "returnValue": "The value of x to the power of y. If y is zero, the return value is always 1.0",
    "category": "functions_mathematical_operations"
  },
  "round": {
    "name": "round",
    "type": "function",
    "syntax": "function double round (double value, long diga, long mode)",
    "description": "This rounds a given value to a specified number of decimal places.",
    "arguments": [
      {
        "type": "double",
        "name": "value",
        "description": "The value to be rounded."
      },
      {
        "type": "long",
        "name": "diga",
        "description": "The number of decimal places to which value is to be rounded."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "0 truncate (for example, both 1.5 and 1.49 are rounded down to 1) 1 normal round (for example, 1.5 is rounded up to 2; 1.49 is rounded down to 1) 2 round up (for example, both 1.5 and 1.49 are rounded up to 2)"
      }
    ],
    "returnValue": "The rounded value. Or the original value ( value ) if an error occurs. Because the return value is of type double, the number of digits after the decimal sign is always 6. For example, round(1.345, 2, 1) returns 1.350000.",
    "category": "functions_mathematical_operations"
  },
  "set.fmax": {
    "name": "set.fmax",
    "type": "function",
    "syntax": "function void set.fmax (ref void variable [, string domain])",
    "description": "This sets a specified string variable to its maximum value.",
    "arguments": [
      {
        "type": "ref void",
        "name": "variable",
        "description": "Reference argument to be set. This can be a single variable or an array."
      },
      {
        "type": "[string",
        "name": "domain ]",
        "description": "Optional name of the domain of which the maximum value must be used. If it is not supplied, then the runtime domain of the first argument is used. The runtime domain of the first argument is determined by means of a lookup of its name in the runtime list of table fields. Notice that for a normal variable declared by means of a domain declaration , its declared domain is not known at runtime. If for the first argument no runtime domain is found, then its name is looked up in the list of form fields of the current form of the process. If it is found, then the domain type as specified in the form is used. Otherwise, a default domain type is used which depends on the runtime type of the first argument. Notice that if the first argument is a subscripted variable, then at runtime its name is not available, so both the lookup in the runtime list of table fields and the lookup in the list of form fields is skipped. When the compiler has any reason to suspect that specifying the compile time domain of the first argument would lead to a different result than omitting it, then (as of porting set TIV level 2100 ) it issues warning 23 or 24 . In the future, in some cases this will change to an error."
      }
    ],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "set.fmin": {
    "name": "set.fmin",
    "type": "function",
    "syntax": "function void set.fmin (ref void variable [, string domain])",
    "description": "This sets a specified string variable to its minimum value.",
    "arguments": [
      {
        "type": "ref void",
        "name": "variable",
        "description": "Reference argument to be set. This can be a single variable or an array."
      },
      {
        "type": "[string",
        "name": "domain ]",
        "description": "Optional name of the domain of which the minimum value must be used. If it is not supplied, then the runtime domain of the first argument is used. The runtime domain of the first argument is determined by means of a lookup of its name in the runtime list of table fields. Notice that for a normal variable declared by means of a domain declaration , its declared domain is not known at runtime. If for the first argument no runtime domain is found, then its name is looked up in the list of form fields of the current form of the process. If it is found, then the domain type as specified in the form is used. Otherwise, a default domain type is used which depends on the runtime type of the first argument. Notice that if the first argument is a subscripted variable, then at runtime its name is not available, so both the lookup in the runtime list of table fields and the lookup in the list of form fields is skipped. When the compiler has any reason to suspect that specifying the compile time domain of the first argument would lead to a different result than omitting it, then (as of porting set TIV level 2100 ) it issues warning 23 or 24 . In the future, in some cases this will change to an error."
      }
    ],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "set.max": {
    "name": "set.max",
    "type": "function",
    "syntax": "function void set.max (ref void variable [, string domain])",
    "description": "This sets a specified standard variable to its maximum value.",
    "arguments": [
      {
        "type": "ref void",
        "name": "variable",
        "description": "Reference argument to be set. This can be a single variable or an array."
      },
      {
        "type": "[string",
        "name": "domain ]",
        "description": "Optional name of the domain of which the maximum value must be used. If it is not supplied, then the runtime domain of the first argument is used. The runtime domain of the first argument is determined by means of a lookup of its name in the runtime list of table fields. Notice that for a normal variable declared by means of a domain declaration , its declared domain is not known at runtime. If for the first argument no runtime domain is found, then its name is looked up in the list of form fields of the current form of the process. If it is found, then the domain type as specified in the form is used. Otherwise, a default domain type is used which depends on the runtime type of the first argument. Notice that if the first argument is a subscripted variable, then at runtime its name is not available, so both the lookup in the runtime list of table fields and the lookup in the list of form fields is skipped. When the compiler has any reason to suspect that specifying the compile time domain of the first argument would lead to a different result than omitting it, then (as of porting set TIV level 2100 ) it issues warning 23 or 24 . In the future, in some cases this will change to an error."
      }
    ],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "set.min": {
    "name": "set.min",
    "type": "function",
    "syntax": "function void set.min (ref void variable [, string domain])",
    "description": "This sets a specified standard variable to its minimum value.",
    "arguments": [
      {
        "type": "ref void",
        "name": "variable",
        "description": "Reference argument to be set. This can be a single variable or an array."
      },
      {
        "type": "[string",
        "name": "domain ]",
        "description": "Optional name of the domain of which the minimum value must be used. If it is not supplied, then the runtime domain of the first argument is used. The runtime domain of the first argument is determined by means of a lookup of its name in the runtime list of table fields. Notice that for a normal variable declared by means of a domain declaration , its declared domain is not known at runtime. If for the first argument no runtime domain is found, then its name is looked up in the list of form fields of the current form of the process. If it is found, then the domain type as specified in the form is used. Otherwise, a default domain type is used which depends on the runtime type of the first argument. Notice that if the first argument is a subscripted variable, then at runtime its name is not available, so both the lookup in the runtime list of table fields and the lookup in the list of form fields is skipped. When the compiler has any reason to suspect that specifying the compile time domain of the first argument would lead to a different result than omitting it, then (as of porting set TIV level 2100 ) it issues warning 23 or 24 . In the future, in some cases this will change to an error."
      }
    ],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "sin": {
    "name": "sin",
    "type": "function",
    "syntax": "function double sin (double x)",
    "description": "This computes the sine of x , in radians. The x argument can be a long or a double.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The sine of x .",
    "category": "functions_mathematical_operations"
  },
  "sinh": {
    "name": "sinh",
    "type": "function",
    "syntax": "function double sinh (double x)",
    "description": "This computes the hyperbolic sine of x .",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The hyperbolic sine of x .",
    "category": "functions_mathematical_operations"
  },
  "sqrt": {
    "name": "sqrt",
    "type": "function",
    "syntax": "function double sqrt (double x)",
    "description": "This computes the non-negative square root of x . The x argument must not be less than zero. It can be of type long or double.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The non-negative square root of x .",
    "category": "functions_mathematical_operations"
  },
  "mathematical operations synopsis": {
    "name": "Mathematical operations synopsis",
    "type": "function",
    "syntax": "function Mathematical operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "table.round": {
    "name": "table.round",
    "type": "function",
    "syntax": "function void table.round ( [void field [, field] ...] [, string table [, table] ...])",
    "description": "This rounds the values in certain tables and table fields according to parameters defined in the domain definition in the data dictionary.",
    "arguments": [
      {
        "type": "[void",
        "name": "field [, field] ... ]",
        "description": "The names of one or more table fields. The function rounds the values in all specified fields."
      },
      {
        "type": "[string",
        "name": "table [, table] ... ]",
        "description": "The names of one or more tables. The function rounds all fields in the specified tables. You must specify table names within quotes � for example, \" tpctst999\"."
      }
    ],
    "returnValue": "",
    "category": "functions_mathematical_operations"
  },
  "tan": {
    "name": "tan",
    "type": "function",
    "syntax": "function double tan (double x)",
    "description": "This computes the tangent of x , in radians. The x argument can be a long or a double.",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The tangent of x .",
    "category": "functions_mathematical_operations"
  },
  "tanh": {
    "name": "tanh",
    "type": "function",
    "syntax": "function double tanh (double x)",
    "description": "This computes the hyperbolic tangent of x .",
    "arguments": [
      {
        "type": "double",
        "name": "x",
        "description": ""
      }
    ],
    "returnValue": "The hyperbolic tangent of x .",
    "category": "functions_mathematical_operations"
  },
  "alloc.mem": {
    "name": "alloc.mem",
    "type": "function",
    "syntax": "function long alloc.mem (ref variable, long dimension1 [, long dimension2, ...])",
    "description": "This allocates memory space to the specified variable at run time. The variable can be a string or an array (of any type). It must be declared as BASED. With multi-dimensional arrays, each dimension must be initialized to 1 at declaration. Once alloc.mem() has allocated memory for a variable, that variable behaves in the same way as any other variable.",
    "arguments": [
      {
        "type": "ref",
        "name": "variable",
        "description": ""
      },
      {
        "type": "long",
        "name": "dimension1",
        "description": ""
      },
      {
        "type": "[long",
        "name": "dimension2, ... ]",
        "description": ""
      }
    ],
    "returnValue": "0 success -1 insufficient memory available",
    "category": "functions_memory_operations"
  },
  "array.get.size.in.bytes": {
    "name": "array.get.size.in.bytes",
    "type": "function",
    "syntax": "function long array.get.size.in.bytes (void var)",
    "description": "This returns the number of bytes available for a specified array or string",
    "arguments": [
      {
        "type": "void",
        "name": "var",
        "description": "The name of the array or string."
      }
    ],
    "returnValue": "If var is an array or string, then the number of bytes available for it is returned. If var is not an array or string, then the value 0 is returned.",
    "category": "functions_memory_operations"
  },
  "array.info": {
    "name": "array.info",
    "type": "function",
    "syntax": "function void array.info (void var, ref long nr.dims, ref long dim.info())",
    "description": "This function returns the number of dimensions in a specified array variable and the size of each dimension.",
    "arguments": [
      {
        "type": "void",
        "name": "var",
        "description": "Any variable, typically (but not restricted to) an array variable."
      },
      {
        "type": "ref long",
        "name": "nr.dims",
        "description": "Reference parameter which receives the number of dimensions of var . If var is a non-array variable, then nr.dims returns 0. If var is a string variable, then nr.dims returns 1. If var is an array variable, then the value returned by nr.dims is at least 1 and at most 4."
      },
      {
        "type": "ref long",
        "name": "dim.info()",
        "description": "Reference array parameter which receives the sizes of the dimensions of var . The number of elements of dim.info must not be less than the value returned by nr.dims The first nr.dims elements of dim.info are filled with the size of the corresponding dimension of var . Any further elements of dim.info (but not further than dim.info(4)) are set to value 0."
      }
    ],
    "returnValue": "",
    "category": "functions_memory_operations"
  },
  "cmp.mem": {
    "name": "cmp.mem",
    "type": "function",
    "syntax": "function long cmp.mem (void var1, void var2 [, long count])",
    "description": "This compares the values of two variables or arrays. By default, the values are compared for the length of the shortest argument. If you specify the optional count argument, the function compares the first count numbers or characters of both arguments. The number of numbers or characters compared will, however, never exceed the length of the shortest argument.",
    "arguments": [
      {
        "type": "void",
        "name": "var1",
        "description": ""
      },
      {
        "type": "void",
        "name": "var2",
        "description": ""
      },
      {
        "type": "[long",
        "name": "count ]",
        "description": ""
      }
    ],
    "returnValue": "The return values depend on the types of the variables. Variables are of different types: 1 Variables are longs or doubles: 0 values are equal 1 values are different Variables are strings or arrays of type long, double, or string: <0 first argument is less than second =0 arguments are equal >0 first argument is greater than second",
    "category": "functions_memory_operations"
  },
  "copy.mem": {
    "name": "copy.mem",
    "type": "function",
    "syntax": "function void copy.mem (ref void destination, void source [, long count])",
    "description": "This copies the memory space from the source argument to the destination argument. By default, the total length of source is copied. But, if the destination argument is shorter than the source argument, then source is truncated. Use the optional count argument to copy a specified number of array elements only.",
    "arguments": [
      {
        "type": "ref void",
        "name": "destination",
        "description": ""
      },
      {
        "type": "void",
        "name": "source",
        "description": ""
      },
      {
        "type": "[long",
        "name": "count ]",
        "description": "Optional argument for the specification of the number of array elements to be copied. Default value is the minimum of the element counts of the destination and source arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_memory_operations"
  },
  "free.mem": {
    "name": "free.mem",
    "type": "function",
    "syntax": "function void free.mem (void variable)",
    "description": "This deallocates memory space previously allocated to the specified variable by alloc.mem() . The freed memory becomes available for another allocation. The variable cannot be used again after deallocation, unless it is reallocated memory space again using alloc.mem() .",
    "arguments": [
      {
        "type": "void",
        "name": "variable",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_memory_operations"
  },
  "memory operations overview and synopsis": {
    "name": "Memory operations overview and synopsis",
    "type": "function",
    "syntax": "function Memory operations overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_memory_operations"
  },
  "set.mem": {
    "name": "set.mem",
    "type": "function",
    "syntax": "function long set.mem (ref void destination, void source [, long count])",
    "description": "The stores the value of source in the destination argument. By default, the value of source is repeated in destination until the latter is completely filled. Use the optional count argument to repeat the value of source a specific number of times only. Elements in the destination argument which are not overwritten remain unchanged.",
    "arguments": [
      {
        "type": "ref void",
        "name": "destination",
        "description": ""
      },
      {
        "type": "void",
        "name": "source",
        "description": ""
      },
      {
        "type": "[long",
        "name": "count ]",
        "description": ""
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_memory_operations"
  },
  "add.message.button": {
    "name": "add.message.button",
    "type": "function",
    "syntax": "function long add.message.button (string msgCode, string buttonLabel, string library, string fnc, long autg, string Session)",
    "description": "Add an additional button to a message or a question. This button will execute the specified function from the specified Library.",
    "arguments": [
      {
        "type": "string",
        "name": "msgCode",
        "description": "The message code where for which the button is added"
      },
      {
        "type": "string",
        "name": "buttonLabel",
        "description": "The label of the button"
      },
      {
        "type": "string",
        "name": "library",
        "description": "The library from where the function is executed"
      },
      {
        "type": "string",
        "name": "fnc",
        "description": "The function to be executed"
      }
    ],
    "returnValue": "0 Button correctly added -1 Library not found -2 Function not found in library -3 Max number of additional buttons (4) exceeded -4 Not authorized",
    "category": "functions_message_handling"
  },
  "clean.mess": {
    "name": "clean.mess",
    "type": "function",
    "syntax": "function void clean.mess ()",
    "description": "This removes a message that was displayed by using the mess() function with its mode argument set to 0.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.clear.error.messages": {
    "name": "dal.clear.error.messages",
    "type": "function",
    "syntax": "function void dal.clear.error.messages ()",
    "description": "This clears all DAL error messages from the message buffer. Abbreviation for dal.reset.error.messages(0).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.clear.messages": {
    "name": "dal.clear.messages",
    "type": "function",
    "syntax": "function void dal.clear.messages (long i.type)",
    "description": "This clears all DAL messages of the specified type from the message buffer. Abbreviation for dal.reset.messages(i.type, 0).",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.count.error.messages": {
    "name": "dal.count.error.messages",
    "type": "function",
    "syntax": "function long dal.count.error.messages ()",
    "description": "This returns the number of DAL messages of type MSG.ERROR currently in the message buffer.",
    "arguments": [],
    "returnValue": "The number of error messages in the message buffer.",
    "category": "functions_message_handling"
  },
  "dal.count.messages": {
    "name": "dal.count.messages",
    "type": "function",
    "syntax": "function long dal.count.messages (long i.type)",
    "description": "This returns the number of DAL messages of the specified type that are currently in the message buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      }
    ],
    "returnValue": "The number of DAL messages of the specified type.",
    "category": "functions_message_handling"
  },
  "dal.get.error.message": {
    "name": "dal.get.error.message",
    "type": "function",
    "syntax": "function long dal.get.error.message (ref string mesg)",
    "description": "This retrieves the most recent DAL message of type MSG.ERROR from the message buffer. The message is removed from the buffer.",
    "arguments": [
      {
        "type": "ref string",
        "name": "mesg",
        "description": ""
      }
    ],
    "returnValue": "The number of error messages that remain in the message buffer, or -1 if the buffer is empty. (In the latter case the returned message is \"\".)",
    "category": "functions_message_handling"
  },
  "dal.get.error.msgcode": {
    "name": "dal.get.error.msgcode",
    "type": "function",
    "syntax": "function string dal.get.error.msgcode ()",
    "description": "This retrieves the message code of most recent DAL error message from the message buffer. The message is not removed from the buffer.",
    "arguments": [],
    "returnValue": "The message code.",
    "category": "functions_message_handling"
  },
  "dal.get.first.error.message": {
    "name": "dal.get.first.error.message",
    "type": "function",
    "syntax": "function long dal.get.first.error.message (ref string mesg, ref string code)",
    "description": "This retrieves the oldest DAL message of type MSG.ERROR from the message buffer, together with the message code. The message is removed from the buffer.",
    "arguments": [
      {
        "type": "ref string",
        "name": "mesg",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "code",
        "description": ""
      }
    ],
    "returnValue": "The number of error messages that remain in the message buffer, or -1 if the buffer is empty. (In the latter case the returned message and message code are both \"\".)",
    "category": "functions_message_handling"
  },
  "dal.get.first.message": {
    "name": "dal.get.first.message",
    "type": "function",
    "syntax": "function boolean dal.get.first.message (long i.type, ref string o.code, ref string o.text [, ref long o.type])",
    "description": "Returns the code and text of the oldest message of the given type. In case MSG.ALL is passed as the type, then the type of the message is returned in the 4th argument.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      },
      {
        "type": "ref string",
        "name": "o.code",
        "description": "The returned code of the message."
      },
      {
        "type": "ref string",
        "name": "o.text",
        "description": "The returned text of the message."
      },
      {
        "type": "[ref long",
        "name": "o.type ]",
        "description": "Optional, the returned type of the message, in case MSG.ALL was passed as the first argument."
      }
    ],
    "returnValue": "This function returns TRUE if a message could be retrieved, else FALSE is returned.",
    "category": "functions_message_handling"
  },
  "dal.get.last.message": {
    "name": "dal.get.last.message",
    "type": "function",
    "syntax": "function boolean dal.get.last.message (long i.type, ref string o.code, ref string o.text [, ref long o.type])",
    "description": "Returns the code and text of the most recent message of the given type. In case MSG.ALL is passed as the type, then the type of the message is returned in the 4th argument. The message is removed from the buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      },
      {
        "type": "ref string",
        "name": "o.code",
        "description": "The returned code of the message."
      },
      {
        "type": "ref string",
        "name": "o.text",
        "description": "The returned text of the message."
      },
      {
        "type": "[ref long",
        "name": "o.type ]",
        "description": "Optional, the returned type of the message, in case MSG.ALL was passed as the first argument."
      }
    ],
    "returnValue": "This function returns TRUE if a message could be retrieved, else FALSE is returned.",
    "category": "functions_message_handling"
  },
  "dal.peek.error.message": {
    "name": "dal.peek.error.message",
    "type": "function",
    "syntax": "function string dal.peek.error.message (long n)",
    "description": "This retrieves the DAL message of type MSG.ERROR from the message buffer at position n. The message is not removed from the buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "n",
        "description": ""
      }
    ],
    "returnValue": "The message from the message buffer at position n , where n = 1 is the oldest message.",
    "category": "functions_message_handling"
  },
  "dal.peek.error.msgcode": {
    "name": "dal.peek.error.msgcode",
    "type": "function",
    "syntax": "function string dal.peek.error.msgcode (long n)",
    "description": "This retrieves the message code from the message buffer at position n . The message is not removed from the buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "n",
        "description": ""
      }
    ],
    "returnValue": "The message code.",
    "category": "functions_message_handling"
  },
  "dal.peek.message": {
    "name": "dal.peek.message",
    "type": "function",
    "syntax": "function void dal.peek.message (long i.type, long i.index, ref string o.code, ref string o.text [, ref long o.type])",
    "description": "Returns the code and text of the message of the specified type that is located at the given index in the message buffer. In case you specify MSG.ALL as the type, the type of the message is returned in the 5th argument.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      },
      {
        "type": "long",
        "name": "i.index",
        "description": "The position of the message in the buffer."
      },
      {
        "type": "ref string",
        "name": "o.code",
        "description": "The returned code of the message."
      },
      {
        "type": "ref string",
        "name": "o.text",
        "description": "The returned text of the message."
      },
      {
        "type": "[ref long",
        "name": "o.type ]",
        "description": "Optional, the returned type of the message, in case MSG.ALL was passed as the first argument."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.reset.error.messages": {
    "name": "dal.reset.error.messages",
    "type": "function",
    "syntax": "function void dal.reset.error.messages (long amt)",
    "description": "This clears the most recent DAL messages of type MSG.ERROR from the message buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "amt",
        "description": "0 clear the entire buffer >0 leave the specified number of oldest messages in the buffer; the rest are cleared. <0 clear the specified number of the most recent messages (the absolute value of amt is used)."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.reset.messages": {
    "name": "dal.reset.messages",
    "type": "function",
    "syntax": "function void dal.reset.messages (long i.type, long i.count)",
    "description": "Removes the most recent messages of the given type from the DAL message buffer. The 2nd argument determines how many messages will remain in the buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO ."
      },
      {
        "type": "long",
        "name": "i.count",
        "description": "0"
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.set.error.message, dal.set.warning.message, dal.set.info.message": {
    "name": "dal.set.error.message, dal.set.warning.message, dal.set.info.message",
    "type": "function",
    "syntax": "function void dal.set.error.message (string mess.or.code [, void arg ...])",
    "description": "These functions add a message to the DAL message buffer of type MSG.ERROR , MSG.WARNING , or MSG.INFO .",
    "arguments": [
      {
        "type": "string",
        "name": "mess.or.code",
        "description": "Specifies either the data dictionary code for the message or a literal string. In the latter case, the value of mess.or.code must start with the at sign [@]. Note that using a literal string makes the script language dependent."
      },
      {
        "type": "[void",
        "name": "arg ... ]",
        "description": "The literal string or message specified with mess.or.code can contain format characters for parameter substitution. The values which must be substituted are specified in the 2nd, 3rd, ... arguments of the function. The number of these arguments is variable. For details about formatting a string see the sprintf$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.set.message": {
    "name": "dal.set.message",
    "type": "function",
    "syntax": "function void dal.set.message (long i.type, const string i.mess.or.code [, void arg ...])",
    "description": "Adds a message of the specified type to the DAL message buffer.",
    "arguments": [
      {
        "type": "long",
        "name": "i.type",
        "description": "A message type. Parameter i.type should be one of the following values: MSG.ERROR, MSG.WARNING, MSG.INFO ."
      },
      {
        "type": "const string",
        "name": "i.mess.or.code",
        "description": "Specifies either the data dictionary code for the message or a literal string. In the latter case, the value of i.mess.or.code must start with the at sign [@]. Note that using a literal string makes the script language dependent."
      },
      {
        "type": "[void",
        "name": "arg ... ]",
        "description": "The literal string or message specified with i.mess.or.code can contain format characters for parameter substitution. The values which must be substituted are specified in the 2nd, 3rd, ... arguments of the function. The number of these arguments is variable. For details about formatting a string see the sprintf$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.set.messages.off": {
    "name": "dal.set.messages.off",
    "type": "function",
    "syntax": "function void dal.set.messages.off ()",
    "description": "Turns off dal.set.error.message() . After calling dal.set.messages.off(), any calls to dal.set.error.message() are ignored.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "dal.set.messages.on": {
    "name": "dal.set.messages.on",
    "type": "function",
    "syntax": "function void dal.set.messages.on ()",
    "description": "Turns on dal.set.error.message .",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "form.text$": {
    "name": "form.text$",
    "type": "function",
    "syntax": "function string form.text$ (string messcode [, string language_code])",
    "description": "This retrieves a message from the data dictionary. It is used for constructing strings with parameter substitution. For messages to the screen, use mess() .",
    "arguments": [
      {
        "type": "string",
        "name": "messcode",
        "description": "The message code of the required message."
      },
      {
        "type": "[string",
        "name": "language_code ]",
        "description": "The language code. If you do not specify a language code, the user language is used. Otherwise the message with the specified language is retrieved (if available)."
      }
    ],
    "returnValue": "The message string.",
    "category": "functions_message_handling"
  },
  "mess": {
    "name": "mess",
    "type": "function",
    "syntax": "function void mess (string messcode, long separate_window [, void arg ...])",
    "description": "This retrieves a message from the data dictionary and displays it on screen. Using this function makes your program script language independent.",
    "arguments": [
      {
        "type": "string",
        "name": "messcode",
        "description": "The message code (including the package code). The language code of the user is automatically added. Both the message code and the user language must be available in the data dictionary."
      },
      {
        "type": "long",
        "name": "separate_window",
        "description": "This specifies how the message can be removed: 1"
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "message": {
    "name": "message",
    "type": "function",
    "syntax": "function void message (string mess_str [, void arg ...])",
    "description": "This displays the specified message string on screen in a separate window, and waits until the user closes it. This is applicable in case the message mode of the concerning user is set to \"Interactive\". In case of a \"Non-interrupting\" message mode, ERP Enterprise displays the message strings in a separate \"Messages\" window without interruption.",
    "arguments": [
      {
        "type": "string",
        "name": "mess_str",
        "description": "The message string to be displayed. This can contain format characters for parameter substitution. For details about formatting a string see the sprintf$() ."
      },
      {
        "type": "[void",
        "name": "arg ... ]",
        "description": "The message string can contain format characters for parameter substitution. The values which must be substituted are specified in the 2nd, 3rd, ... arguments of the function. The number of these arguments is variable."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "message handling overview and synopsis": {
    "name": "Message handling overview and synopsis",
    "type": "function",
    "syntax": "function Message handling overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "set.input.error": {
    "name": "set.input.error",
    "type": "function",
    "syntax": "function void set.input.error (string mess.or.code [, void arg ...])",
    "description": "This causes the 4GL engine to display the specified error message and to force input again in the same input field. If you specify an empty string, no error message is displayed.",
    "arguments": [
      {
        "type": "string",
        "name": "mess.or.code",
        "description": "Specifies either the data dictionary code for the message or a literal string. In the latter case, the value of mess.or.code must start with the at sign [@]. Note that using a literal string makes the script language dependent."
      },
      {
        "type": "[void",
        "name": "arg ... ]",
        "description": "The literal string or message specified with mess.or.code can contain format characters for parameter substitution. The values which must be substituted are specified in the 2nd, 3rd, ... arguments of the function. The number of these arguments is variable. For details about formatting a string see the sprintf$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "show.dal.messages": {
    "name": "show.dal.messages",
    "type": "function",
    "syntax": "function void show.dal.messages ( [long i.type])",
    "description": "Displays messages that are currently on the DAL message stack. Depending on the specified message type, you can display error, warning or info messages, or all messages. If no message type is specified, only error messages will be displayed.",
    "arguments": [
      {
        "type": "[long",
        "name": "i.type ]",
        "description": "A message type. If not specified, only error messages are displayed. Parameter i.type should be one of the following values: MSG.ALL, MSG.ERROR, MSG.WARNING, MSG.INFO"
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "status.del": {
    "name": "status.del",
    "type": "function",
    "syntax": "function void status.del ()",
    "description": "This clears the first status field in the status area. Abbreviation for status.mess(\"\").",
    "arguments": [],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "status.mess": {
    "name": "status.mess",
    "type": "function",
    "syntax": "function void status.mess (string strg)",
    "description": "This displays the specified message in the first status field of a 4GL form.",
    "arguments": [
      {
        "type": "string",
        "name": "strg",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_message_handling"
  },
  "multi language data support code examples": {
    "name": "Multi Language Data support code examples",
    "type": "function",
    "syntax": "function Multi Language Data support code examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_mle"
  },
  "ml_get_baselang": {
    "name": "ml_get_baselang",
    "type": "function",
    "syntax": "function string ml_get_baselang ()",
    "description": "Returns the base language of the environment.",
    "arguments": [],
    "returnValue": "the base language of the environment, or \"\" in case Multi Language support is inactive",
    "category": "functions_mle"
  },
  "ml_get_datalang": {
    "name": "ml_get_datalang",
    "type": "function",
    "syntax": "function string ml_get_datalang ()",
    "description": "Returns the current data language of the user.",
    "arguments": [],
    "returnValue": "the current data language of the user, or \"\" in case Multi Language support is inactive",
    "category": "functions_mle"
  },
  "ml_get_datalang_of_softlang": {
    "name": "ml_get_datalang_of_softlang",
    "type": "function",
    "syntax": "function string ml_get_datalang_of_softlang (const string softlang)",
    "description": "Returns the data language of the specified software language.",
    "arguments": [
      {
        "type": "const string",
        "name": "softlang",
        "description": "a software language code (like \"2\" for english)"
      }
    ],
    "returnValue": "the data language of the specified software language, or \"\" if no data language defined for the specified software language",
    "category": "functions_mle"
  },
  "ml_is_active": {
    "name": "ml_is_active",
    "type": "function",
    "syntax": "function boolean ml_is_active ()",
    "description": "Tests whether Multi Language support is active on runtime for the current environment.",
    "arguments": [],
    "returnValue": "TRUE Multi Language support is active. FALSE Multi Language support is inactive.",
    "category": "functions_mle"
  },
  "ml_one_lang": {
    "name": "ml_one_lang",
    "type": "function",
    "syntax": "function string ml_one_lang (const string mlv [, const string language])",
    "description": "This function retrieves the value in a specific data language from a string variable.",
    "arguments": [
      {
        "type": "const string",
        "name": "mlv",
        "description": "a multi language value (string)"
      },
      {
        "type": "[const string",
        "name": "language ]",
        "description": "a valid Data Language code"
      }
    ],
    "returnValue": "The value in the specified data language'. If the optional argument 'language' is not specified: the value in the 'current data language' This function can be used in SQL as well, to select values in just one language from the database.",
    "category": "functions_mle"
  },
  "ml_set_datalang": {
    "name": "ml_set_datalang",
    "type": "function",
    "syntax": "function long ml_set_datalang (const string datalang)",
    "description": "Sets a new data language for the user.",
    "arguments": [
      {
        "type": "const string",
        "name": "datalang",
        "description": "a valid Data Language code"
      }
    ],
    "returnValue": "0 OK <> 0 Error",
    "category": "functions_mle"
  },
  "multi language data overview": {
    "name": "Multi Language Data overview",
    "type": "function",
    "syntax": "function Multi Language Data overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_mle"
  },
  "multi language data synopsis": {
    "name": "Multi Language Data synopsis",
    "type": "function",
    "syntax": "function Multi Language Data synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_mle"
  },
  "mb.cast$": {
    "name": "mb.cast$",
    "type": "function",
    "syntax": "function string mb.cast$ (string string_expres)",
    "description": "This function converts a specified string to a multibyte string. The content of the string remains the same.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expres",
        "description": ""
      }
    ],
    "returnValue": "The multibyte string.",
    "category": "functions_multibyte_strings"
  },
  "mb.cast.to.str$": {
    "name": "mb.cast.to.str$",
    "type": "function",
    "syntax": "function string mb.cast.to.str$ (string string_express)",
    "description": "This function converts a specified string to a single-byte string. The content of the string remains the same.",
    "arguments": [
      {
        "type": "string",
        "name": "string_express",
        "description": ""
      }
    ],
    "returnValue": "The single-byte string.",
    "category": "functions_multibyte_strings"
  },
  "mb.char": {
    "name": "mb.char",
    "type": "function",
    "syntax": "function long mb.char (long charvalue)",
    "description": "This function tests if a specified character code represents a multibyte character. It is mainly used in conjunction with the next.event() function, which returns a character as a long value.",
    "arguments": [
      {
        "type": "long",
        "name": "charvalue",
        "description": ""
      }
    ],
    "returnValue": "2 charvalue is a multibyte character 1 charvalue is a non-zero single byte character 0 charvalue is zero or some other key (for example, a function key)",
    "category": "functions_multibyte_strings"
  },
  "mb.char.info": {
    "name": "mb.char.info",
    "type": "function",
    "syntax": "function long mb.char.info (string ch$)",
    "description": "This function identifies the character set to which a TSS Encoding character belongs. It returns the character set ID for the first character in the specified string.",
    "arguments": [
      {
        "type": "string",
        "name": "ch$",
        "description": ""
      }
    ],
    "returnValue": "The ID of the character set for the first character in the specified string. Or -1 if ch$ is an empty string or if the TSS character could not be found in one of the TSS character sets.",
    "category": "functions_multibyte_strings"
  },
  "mb.coerce.to.sb": {
    "name": "mb.coerce.to.sb",
    "type": "function",
    "syntax": "function long mb.coerce.to.sb (ref string string$ [, long setid])",
    "description": "This function converts a string from the TSS Encoding character set to the external, native character set, assuring that each resulting character is a single byte. By default, the setting of the current user locale (singlebyte or multibyte environment) or the installation locale (Unicode environment) determines the character set to which the string is converted. Code features in the string are skipped.",
    "arguments": [
      {
        "type": "ref string",
        "name": "string$",
        "description": ""
      },
      {
        "type": "[long",
        "name": "setid ]",
        "description": "If you do not want to base the conversion on the setting of the current user locale (singlebyte or multibyte environment) or the installation locale (Unicode environment), use this optional argument to specify the ID of the TSS character set to be used during the converversion."
      }
    ],
    "returnValue": ">=0 The number of bytes in the result string. -1 The conversion failed because some character could not be converted, or some converted character is not a single byte.",
    "category": "functions_multibyte_strings"
  },
  "mb.display": {
    "name": "mb.display",
    "type": "function",
    "syntax": "function long mb.display (string string_expr, ref string substr$, long space [, long flags])",
    "description": "This function returns that part of a specified string that fits in a specified display space. The substring is equal to the source string if the source string fits in the display space. If one or more characters do not fit in the display space, a ghost character (default is >) is appended to the substring.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": "The source string."
      },
      {
        "type": "ref string",
        "name": "substr$",
        "description": "The returned substring. This ends with a ghost character if some characters of the source string do not fit in the specified display space."
      },
      {
        "type": "long",
        "name": "space",
        "description": "The size of the display space for the substring."
      },
      {
        "type": "[long",
        "name": "flags ]",
        "description": "These optional flags specify certain criteria for handling the substring. They are particularly useful for working with bidirectional strings. TSS_REVERSE"
      }
    ],
    "returnValue": "An index to omitted characters if the string is truncated. Otherwise, the length of the string.",
    "category": "functions_multibyte_strings"
  },
  "mb.export$": {
    "name": "mb.export$",
    "type": "function",
    "syntax": "function long mb.export$ (ref string target$, string source$ [, long setid])",
    "description": "This function converts a string from the TSS Encoding character set to the external, native character set. By default, the setting of the current locale determines the character set to which the string is converted. Code features in the string are skipped.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The converted string. This can be a maximum of 4096 bytes."
      },
      {
        "type": "string",
        "name": "source$",
        "description": "The source string that must be converted."
      },
      {
        "type": "[long",
        "name": "setid ]",
        "description": "If you do not want to base the conversion on the setting of the current locale, use this optional argument to specify the ID of the TSS character set to be used in the export operation."
      }
    ],
    "returnValue": ">=0 The number of converted bytes. Note: This can be an indication of an overflow condition! If the supplied buffer is too small, the number of output bytes that fits in the supplied buffer is returned, with no clear indication of the overflow condition. This behaviour is retained for compatibility reasons. Make sure your output buffer is of sufficient size to hold the resulting string. -1 An incomplete character was found at the end of the string, or an illegal code sequence was detected. -3 Character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "mb.export.raw": {
    "name": "mb.export.raw",
    "type": "function",
    "syntax": "function long mb.export.raw (ref string target$, string source$ [, long setid])",
    "description": "This function converts a string from the TSS Encoding character set to the external, native character set. By default, the setting of the current locale determines the character set to which the string is converted. This function is almost identical to mb.export$(), but in contrast to that function, no special conversion is done for code features in source$.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The converted string. This can be a maximum of 4096 bytes."
      },
      {
        "type": "string",
        "name": "source$",
        "description": "The source string that must be converted."
      },
      {
        "type": "[long",
        "name": "setid ]",
        "description": "If you do not want to base the conversion on the setting of the current locale, use this optional argument to specify the ID of the TSS character set to be used in the export operation."
      }
    ],
    "returnValue": ">=0 The number of converted bytes. -1 The target string was too small to contain the converted string. -2 An incomplete character was found at the end of the string. -3 Character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "mb.hasbidi": {
    "name": "mb.hasbidi",
    "type": "function",
    "syntax": "function boolean mb.hasbidi (string string_expres)",
    "description": "Deprecated. This function is supported for backward compatibility reasons only. As of object TIV level 2200 (specified with the -T option of the compiler ) using this function will trigger a compilation error.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expres",
        "description": ""
      }
    ],
    "returnValue": "FALSE",
    "category": "functions_multibyte_strings"
  },
  "mb.import$": {
    "name": "mb.import$",
    "type": "function",
    "syntax": "function long mb.import$ (ref string target$, string source$ [, long setid])",
    "description": "This function converts a string from the external, native character set to the TSS Encoding character set. By default, the setting of the current locale determines the native character set from which the string is converted. Code features are restored.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The converted string. This can be a maximum of 4096 bytes."
      },
      {
        "type": "string",
        "name": "source$",
        "description": "The source string that must be converted."
      },
      {
        "type": "[long",
        "name": "setid ]",
        "description": "If you do not want to base the conversion on the setting of the current locale, use this optional argument to specify the ID of the TSS character set to be used in the import operation."
      }
    ],
    "returnValue": ">=0 The number of converted bytes. -1 The target string was too small to contain the converted string. -2 An incomplete character was found at the end of the string. -3 Character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "mb.import.raw": {
    "name": "mb.import.raw",
    "type": "function",
    "syntax": "function long mb.import.raw (ref string target$, string source$ [, long setid])",
    "description": "This function converts a string from the external, native character set to the TSS Encoding character set. By default, the setting of the current locale determines the native character set from which the string is converted. Unlike mb.import$(), no special conversion is done for Code Features.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The converted string. This can be a maximum of 4096 bytes."
      },
      {
        "type": "string",
        "name": "source$",
        "description": "The source string that must be converted."
      },
      {
        "type": "[long",
        "name": "setid ]",
        "description": "If you do not want to base the conversion on the setting of the current locale, use this optional argument to specify the ID of the TSS character set to be used in the import operation."
      }
    ],
    "returnValue": ">=0 The number of converted bytes. -1 The target string was too small to contain the converted string. -2 An incomplete character was found at the end of the string. -3 Character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "mb.isbidi": {
    "name": "mb.isbidi",
    "type": "function",
    "syntax": "function boolean mb.isbidi ()",
    "description": "This function checks whether the current environment is a bidirectional one.",
    "arguments": [],
    "returnValue": "TRUE current environment is bidirectional FALSE current environment is not bidirectional",
    "category": "functions_multibyte_strings"
  },
  "mb.isbidi.language": {
    "name": "mb.isbidi.language",
    "type": "function",
    "syntax": "function boolean mb.isbidi.language (string lang)",
    "description": "This function checks whether the specified language is a bidirectional one. To use the function, you must link to the ttdllbidi library. The function checks the flag � %TF@ttaad110.bidi� in the table �%TB@ttaad110�.",
    "arguments": [
      {
        "type": "string",
        "name": "lang",
        "description": ""
      }
    ],
    "returnValue": "TRUE current language is bidirectional FALSE current language is not bidirectional",
    "category": "functions_multibyte_strings"
  },
  "mb.locale.enumerate": {
    "name": "mb.locale.enumerate",
    "type": "function",
    "syntax": "function long mb.locale.enumerate (const string locale.name$)",
    "description": "This function returns information about one specific locale or about all locales.",
    "arguments": [
      {
        "type": "const string",
        "name": "locale.name$",
        "description": "Specifies the locale about which information is to be returned. If an empty string \"\" is supplied, information about all locales is returned."
      }
    ],
    "returnValue": "An XML tree containing the requested information. Like any other XML tree, the returned tree must be freed from memory by using xmlDelete . When the supplied argument locale.name$ refers to a not existing locale, e.g. \"abcdefg\", then the returned xml tree looks like this: <enumeration type=\"locales\" name=\"abcdefg\" /> When the supplied argument refers to an existing locale, e.g. \"ISO88591_WIN32\", then the returned xml tree looks like this: <enumeration type=\"locales\" name=\"ISO88591_WIN32\"> <locale name=\"ISO88591_WIN32\" nlsname=\"NULL\" tssname=\"CP1252\" tss_characterset_id=\"7\" internal_factor=\"1\" external_factor=\"1\" multibyte=\"false\" language_group=\"Latin1\" /> </enumeration> When the supplied argument locale.name$ is an empty string \"\", then the returned xml tree contains a <locale> node for each existing locale, and looks like this: <enumeration type=\"locales\"> <locale name=\"GB2312_WIN32\" nlsname=\"chs\" tssname=\"CP936\" tss_characterset_id=\"17\" internal_factor=\"2\" external_factor=\"2\" multibyte=\"true\" language_group=\"Simplified Chinese\" /> <locale name=\"ISO88591\" nlsname=\"NULL\" tssname=\"ISO88591\" tss_characterset_id=\"0\" internal_factor=\"1\" external_factor=\"1\" multibyte=\"false\" language_group=\"Latin1\" /> ... etcetera ... <locale name=\"ISO_BIN5\" nlsname=\"NULL\" tssname=\"ISO88595\" tss_characterset_id=\"23\" internal_factor=\"1\" external_factor=\"1\" multibyte=\"false\" language_group=\"Cyrillic\" /> </enumeration> The 'name' attribute corresponds to the locale name as returned by mb.localename$() . The five attribute names 'name', 'nlsname', 'tssname', '&#65533;nternal_factor', and 'external_factor' correspond to the five values 'TSS_GET_LOCALE_NAME', 'TSS_GET_NLS_NAME', 'TSS_GET_TSS_NAME', 'TSS_GET_IFACTOR', and 'TSS_GET_EFACTOR' of the flag supplied to the function mb.locale.info() . The attributes 'tss_characterset_id' and 'tssname' correspond to the first two arguments of mb.set.info() . The attribute 'tss_characterset_id' corresponds to the value returned by mb.char.info() and to the optional third argument of mb.import$() , mb.import.raw() , mb.export$() , and mb.export.raw() . The attribute 'multibyte' indicates if the locale has a multi byte native encoding. All locales that share a common character set have the same 'language_group' attribute.",
    "category": "functions_multibyte_strings"
  },
  "mb.locale.info": {
    "name": "mb.locale.info",
    "type": "function",
    "syntax": "function string mb.locale.info (long info_flag [, const string locale_name])",
    "description": "This function returns information about the current locale.",
    "arguments": [
      {
        "type": "long",
        "name": "info_flag",
        "description": "Specifies the required information. The possible values are: TSS_GET_TSS_CHARACTERSET_ID"
      }
    ],
    "returnValue": "A string containing the requested information. Where applicable, lval() can be used to convert the string to a long.",
    "category": "functions_multibyte_strings"
  },
  "mb.localename$": {
    "name": "mb.localename$",
    "type": "function",
    "syntax": "function string mb.localename$ ()",
    "description": "This function returns the name of the current locale as defined in the file '$bse/lib/user/u< user >'. The file �$BSE/lib/tss_locale x.x � (where x.x is the bshell version) contains all locales that the system supports.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_multibyte_strings"
  },
  "mb.long.to.str$": {
    "name": "mb.long.to.str$",
    "type": "function",
    "syntax": "function string mb.long.to.str$ (long charvalue)",
    "description": "This function converts a character code to the equivalent string value. It accepts single byte and multibyte character codes only. Do not use it for other character codes, such as function keys.",
    "arguments": [
      {
        "type": "long",
        "name": "charvalue",
        "description": ""
      }
    ],
    "returnValue": "string success empty string illegal character code (an error message is logged)",
    "category": "functions_multibyte_strings"
  },
  "mb.nsets": {
    "name": "mb.nsets",
    "type": "function",
    "syntax": "function long mb.nsets ()",
    "description": "This function returns the number of TSS character sets currently defined. This is useful for retrieving character set information using mb.set.info() .",
    "arguments": [],
    "returnValue": "",
    "category": "functions_multibyte_strings"
  },
  "mb.rev$": {
    "name": "mb.rev$",
    "type": "function",
    "syntax": "function string mb.rev$ (string string_expr [, long flags])",
    "description": "Deprecated. This function is supported for backward compatibility reasons only. As of object TIV level 2200 (specified with the -T option of the compiler ) using this function will trigger a compilation error.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": ""
      },
      {
        "type": "[long",
        "name": "flags ]",
        "description": "TSS_REVERSE TSS_FORCE_REVERSE"
      }
    ],
    "returnValue": "The supplied string_expr .",
    "category": "functions_multibyte_strings"
  },
  "mb.scrpos": {
    "name": "mb.scrpos",
    "type": "function",
    "syntax": "function long mb.scrpos (string string_expr, long pos)",
    "description": "This function converts a string position to a screen position. Code features are ignored.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": "The source string."
      },
      {
        "type": "long",
        "name": "pos",
        "description": "A position in the string."
      }
    ],
    "returnValue": "The screen position corresponding to the specified string position. Or -1 if pos lies beyond the end of the string.",
    "category": "functions_multibyte_strings"
  },
  "mb.set.info": {
    "name": "mb.set.info",
    "type": "function",
    "syntax": "function long mb.set.info (long setid, ref string name, string desc, ref long n_items)",
    "description": "This function returns information about a specified character set.",
    "arguments": [
      {
        "type": "long",
        "name": "setid",
        "description": "The character set ID."
      },
      {
        "type": "ref string",
        "name": "name",
        "description": "The name of the character set."
      },
      {
        "type": "string",
        "name": "desc",
        "description": "The description of the character set."
      },
      {
        "type": "ref long",
        "name": "n_items",
        "description": "The number of defined ranges in the character set. Currently, this value is always zero."
      }
    ],
    "returnValue": "0 success -1 the set ID is not linked to a known character set",
    "category": "functions_multibyte_strings"
  },
  "mb.strpos": {
    "name": "mb.strpos",
    "type": "function",
    "syntax": "function long mb.strpos (string string_expr, long pos)",
    "description": "This function converts a screen position to a string position. Code features are ignored.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": "The source string."
      },
      {
        "type": "long",
        "name": "pos",
        "description": "A screen position."
      }
    ],
    "returnValue": "The string position corresponding to the specified screen position. Or -1 if pos lies beyond the end of the string.",
    "category": "functions_multibyte_strings"
  },
  "mb.type": {
    "name": "mb.type",
    "type": "function",
    "syntax": "function long mb.type (string string_expres)",
    "description": "This function tests if a specified string is a multibyte string. It does not test the content of the string.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expres",
        "description": ""
      }
    ],
    "returnValue": "0 the string is not of type multibyte. 1 the string is of type multibyte.",
    "category": "functions_multibyte_strings"
  },
  "mb.width": {
    "name": "mb.width",
    "type": "function",
    "syntax": "function long mb.width (string string_expres)",
    "description": "This function returns the display width of a specified string; that is, the number of positions the string will occupy on the screen.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expres",
        "description": ""
      }
    ],
    "returnValue": "The display width of the specified string.",
    "category": "functions_multibyte_strings"
  },
  "multibyte strings overview and synopsis": {
    "name": "Multibyte strings overview and synopsis",
    "type": "function",
    "syntax": "function Multibyte strings overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_multibyte_strings"
  },
  "uni.export": {
    "name": "uni.export",
    "type": "function",
    "syntax": "function long uni.export (ref string target$, const string source$ [, long sb_flag])",
    "description": "This function converts a string from the TSS Encoding character set to Unicode , using a byte serialized UTF-16 encoding scheme. The default encoding scheme is UTF-16BE, i.e. each UTF-16 code unit is serialized with the most significant byte first.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The target string. This string will receive the byte serialized UTF-16. This can be a maximum of 4096 bytes."
      },
      {
        "type": "const string",
        "name": "source$",
        "description": "The source string. It is assumed to be in the default encoding: TSS."
      },
      {
        "type": "[long",
        "name": "sb_flag ]",
        "description": "This optional argument specifies the byte-order of the target string. Default is UNI_MSB_ORDER. UNI_DEF_ORDER"
      }
    ],
    "returnValue": ">= 0 the number of converted bytes -1 the target string was too small to contain the converted string -2 an incomplete character was found at the end of the string -3 character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "uni.import": {
    "name": "uni.import",
    "type": "function",
    "syntax": "function long uni.import (ref string target$, const string source$ [, long sb_flag])",
    "description": "This function converts a string from Unicode (encoded according to a byte serialized UTF-16 encoding scheme) to the TSS Encoding character set. The default encoding scheme is UTF-16BE, i.e. each UTF-16 code unit is assumed to be serialized with the most significant byte first.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The target string. This string will receive the TSS encoded characters. This can be a maximum of 4096 bytes."
      },
      {
        "type": "const string",
        "name": "source$",
        "description": "The source string. It is assumed to be in byte serialized UTF-16 encoding."
      },
      {
        "type": "[long",
        "name": "sb_flag ]",
        "description": "This optional argument specifies the byte-order of the source string. Default is UNI_MSB_ORDER. UNI_DEF_ORDER"
      }
    ],
    "returnValue": ">= 0 the number of converted bytes -1 the target string was too small to contain the converted string -2 an incomplete character was found at the end of the string -3 character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "utf8.export": {
    "name": "utf8.export",
    "type": "function",
    "syntax": "function long utf8.export (ref string target$, const string source$, long option_mask)",
    "description": "This function converts a string from the TSS Encoding character set to Unicode , using a UTF-8 Encoding encoding.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The target string. This string will receive the UTF-8. This can be a maximum of 4096 bytes."
      },
      {
        "type": "const string",
        "name": "source$",
        "description": "The source string. It is assumed to be in the default encoding: TSS."
      },
      {
        "type": "long",
        "name": "option_mask",
        "description": "This specifies the way the UTF-8 string is generated. UTF8_STD_MODE"
      }
    ],
    "returnValue": ">= 0 the number of converted bytes -1 the target string was too small to contain the converted string -2 an incomplete character was found at the end of the string -3 character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "utf8.import": {
    "name": "utf8.import",
    "type": "function",
    "syntax": "function long utf8.import (ref string target$, const string source$, long option_mask)",
    "description": "This function converts a string from Unicode (encoded according to a UTF-8 Encoding encoding) to the TSS Encoding character set.",
    "arguments": [
      {
        "type": "ref string",
        "name": "target$",
        "description": "The target string. This string will receive the TSS encoded characters. This can be a maximum of 4096 bytes."
      },
      {
        "type": "const string",
        "name": "source$",
        "description": "The source string. It is assumed to be in a UTF-8 encoding."
      },
      {
        "type": "long",
        "name": "option_mask",
        "description": "This specifies the format of the source string. UTF8_STD_MODE"
      }
    ],
    "returnValue": ">= 0 the number of converted bytes -1 the target string was too small to contain the converted string -2 an incomplete character was found at the end of the string -3 character could not be converted.",
    "category": "functions_multibyte_strings"
  },
  "get.tenant.id": {
    "name": "get.tenant.id",
    "type": "function",
    "syntax": "function string get.tenant.id ()",
    "description": "Returns the tenant id of the tenant under which the user is logged in. If the user is not logged in under a tenant then id \"infor\" is returned.",
    "arguments": [],
    "returnValue": "String containing tenant id The tenant id of the tenant under which the user is logged in infor The user is not logged in under a tenant",
    "category": "functions_multi_tenant"
  },
  "is.landlord.bse": {
    "name": "is.landlord.bse",
    "type": "function",
    "syntax": "function boolean is.landlord.bse ()",
    "description": "This function returns TRUE if the current BSE is a landlord BSE; FALSE otherwise.",
    "arguments": [],
    "returnValue": "TRUE The BSE is a landlord BSE. FALSE The BSE is not multi tenant enabled or is not a landlord BSE.",
    "category": "functions_multi_tenant"
  },
  "is.multi.tenant.enabled": {
    "name": "is.multi.tenant.enabled",
    "type": "function",
    "syntax": "function boolean is.multi.tenant.enabled ()",
    "description": "Returns TRUE if the current BSE is multi-tenant enabled; FALSE otherwise.",
    "arguments": [],
    "returnValue": "TRUE The BSE is multi tenant enabled. FALSE The BSE is not multi tenant enabled.",
    "category": "functions_multi_tenant"
  },
  "is.tenant.bse": {
    "name": "is.tenant.bse",
    "type": "function",
    "syntax": "function boolean is.tenant.bse ()",
    "description": "This function returns TRUE if the current BSE is a tenant BSE; FALSE otherwise.",
    "arguments": [],
    "returnValue": "TRUE The BSE is a tenant BSE. FALSE The BSE is not multi tenant enabled or is not a tenant BSE.",
    "category": "functions_multi_tenant"
  },
  "multi tenant functions overview": {
    "name": "Multi Tenant functions overview",
    "type": "function",
    "syntax": "function Multi Tenant functions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_multi_tenant"
  },
  "multi tenant functions synopsis": {
    "name": "Multi Tenant functions synopsis",
    "type": "function",
    "syntax": "function Multi Tenant functions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_multi_tenant"
  },
  "outbound publishing functions overview": {
    "name": "Outbound Publishing functions overview",
    "type": "function",
    "syntax": "function Outbound Publishing functions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_outbound_publishing"
  },
  "publish.check": {
    "name": "publish.check",
    "type": "function",
    "syntax": "function long publish.check (const string bus.component.name, ref long result.xml)",
    "description": "This function checks whether a destination (bus component) is available for publishing events. Note that publish.open() and publish.message() will not always report errors, but will send messages to an error handler or log file instead. To avoid publishing many message to the error handler or log file, this check function can be used before using publish.open().",
    "arguments": [
      {
        "type": "const string",
        "name": "bus.component.name",
        "description": "(input) Name of the bus component to be used."
      },
      {
        "type": "ref long",
        "name": "result.xml",
        "description": "(output): xml containing result in case of errors or warnings; see Outbound Publishing functions overview for details. The result.xml is available if return value <> 0."
      }
    ],
    "returnValue": "0 success. <>0 an error value (this only occurs if the functionality is unavailable in the current Adapter version)",
    "category": "functions_outbound_publishing"
  },
  "publish.close": {
    "name": "publish.close",
    "type": "function",
    "syntax": "function long publish.close (long publication.id, ref long result.xml)",
    "description": "This function closes a publication channel. After using this function, publish.message() and publish.error.message() cannot be used anymore unless a new publish.open() is done first.",
    "arguments": [
      {
        "type": "long",
        "name": "publication.id",
        "description": "(input) id for publication channel, which is provided as the return value of publish.open()"
      },
      {
        "type": "ref long",
        "name": "result.xml",
        "description": "(output): xml containing result in case of errors or warnings; see Outbound Publishing functions overview for details."
      }
    ],
    "returnValue": "0 success. <>0 an error value",
    "category": "functions_outbound_publishing"
  },
  "publish.error.message": {
    "name": "publish.error.message",
    "type": "function",
    "syntax": "function long publish.error.message (long publication.id, long error.xml, ref long result.xml)",
    "description": "This function reports an error instead of publishing a message. It can be used if a message could not be created or sent successfully. Note that the error message is not sent to the bus component as specified in publish.open(). Instead, the Adapter configuration specifies an error handler for the bus component and the error message is sent to that error handler. If the error handler cannot be found or is unavailable, the Adapter will take care that the error is logged.",
    "arguments": [
      {
        "type": "long",
        "name": "publication.id",
        "description": "(input) id for publication channel, which is provided as the return value of publish.open()"
      },
      {
        "type": "long",
        "name": "error.xml",
        "description": "(input) error message to be published, which is an xml structure according to the Result definition of the BDE standard.."
      },
      {
        "type": "ref long",
        "name": "result.xml",
        "description": "(output): xml containing errors or warnings; see Outbound Publishing functions overview for details. This only occurs if the functionality is unavailable in the current Adapter version; in all other cases the result.xml is empty."
      }
    ],
    "returnValue": "0 success. <>0 an error value (this only occurs if the functionality is unavailable in the current Adapter version)",
    "category": "functions_outbound_publishing"
  },
  "publish.message": {
    "name": "publish.message",
    "type": "function",
    "syntax": "function long publish.message (long publication.id, long message.xml, ref long result.xml)",
    "description": "This function publishes the specified message.",
    "arguments": [
      {
        "type": "long",
        "name": "publication.id",
        "description": "(input) id for publication channel, which is provided as the return value of publish.open()"
      },
      {
        "type": "long",
        "name": "message.xml",
        "description": "(input) message to be published, which is an xml structure."
      },
      {
        "type": "ref long",
        "name": "result.xml",
        "description": "(output): xml containing result in case of errors or warnings; see Outbound Publishing functions overview for details."
      }
    ],
    "returnValue": "0 success. <>0 an error value",
    "category": "functions_outbound_publishing"
  },
  "publish.open": {
    "name": "publish.open",
    "type": "function",
    "syntax": "function long publish.open (const string bus.component.name, ref long result.xml)",
    "description": "This function initializes the publishing.",
    "arguments": [
      {
        "type": "const string",
        "name": "bus.component.name",
        "description": "(input) Name of the bus component to be used."
      },
      {
        "type": "ref long",
        "name": "result.xml",
        "description": "(output): xml containing result in case of errors or warnings; see Outbound Publishing functions overview for details."
      }
    ],
    "returnValue": "0 Error. <>0 Publication id to be used subsequently in publish.message() , publish.error.message() and publish.close()",
    "category": "functions_outbound_publishing"
  },
  "outbound publishing functions synopsis": {
    "name": "Outbound Publishing functions synopsis",
    "type": "function",
    "syntax": "function Outbound Publishing functions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_outbound_publishing"
  },
  "parallel application processing configuration": {
    "name": "Parallel Application Processing Configuration",
    "type": "function",
    "syntax": "function Parallel Application Processing Configuration()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing cross reference": {
    "name": "Parallel Application Processing Cross Reference",
    "type": "function",
    "syntax": "function Parallel Application Processing Cross Reference()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing debugging": {
    "name": "Parallel Application Processing Debugging",
    "type": "function",
    "syntax": "function Parallel Application Processing Debugging()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing examples": {
    "name": "Parallel Application Processing Examples",
    "type": "function",
    "syntax": "function Parallel Application Processing Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing overview": {
    "name": "Parallel Application Processing Overview",
    "type": "function",
    "syntax": "function Parallel Application Processing Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "par.abort.client.server": {
    "name": "par.abort.client.server",
    "type": "function",
    "syntax": "function void par.abort.client.server (string error.message)",
    "description": "This function can be used in the client as well in the server. When there are (application) problems in the client or server, an abort message will be sent to the client and all servers. After this function call, all servers are stopped and all communication will be ended.",
    "arguments": [
      {
        "type": "string",
        "name": "error.message",
        "description": "This string contains the message which will be logged in the error log."
      }
    ],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "par.client.close.servers": {
    "name": "par.client.close.servers",
    "type": "function",
    "syntax": "function boolean par.client.close.servers (long group.id)",
    "description": "This function will close all servers in a group. Normally this call should only be done when all servers are ready, so after a call to par.client.wait.ready() . Closing the servers means that the application servers will terminate.",
    "arguments": [
      {
        "type": "long",
        "name": "group.id",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      }
    ],
    "returnValue": "true When successful false When an error occurred",
    "category": "functions_parallel_processing"
  },
  "par.client.get.message": {
    "name": "par.client.get.message",
    "type": "function",
    "syntax": "function long par.client.get.message (long group.id, ref string comm.string)",
    "description": "This function will check if a message has been sent by one of the servers in the indicated server group. A server process can sent a message back to the client with the function: par.server.send.message() . This function will not wait for any messages from a server process.",
    "arguments": [
      {
        "type": "long",
        "name": "group.id",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      },
      {
        "type": "ref string",
        "name": "comm.string",
        "description": "Output argument which will contain the message from a server when there is one available."
      }
    ],
    "returnValue": "0 When no message is received (so no message was sent by any server) >0 Server number from which this message is received.",
    "category": "functions_parallel_processing"
  },
  "par.client.get.status": {
    "name": "par.client.get.status",
    "type": "function",
    "syntax": "function long par.client.get.status (long group.id, long server.number, ref long messages)",
    "description": "Returns the current status of the specified server.",
    "arguments": [
      {
        "type": "long",
        "name": "group.id",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      },
      {
        "type": "long",
        "name": "server.number",
        "description": "The server number within this group, for which the status is requested. Server numbers start with number 1."
      },
      {
        "type": "ref long",
        "name": "messages",
        "description": "Output argument which contains the number of messages send by this server to the client which should be retrieved by calling par.client.get.message() ."
      }
    ],
    "returnValue": "This function returns the current state of this server, which can be one of the following STATE_SRV_CLOSED Initial state after par.init.client.to.server() was called STATE_SRV_LISTEN par.client.start.servers() called, waiting for connect from server STATE_SRV_KNOWN Server called: par.init.server.to.client() STATE_SRV_IDLE Server ready to accept a new message and waiting in par.server.get.message() STATE_SRV_PROCESSING Server busy processing a message. STATE_SRV_QUESTION Server waiting in function par.server.question() STATE_SRV_CLOSING par.client.close.servers() called, waiting for server to close STATE_SRV_ERROR Server in error state -1 Invalid group id or group already closed",
    "category": "functions_parallel_processing"
  },
  "par.client.running": {
    "name": "par.client.running",
    "type": "function",
    "syntax": "function boolean par.client.running ()",
    "description": "This function will return whether the current session is running in parallel processing client mode. It will be true when function par.init.client.to.server() was called successfully. This function can be useful in DLL�s.",
    "arguments": [],
    "returnValue": "true Session is running in parallel processing client mode false Session is not running a parallel processing client mode",
    "category": "functions_parallel_processing"
  },
  "par.client.send.message": {
    "name": "par.client.send.message",
    "type": "function",
    "syntax": "function boolean par.client.send.message (long group.id [, string comm.string] [, long server.number])",
    "description": "Send a message to the indicated group or application server. When a server.number is passed, the message is sent to that particular server. Otherwise the message is sent to the first server in the group which is ready. This function will wait until the message has been sent to a server. This does however not mean that the message is already processed by this server when this function returns.",
    "arguments": [
      {
        "type": "long",
        "name": "group.id",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      },
      {
        "type": "[string",
        "name": "comm.string ]",
        "description": "This string contains the message to be sent to the server. There is no maximum length for this string. The string must contain only textual data (so no binary data like a complete record buffer)."
      },
      {
        "type": "[long",
        "name": "server.number ]",
        "description": "Optional argument which can be used to sent a message to a specific server within a group. Server numbers start with number 1"
      }
    ],
    "returnValue": "true When message was sent successfully false When sending the message failed",
    "category": "functions_parallel_processing"
  },
  "par.client.start.servers": {
    "name": "par.client.start.servers",
    "type": "function",
    "syntax": "function boolean par.client.start.servers (long group.id [, long options])",
    "description": "This function is used to actually start the application servers (Bshells) for the indicated group.",
    "arguments": [
      {
        "type": "long",
        "name": "group.id",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "Optional argument which can be set to the values: CONTINUE_ON_SERVER_ERRORS and NO_REFS. These values can be combined for instance: CONTINUE_ON_SERVER_ERRORS+NO_REFS. When the option CONTINUE_ON_SERVER_ERRORS is not set (which is the default), processing will stop when one server aborts unexpectedly. When this option is set, processing will continue as long as there is one server available for processing messages. When the option NO_REFS is set, the server Bshells will not perform any database reference checking. Use this option with great care to prevent database corruption! This option requires a Bshell TIV level of at least 1752."
      }
    ],
    "returnValue": "true When all application servers started successfully false When one or more application servers could not be started",
    "category": "functions_parallel_processing"
  },
  "par.client.wait.ready": {
    "name": "par.client.wait.ready",
    "type": "function",
    "syntax": "function boolean par.client.wait.ready ( [long group.id] [, long server.number])",
    "description": "This function will wait until servers are ready with processing messages. When no group.id and no server.number are specified, this function will wait for all servers in all groups to become ready. When only a group.id is specified, this function will wait for all servers in the specified group to become ready. When both a group.id and a server.number is specified, this function will wait for one specific server to become ready.",
    "arguments": [
      {
        "type": "[long",
        "name": "group.id ]",
        "description": "ID which is returned by a previous call to par.init.client.to.server() ."
      },
      {
        "type": "[long",
        "name": "server.number ]",
        "description": "The server number within this group. Server numbers start with number 1."
      }
    ],
    "returnValue": "true When successful false When an error occurred",
    "category": "functions_parallel_processing"
  },
  "par.get.no.of.server": {
    "name": "par.get.no.of.server",
    "type": "function",
    "syntax": "function long par.get.no.of.server ()",
    "description": "This function will return the number of servers configured for this client session. See the section Parallel Application Processing Configuration .",
    "arguments": [],
    "returnValue": ">0 number of servers configured for this client session <=0 session not configured for parallel processing operation",
    "category": "functions_parallel_processing"
  },
  "par.init.client.to.server": {
    "name": "par.init.client.to.server",
    "type": "function",
    "syntax": "function long par.init.client.to.server (long nr.of.servers, string server.session [, string support.session])",
    "description": "This function is used to initialize the client to server communication for one group. Starting the application servers (Bshells) will be done when the function par.client.start.servers() is called.",
    "arguments": [
      {
        "type": "long",
        "name": "nr.of.servers",
        "description": "Specifies the number of servers to be started within this group. If this argument is <= 0, the configured number of servers will be used."
      },
      {
        "type": "string",
        "name": "server.session",
        "description": "Specifies the server session to be started for this group."
      },
      {
        "type": "[string",
        "name": "support.session ]",
        "description": "Optional argument in which a session name can be passed which is responsible for handling questions from server sessions (see par.server.question() )."
      }
    ],
    "returnValue": ">0 The id of the server group <0 When parallel processing is not configured for the current session and nr.of.servers is <= 0",
    "category": "functions_parallel_processing"
  },
  "par.init.server.to.client": {
    "name": "par.init.server.to.client",
    "type": "function",
    "syntax": "function boolean par.init.server.to.client (ref long group.number, ref long server.number [, ref long tot.nr.servers])",
    "description": "This function is used to initialize the communication to the client. This function must be called rather in the beginning of a program which can be started as server. This because of the fact that the client function has a time out time (default 2 minutes) on starting each server (receiving the 'known' command).",
    "arguments": [
      {
        "type": "ref long",
        "name": "group.number",
        "description": "Output argument which will be set to the current group number of which this server will be a member."
      },
      {
        "type": "ref long",
        "name": "server.number",
        "description": "Output argument which will be set to the current server number assigned to this server."
      },
      {
        "type": "[ref long",
        "name": "tot.nr.servers ]",
        "description": "Output argument which will be set to the total number of servers in this group."
      }
    ],
    "returnValue": "true When this session is running in parallel processing server mode. false When this session is not running in parallel processing server mode.",
    "category": "functions_parallel_processing"
  },
  "par.server.get.message": {
    "name": "par.server.get.message",
    "type": "function",
    "syntax": "function long par.server.get.message (ref string comm.string)",
    "description": "This function will inform the client that this server is ready and wait for a new message from the client.",
    "arguments": [
      {
        "type": "ref string",
        "name": "comm.string",
        "description": "Output argument which will contain the received message when there is one available."
      }
    ],
    "returnValue": "1 a message is available in comm.string 0 an error occurred -1 the client called the function par.client.close.servers() to indicate that all servers should end processing and exit.",
    "category": "functions_parallel_processing"
  },
  "par.server.id": {
    "name": "par.server.id",
    "type": "function",
    "syntax": "function long par.server.id ()",
    "description": "This function will return the identification of a server within its group. This function can be useful in includes or DLL�s to determine if the session is running in the context of parallel processing.",
    "arguments": [],
    "returnValue": ">0 The server number when the session is running in a parallel processing context 0 Session is not running a parallel processing context",
    "category": "functions_parallel_processing"
  },
  "par.server.question": {
    "name": "par.server.question",
    "type": "function",
    "syntax": "function boolean par.server.question (string question, ref string answer)",
    "description": "This function can be used by a server session to send a question message to the \"support\" session in the client. The \"support\" session in the client must use function par.support.get.question() to receive questions from server processes and function par.support.send.answer() to sent an answer message to the server. The function par.server.question() waits until an answer message is received from the \"support\" session.",
    "arguments": [
      {
        "type": "string",
        "name": "question",
        "description": "This string contains the message (question) to be sent to the support session. There is no maximum length for this string"
      },
      {
        "type": "ref string",
        "name": "answer",
        "description": "Output argument which will contain the answer returned by the support session"
      }
    ],
    "returnValue": "true when an answer is returned by the support session false when an error occurred",
    "category": "functions_parallel_processing"
  },
  "par.server.retry.hit": {
    "name": "par.server.retry.hit",
    "type": "function",
    "syntax": "function void par.server.retry.hit ()",
    "description": "This function must be called in a server after a real db.retry.hit() call. When this function is called x times and x = MAX.RETRY-1, this function will do an abort of the client server communication with the abort message \"Too many retry hits in server\". See section: Parallel Application Processing Database Retries for a further explanation.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "par.server.retry.point": {
    "name": "par.server.retry.point",
    "type": "function",
    "syntax": "function void par.server.retry.point ()",
    "description": "This function is used for setting a not real retry point after a db.retry.point (). It must be used together with function par.server.retry.hit() . See section: Parallel Application Processing Database Retries for a further explanation.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "par.server.running": {
    "name": "par.server.running",
    "type": "function",
    "syntax": "function boolean par.server.running ()",
    "description": "This function will return whether the current session is running in parallel processing server mode. It will be true when function par.init.server.to.client() was called successfully. This function can be useful in DLL�s.",
    "arguments": [],
    "returnValue": "true Session is running in parallel processing server mode false Session is not running a parallel processing server mode",
    "category": "functions_parallel_processing"
  },
  "par.server.send.message": {
    "name": "par.server.send.message",
    "type": "function",
    "syntax": "function boolean par.server.send.message (string comm.string)",
    "description": "Send a message to the client. This function will return as soon as the message has been sent.",
    "arguments": [
      {
        "type": "string",
        "name": "comm.string",
        "description": "This string contains the message to be sent to the client. There is no maximum length for this string. The string must contain only textual data (so no binary data like a complete record buffer)."
      }
    ],
    "returnValue": "true when message was sent successfully false when sending the message failed",
    "category": "functions_parallel_processing"
  },
  "par.support.get.question": {
    "name": "par.support.get.question",
    "type": "function",
    "syntax": "function long par.support.get.question (ref string question)",
    "description": "This function will wait for a question message from any server. When this function returns -1, the support session must end processing and exit.",
    "arguments": [
      {
        "type": "ref string",
        "name": "question",
        "description": "Output argument which will contain the question message from a server when there is one available."
      }
    ],
    "returnValue": ">0 The server number which has sent the question string -1 The client called the function par.client.close.servers() to indicate that all servers (and support sessions) should end processing and exit.",
    "category": "functions_parallel_processing"
  },
  "par.support.init": {
    "name": "par.support.init",
    "type": "function",
    "syntax": "function boolean par.support.init (ref long group.number, ref long tot.nr.servers)",
    "description": "This function is used to initialize the communication for a support session. This function must be called at the start of a session which can be used as a parallel processing support session.",
    "arguments": [
      {
        "type": "ref long",
        "name": "group.number",
        "description": "Output argument which will be set to the current group number of which this support session will be a member."
      },
      {
        "type": "ref long",
        "name": "tot.nr.servers",
        "description": "Output argument which will be set to the total number of servers in this group."
      }
    ],
    "returnValue": "true When this session is running in parallel processing support session mode. false When this session is not running in parallel processing support session mode.",
    "category": "functions_parallel_processing"
  },
  "par.support.running": {
    "name": "par.support.running",
    "type": "function",
    "syntax": "function boolean par.support.running ()",
    "description": "This function will return whether the current session is running in parallel processing support session mode. It will be true when function par.support.init() was called successfully. This function can be useful in DLL�s.",
    "arguments": [],
    "returnValue": "true Session is running in parallel processing support session mode false Session is not running a parallel processing support session mode",
    "category": "functions_parallel_processing"
  },
  "par.support.send.answer": {
    "name": "par.support.send.answer",
    "type": "function",
    "syntax": "function boolean par.support.send.answer (string answer, long server.number)",
    "description": "Send an answer message to a server session. This function will return as soon as the message has been sent.",
    "arguments": [
      {
        "type": "string",
        "name": "answer",
        "description": "This string contains the answer message to be sent to the server session. There is no maximum length for this string."
      },
      {
        "type": "long",
        "name": "server.number",
        "description": "Indicates the server to which this answer must be sent. This must be the return value of a previous call to par.support.get.question() ."
      }
    ],
    "returnValue": "true when message was sent successfully false when sending the message failed",
    "category": "functions_parallel_processing"
  },
  "parallel application processing database retries": {
    "name": "Parallel Application Processing Database Retries",
    "type": "function",
    "syntax": "function Parallel Application Processing Database Retries()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "sequence diagrams": {
    "name": "Sequence Diagrams",
    "type": "function",
    "syntax": "function Sequence Diagrams()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing synopsis": {
    "name": "Parallel Application Processing synopsis",
    "type": "function",
    "syntax": "function Parallel Application Processing synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "parallel application processing tracing": {
    "name": "Parallel Application Processing Tracing",
    "type": "function",
    "syntax": "function Parallel Application Processing Tracing()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_parallel_processing"
  },
  "pcm_ot_activity � activity object": {
    "name": "PCM_OT_ACTIVITY � activity object",
    "type": "function",
    "syntax": "function PCM_OT_ACTIVITY � activity object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_button � button object": {
    "name": "PCM_OT_BUTTON � button object",
    "type": "function",
    "syntax": "function PCM_OT_BUTTON � button object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_column � column object": {
    "name": "PCM_OT_COLUMN � column object",
    "type": "function",
    "syntax": "function PCM_OT_COLUMN � column object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_delay � delay time object": {
    "name": "PCM_OT_DELAY � delay time object",
    "type": "function",
    "syntax": "function PCM_OT_DELAY � delay time object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "plan chart manager: example": {
    "name": "Plan Chart Manager: example",
    "type": "function",
    "syntax": "function Plan Chart Manager: example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_marker � marker object": {
    "name": "PCM_OT_MARKER � marker object",
    "type": "function",
    "syntax": "function PCM_OT_MARKER � marker object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_menu - menu object": {
    "name": "PCM_OT_MENU - menu object",
    "type": "function",
    "syntax": "function PCM_OT_MENU - menu object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "plan chart manager overview": {
    "name": "Plan Chart Manager overview",
    "type": "function",
    "syntax": "function Plan Chart Manager overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.activate.session": {
    "name": "pcm.activate.session",
    "type": "function",
    "syntax": "function long pcm.activate.session (ref string session, string title)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref string",
        "name": "session",
        "description": "The session code."
      },
      {
        "type": "string",
        "name": "title",
        "description": "The title for the session window."
      }
    ],
    "returnValue": "The function returns the process ID of the activated session.",
    "category": "functions_plan_chart_manager"
  },
  "pcm.change": {
    "name": "pcm.change",
    "type": "function",
    "syntax": "function void pcm.change (long plan_id, ..., long flag, long value)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id, ...",
        "description": "The ID of the chart whose attributes you want to change, as returned by pcm.create() ."
      },
      {
        "type": "long",
        "name": "flag",
        "description": "Use these arguments to set new values for the chart attributes. For each attribute you specify, you must include the attribute type (for example, PcmPlanName or PcmPlanBackgroundColor), and the attribute value. For a list of the plan attributes, see pcm.create() ."
      },
      {
        "type": "long",
        "name": "value",
        "description": "Use these arguments to set new values for the chart attributes. For each attribute you specify, you must include the attribute type (for example, PcmPlanName or PcmPlanBackgroundColor), and the attribute value. For a list of the plan attributes, see pcm.create() ."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.change.object": {
    "name": "pcm.change.object",
    "type": "function",
    "syntax": "function void pcm.change.object (long plan_id, long object_id [, long flag] [, long value,])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": "The ID of the chart to which the object belongs, as returned by pcm.create() ."
      },
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object, as returned by pcm.create.object() ."
      },
      {
        "type": "[long",
        "name": "flag ]",
        "description": "Use these arguments to set new values for the object's attributes. For each attribute you specify, you must include the attribute type (for example, PcmMenuName or PcmTimescaleVisible), and the attribute value. For a list of the object attributes, see pcm.create.object() ."
      },
      {
        "type": "[long",
        "name": "value, ]",
        "description": "Use these arguments to set new values for the object's attributes. For each attribute you specify, you must include the attribute type (for example, PcmMenuName or PcmTimescaleVisible), and the attribute value. For a list of the object attributes, see pcm.create.object() ."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.create": {
    "name": "pcm.create",
    "type": "function",
    "syntax": "function long pcm.create ( [long flag] [, long value,...])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "[long",
        "name": "flag ]",
        "description": "Use this optional argument to specify the read mode for seq.gets(). Possible values are: PcmPlanName(50) (string) The title of the chart."
      }
    ],
    "returnValue": "The function returns a unique ID for the new chart.",
    "category": "functions_plan_chart_manager"
  },
  "pcm.create.object": {
    "name": "pcm.create.object",
    "type": "function",
    "syntax": "function long pcm.create.object (long plan_id, long object_type [, long flag] [, long value] [, long flag, value])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": "The ID of the plan to which you want to add the new object."
      },
      {
        "type": "long",
        "name": "object_type",
        "description": "The object type. The possible values are: PCM_OT_MENU - menu object a menu item PCM_OT_BUTTON � button object a button to which you can link sessions or options PCM_OT_TIMESCALE � time scale object a time scale PCM_OT_DELAY � delay time object delay time (that is, non workdays) PCM_OT_COLUMN � column object a column containing an activity description PCM_OT_ACTIVITY � activity object an activity PCM_OT_RELATION � relation object a relation PCM_OT_MARKER � marker object an activity marker"
      },
      {
        "type": "[long",
        "name": "flag ]",
        "description": "Use these arguments to define the object's attributes. For each attribute you specify, you must include the attribute type (for example, PcmMenuName or PcmTimescaleVisible), and the attribute value. The attributes of each object are listed in the section describing that object."
      },
      {
        "type": "[long",
        "name": "value ]",
        "description": "Use these arguments to define the object's attributes. For each attribute you specify, you must include the attribute type (for example, PcmMenuName or PcmTimescaleVisible), and the attribute value. The attributes of each object are listed in the section describing that object."
      },
      {
        "type": "[long",
        "name": "flag, value ]",
        "description": "Use these arguments to define the object's attributes. For each attribute you specify, you must include the attribute type (for example, PcmMenuName or PcmTimescaleVisible), and the attribute value. The attributes of each object are listed in the section describing that object."
      }
    ],
    "returnValue": "The function returns a unique ID for the new object.",
    "category": "functions_plan_chart_manager"
  },
  "pcm.destroy": {
    "name": "pcm.destroy",
    "type": "function",
    "syntax": "function void pcm.destroy (long plan_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.destroy.object": {
    "name": "pcm.destroy.object",
    "type": "function",
    "syntax": "function void pcm.destroy.object (long plan_id, long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": "The ID of the chart to which the object belongs, as returned by pcm.create() ."
      },
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object, as returned by pcm.create.object() ."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.get.data": {
    "name": "pcm.get.data",
    "type": "function",
    "syntax": "function void pcm.get.data (long evt_type, ref string arglist,...)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "evt_type",
        "description": "This specifies the type of the event you want to read."
      },
      {
        "type": "ref string",
        "name": "arglist,...",
        "description": "This returns the argument list."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.lock": {
    "name": "pcm.lock",
    "type": "function",
    "syntax": "function void pcm.lock (long plan_id, long lock)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": "The ID of the planning chart that you want to lock."
      },
      {
        "type": "long",
        "name": "lock",
        "description": "This indicates whether the planning chart must be locked or unlocked. The possible values are: true The planning board is locked. The user cannot interact with it until it is unlocked again. false The planning board is unlocked. This is the default value."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.refresh": {
    "name": "pcm.refresh",
    "type": "function",
    "syntax": "function void pcm.refresh (long plan_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "plan_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm.send.bms.event": {
    "name": "pcm.send.bms.event",
    "type": "function",
    "syntax": "function void pcm.send.bms.event (long command, ref string arglist)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "command",
        "description": "The command to be sent back to the application. The Chart Manager places this in the variable"
      },
      {
        "type": "ref string",
        "name": "arglist",
        "description": "The argument list. The application can retrieve this string by calling bms.receive$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_relation � relation object": {
    "name": "PCM_OT_RELATION � relation object",
    "type": "function",
    "syntax": "function PCM_OT_RELATION � relation object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "plan chart manager synopsis": {
    "name": "Plan Chart Manager synopsis",
    "type": "function",
    "syntax": "function Plan Chart Manager synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "pcm_ot_timescale � time scale object": {
    "name": "PCM_OT_TIMESCALE � time scale object",
    "type": "function",
    "syntax": "function PCM_OT_TIMESCALE � time scale object()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_plan_chart_manager"
  },
  "process change manager code examples": {
    "name": "Process Change Manager Code Examples",
    "type": "function",
    "syntax": "function Process Change Manager Code Examples()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "process change manager overview": {
    "name": "Process Change Manager overview",
    "type": "function",
    "syntax": "function Process Change Manager overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "prcm.bms.is.notification": {
    "name": "prcm.bms.is.notification",
    "type": "function",
    "syntax": "function boolean prcm.bms.is.notification ( [long bms.command])",
    "description": "Tests whether the specified bms command is a notification of a subject. If no bms command is passed to this function, the predefined 4GL variable bms.sender.command is checked.",
    "arguments": [
      {
        "type": "[long",
        "name": "bms.command ]",
        "description": "Optional bms command that must be checked to see whether it represents a notification of a subject. If not specified the predefined bms.sender.command variable is checked"
      }
    ],
    "returnValue": "This function returns TRUE if the tested bms command represents a PRCM notification. Otherwise FALSE is returned.",
    "category": "functions_prcm"
  },
  "prcm.get.aspect": {
    "name": "prcm.get.aspect",
    "type": "function",
    "syntax": "function observer processes can call prcm.get.aspect ()",
    "description": "Returns the last decoded aspect of the subject that did a notification.",
    "arguments": [],
    "returnValue": "The last decoded aspect as string.",
    "category": "functions_prcm"
  },
  "prcm.get.data": {
    "name": "prcm.get.data",
    "type": "function",
    "syntax": "function long prcm.get.data ()",
    "description": "Returns the last data passed by the subject that did a notification.",
    "arguments": [],
    "returnValue": "<>0 The id of the passed data 0 When no data was passed with the last PRCM notification",
    "category": "functions_prcm"
  },
  "prcm.get.subject": {
    "name": "prcm.get.subject",
    "type": "function",
    "syntax": "function string prcm.get.subject ()",
    "description": "Returns the last decoded subject that did a notification.",
    "arguments": [],
    "returnValue": "The last decoded subject as string.",
    "category": "functions_prcm"
  },
  "prcm.notify": {
    "name": "prcm.notify",
    "type": "function",
    "syntax": "function void prcm.notify (const string subject [, string aspect(32)] [, long data])",
    "description": "Is called by a subject process to notify other processes that it has changed. Optionally, an aspect can be specified to indicate what aspect of the subject process has changed.",
    "arguments": [
      {
        "type": "const string",
        "name": "subject",
        "description": "The subject that has changed. This can be freely defined."
      },
      {
        "type": "[string",
        "name": "aspect(32) ]",
        "description": "Optional aspect of the subject that has changed. This can be freely defined."
      },
      {
        "type": "[long",
        "name": "data ]",
        "description": "Optional xml node containing data that observers might be interested in. The contents of the XML document can be freely defined. From Tools Interface Version (TIV) 2000, the XML structure is duplicated to the PRCM process. In older versions, only a reference to the XML is sent to the other processes."
      }
    ],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "prcm.register": {
    "name": "prcm.register",
    "type": "function",
    "syntax": "function void prcm.register (const string subject [, string aspect(32)])",
    "description": "Is called by an Observer process (i.e. the current process) to register/subscribe itself for a certain Subject (and optionally Aspect). Afterwards, if the subject notifies its observers, this process will be notified by the Process Change Manager.",
    "arguments": [
      {
        "type": "const string",
        "name": "subject",
        "description": "The subject in which the current process is interested."
      },
      {
        "type": "[string",
        "name": "aspect(32) ]",
        "description": "Optional aspect in which the current process is interested."
      }
    ],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "prcm.unregister": {
    "name": "prcm.unregister",
    "type": "function",
    "syntax": "function void prcm.unregister (const string subject [, string aspect(32)])",
    "description": "Is called by an Observer process (i.e. the current process) to unregister/unsubscribe itself for a certain Subject (and optionally Aspect). Afterwards, this process will no longer be notified by the Process Change Manager if the subject tries to notify its observers.",
    "arguments": [
      {
        "type": "const string",
        "name": "subject",
        "description": "The subject in which the current process is interested."
      },
      {
        "type": "[string",
        "name": "aspect(32) ]",
        "description": "Optional aspect in which the current process is interested."
      }
    ],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "process change manager synopsis": {
    "name": "Process Change Manager synopsis",
    "type": "function",
    "syntax": "function Process Change Manager synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_prcm"
  },
  "act.and.sleep": {
    "name": "act.and.sleep",
    "type": "function",
    "syntax": "function long act.and.sleep (string procname(.) [, string arg1, arg2, ...])",
    "description": "This activates the specified process and places it in the sleeping process queue. It remains there until it is activated by calling the reactivate() function. You can remove the process with the kill() function. The process is automatically removed when the process group to which it belongs is killed.",
    "arguments": [
      {
        "type": "string",
        "name": "procname(.)",
        "description": "The process to be activated. The argument can contain a session name (4GL programs) or the name of an object file (3GL programs)."
      },
      {
        "type": "[string",
        "name": "arg1, arg2, ... ]",
        "description": "Use these optional arguments to pass arguments to the new process. The arguments are always converted to strings. The new process can access these arguments with the argv$() function."
      }
    ],
    "returnValue": "return_value = 0 Error, process cannot be activated. 0 < return_value &#8804; 2^31 - 1 Process ID of activated process. This is a value in the positive part of the signed 32-bit range: [1 � 2^31 - 1] (i.e. [1 � 2,147,483,647]).",
    "category": "functions_processes"
  },
  "activate": {
    "name": "activate",
    "type": "function",
    "syntax": "function long activate (string procname(.) [, string arg1, arg2, ...])",
    "description": "This activates the specified process and places it in the running process queue. Execution starts when the bshell schedules CPU time for the process.",
    "arguments": [
      {
        "type": "string",
        "name": "procname(.)",
        "description": "The process to be activated. The argument can contain a session name (4GL programs) or the name of an object file (3GL programs)."
      },
      {
        "type": "[string",
        "name": "arg1, arg2, ... ]",
        "description": "Use these optional arguments to pass arguments to the new process. The arguments are always converted to strings. The new process can access these arguments with the argv$() function."
      }
    ],
    "returnValue": "return_value = 0 Error, process cannot be activated. 0 < return_value &#8804; 2^31 - 1 Process ID of activated process. This is a value in the positive part of the signed 32-bit range: [1 � 2^31 - 1] (i.e. [1 � 2,147,483,647]).",
    "category": "functions_processes"
  },
  "argc": {
    "name": "argc",
    "type": "function",
    "syntax": "function long argc ()",
    "description": "This returns the number of arguments of the current program. You can pass arguments to the program by activating it with the activate() , act.and.sleep() , or wait.and.activate() functions.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_processes"
  },
  "argv$": {
    "name": "argv$",
    "type": "function",
    "syntax": "function string argv$ (long num_expr)",
    "description": "This returns the specified argument of the program as a string. The program name is stored in ARGV$(0). The last argument is stored in ARGV$( ARGC()-1 ).",
    "arguments": [
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "The specified argument as a string. Or an empty string (��) if the argument does not exist.",
    "category": "functions_processes"
  },
  "bshell.pid": {
    "name": "bshell.pid",
    "type": "function",
    "syntax": "function long bshell.pid ()",
    "description": "This returns the process ID of the current bshell (at operating system level).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_processes"
  },
  "kill": {
    "name": "kill",
    "type": "function",
    "syntax": "function void kill (long processno)",
    "description": "This deletes the specified process from the bshell process queue. If the process is in a running state, it is interrupted.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_processes"
  },
  "processes overview and synopsis": {
    "name": "Processes overview and synopsis",
    "type": "function",
    "syntax": "function Processes overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_processes"
  },
  "pstat": {
    "name": "pstat",
    "type": "function",
    "syntax": "function long pstat (long pid, ref string progname, ref long info(PSMAXSIZE))",
    "description": "This returns status information about a specified process.",
    "arguments": [
      {
        "type": "long",
        "name": "pid",
        "description": "The ID of the process for which you want to retrieve information. Specify a negative value here to retrieve information about the init process."
      },
      {
        "type": "ref string",
        "name": "progname",
        "description": "This returns the process code."
      },
      {
        "type": "ref long",
        "name": "info(PSMAXSIZE)",
        "description": "This returns status information that you can retrieve with the following macros, each of which returns a long: ps.state(info) returns PSRUNNING, PSBLOCKING, PSSLEEPING, or PSTERMINATING. ps.group(info) returns the identifier of the process group to which the process belongs. ps.parent(info) returns the identifier of the parent process of the process group. ps.flags(info) returns flags. ps.nice(info) returns the nice value of the process. ps.cpu.use(info) returns the number of ticks used by the process. ps.mwin(info) returns the object id of the main window of the process. ps.pri(info) returns the priority of the process. ps.size(info) returns the amount of memory allocated by the process (in bytes). ps.cwin(info) returns the object id of the current window of the process. ps.menu(info) returns the object id of the menubar of the current window of the process. ps.bar(info) returns the object id of the toolbar of the current window of the process."
      }
    ],
    "returnValue": "< 0 Could not retrieve info: process does not exist. >= 0 The process ID of the next process in the internal process list, or 0 if this is the last process in that list.",
    "category": "functions_processes"
  },
  "reactivate": {
    "name": "reactivate",
    "type": "function",
    "syntax": "function void reactivate (long processno)",
    "description": "This activates the specified sleeping process.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_processes"
  },
  "signal": {
    "name": "signal",
    "type": "function",
    "syntax": "function void signal (long type, long action)",
    "description": "This specifies whether the process in which it is called ignores child process signals or not.",
    "arguments": [
      {
        "type": "long",
        "name": "type",
        "description": "The signal type. Currently there is only one value for this argument: SIGCHLD Sent by a child process to its parent process when the child process exits."
      },
      {
        "type": "long",
        "name": "action",
        "description": "SIGIGN Ignore signals. The child exits without any action by the parent. The child exits, sends an exit signal to its parent, and is removed. This is the default action. SIGNOIGN Do not ignore signals. The child exits and waits until its parent catches its exit signal. The parent catches the signal with the wait() function. While the child process is waiting, it is a zombie process."
      }
    ],
    "returnValue": "",
    "category": "functions_processes"
  },
  "sleep": {
    "name": "sleep",
    "type": "function",
    "syntax": "function void sleep (long processno)",
    "description": "This suspends execution of the specified process and places it in the sleeping process queue. To suspend execution of the your own process, specify the predefined variable pid in the argument.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_processes"
  },
  "suspend": {
    "name": "suspend",
    "type": "function",
    "syntax": "function void suspend (long msec)",
    "description": "This stops execution of the current process for a specified number of milliseconds. You can specify any number of milliseconds in the range 0 to 2147483647 (the maximum value for a long).",
    "arguments": [
      {
        "type": "long",
        "name": "msec",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_processes"
  },
  "wait.and.activate": {
    "name": "wait.and.activate",
    "type": "function",
    "syntax": "function long wait.and.activate (string procname(.) [, long arg1, arg2, ...])",
    "description": "This activates the specified program. The calling program is put in a waiting state. Because the calling program has not ended, it retains all its values.",
    "arguments": [
      {
        "type": "string",
        "name": "procname(.)",
        "description": "The process to be activated. The argument can contain a session name (4GL programs) or the name of an object file (3GL programs)."
      },
      {
        "type": "[long",
        "name": "arg1, arg2, ... ]",
        "description": "Use these optional arguments to pass arguments to the new process. The arguments are always converted to strings. The new process can access these arguments with the argv$() function."
      }
    ],
    "returnValue": "return_value = 0 Error, process cannot be activated. 0 < return_value &#8804; 2^31 - 1 Process ID of activated process. This is a value in the positive part of the signed 32-bit range: [1 � 2^31 - 1] (i.e. [1 � 2,147,483,647]).",
    "category": "functions_processes"
  },
  "wait": {
    "name": "wait",
    "type": "function",
    "syntax": "function string wait (ref long process_id, long option)",
    "description": "This waits for one or all child processes to exit.",
    "arguments": [
      {
        "type": "ref long",
        "name": "process_id",
        "description": "This returns the process number of the child process that exited. If no child exited, it returns 0. If there are no child processes, or if all child processes were already ended before the function was called, it returns -1."
      },
      {
        "type": "long",
        "name": "option",
        "description": "This can have one of the following values: WTHANG If the parent process ignores child signals (see signal() ), the function waits until all children have exited. The process_id argument returns the process ID of the last child process to exit. If the parent process does not ignore child signals (see signal() ), the function waits until one child exits. The process_id argument returns the process ID of that child process. WTNOHANG If the parent process ignores child signals (see signal() ), the function does not block. If one or more child processes have previously exited and are in a zombie state, the process_id argument returns the process of the last child process that exited. If the parent process does not ignore child signals (see signal() ), the function waits until one child exits. The process_id argument returns the process ID of that child process."
      }
    ],
    "returnValue": "The exit value of the child process identified by the process_id argument.",
    "category": "functions_processes"
  },
  "get.pgrp": {
    "name": "get.pgrp",
    "type": "function",
    "syntax": "function long get.pgrp (long process_id)",
    "description": "This returns the identification number of the process group to which the specified process belongs. If you specify an unknown process ID, -1 is returned.",
    "arguments": [
      {
        "type": "long",
        "name": "process_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_process_groups"
  },
  "grab.mwindow": {
    "name": "grab.mwindow",
    "type": "function",
    "syntax": "function void grab.mwindow (long mwindow, long process_group)",
    "description": "This specifies the process group to which a particular main window must send its events. After calling this function, all events that occur in the main window are sent to the process group. grab.mwindow() is mainly used immediately after creation of a new process group.",
    "arguments": [
      {
        "type": "long",
        "name": "mwindow",
        "description": "The ID of the main window."
      },
      {
        "type": "long",
        "name": "process_group",
        "description": "The ID of the process group."
      }
    ],
    "returnValue": "",
    "category": "functions_process_groups"
  },
  "kill.pgrp": {
    "name": "kill.pgrp",
    "type": "function",
    "syntax": "function void kill.pgrp (long process_id)",
    "description": "This ends all processes within the specified process group. All windows and graphical parts of the processes are removed.",
    "arguments": [
      {
        "type": "long",
        "name": "process_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_process_groups"
  },
  "process groups overview": {
    "name": "Process groups overview",
    "type": "function",
    "syntax": "function Process groups overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_process_groups"
  },
  "set.pgrp": {
    "name": "set.pgrp",
    "type": "function",
    "syntax": "function long set.pgrp (long process_id, long group_id)",
    "description": "This places a specified process in a specified process group. If the process group ID is the same as the process ID, a new process group is created with the specified ID. The specified process becomes the leader of the new group.",
    "arguments": [
      {
        "type": "long",
        "name": "process_id",
        "description": ""
      },
      {
        "type": "long",
        "name": "group_id",
        "description": ""
      }
    ],
    "returnValue": "The function returns the ID of the process group.",
    "category": "functions_process_groups"
  },
  "process groups synopsis": {
    "name": "Process groups synopsis",
    "type": "function",
    "syntax": "function Process groups synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_process_groups"
  },
  "chart.add.data.point": {
    "name": "chart.add.data.point",
    "type": "function",
    "syntax": "function long chart.add.data.point (long series, (long|string|double) x, (long|double) y)",
    "description": "Add a datapoint to the indicated series. The x and y datatypes must correspond with the datatypes set for the indicated axis with the function: chart.set.axis.type().",
    "arguments": [
      {
        "type": "long",
        "name": "series",
        "description": "The identifier of the series. The identifier must be returned by the function chart.add.series()."
      },
      {
        "type": "(long|string|double)",
        "name": "x",
        "description": "X-value of the data point."
      },
      {
        "type": "(long|double)",
        "name": "y",
        "description": "Y-value of the data point."
      }
    ],
    "returnValue": "0 in case of success. -1 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.add.line.series": {
    "name": "chart.add.line.series",
    "type": "function",
    "syntax": "function long chart.add.line.series (long chart, const string title)",
    "description": "Create a new serie of type line (CHART_TYPE_LINE). Only to be used if the chart is of type CHART_TYPE_BAR or CHART_TYPE_BARHORIZONTAL. A series is the container for a set of data points which belong together and form a chart.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      },
      {
        "type": "const string",
        "name": "title",
        "description": "Title (label) for this series."
      }
    ],
    "returnValue": "Series id which must be used in following functions to add data points to this series. 0 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.add.series": {
    "name": "chart.add.series",
    "type": "function",
    "syntax": "function long chart.add.series (long chart, const string title)",
    "description": "Create a new series. A series is the container for a set of data points which belong together and form a chart. For a chart of type CHART_PIE exactly one series must be defined. For then other chart types one or more series can be added.Set the chart title and optionally the sub-title.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      },
      {
        "type": "const string",
        "name": "title",
        "description": "Title (label) for this series."
      }
    ],
    "returnValue": "Series id which must be used in following functions to add data points to this series. 0 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.clear.data": {
    "name": "chart.clear.data",
    "type": "function",
    "syntax": "function long chart.clear.data (long chart)",
    "description": "Remove all series including its datapoints for the indicated chart. This function is typically used in a callback function before new series and datapoints are added.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      }
    ],
    "returnValue": "0 in case of success. -1 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.set.axis.title": {
    "name": "chart.set.axis.title",
    "type": "function",
    "syntax": "function long chart.set.axis.title (long chart, long axis, const string title)",
    "description": "Set the title for the indicated axis.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      },
      {
        "type": "long",
        "name": "axis",
        "description": "Identifies the axis for which the type must be set: CHART_XAXIS, CHART_YAXIS."
      },
      {
        "type": "const string",
        "name": "title",
        "description": "The title set for the indicated axis."
      }
    ],
    "returnValue": "0 in case of success. -1 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.set.axis.type": {
    "name": "chart.set.axis.type",
    "type": "function",
    "syntax": "function long chart.set.axis.type (long chart, long axis, long type)",
    "description": "Set the data type for the indicated axis.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      },
      {
        "type": "long",
        "name": "axis",
        "description": "Identifies the axis for which the type must be set: CHART_XAXIS, CHART_YAXIS."
      },
      {
        "type": "long",
        "name": "type",
        "description": "Data type for the indicated axis. Possible values: DB.LONG, DB.DOUBLE, DB.STRING, DB.DATE or DB.TIME. The y-axis can only be of type DB.LONG or DB.DOUBLE."
      }
    ],
    "returnValue": "0 in case of success. -1 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "chart.set.title": {
    "name": "chart.set.title",
    "type": "function",
    "syntax": "function long chart.set.title (long chart, const string title [, const string subtitle])",
    "description": "Set the chart title and optionally the sub-title.",
    "arguments": [
      {
        "type": "long",
        "name": "chart",
        "description": "The identifier of the chart. The identifier must be returned by the function dialog.add.chart()."
      },
      {
        "type": "const string",
        "name": "title",
        "description": "The chart title which will be shown in the chart area. Note that this might differ from the dialog title, which will be shown in the dialog caption (title bar)."
      },
      {
        "type": "[const string",
        "name": "subtitle ]",
        "description": "Optional chart sub-title which will be shown in the chart area."
      }
    ],
    "returnValue": "0 in case of success. -1 in case of an error.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.add.button": {
    "name": "dialog.add.button",
    "type": "function",
    "syntax": "function long dialog.add.button (long dlg, const string btnFunction(), const string btnLabel)",
    "description": "Creates a button on the dialog.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "const string",
        "name": "btnFunction()",
        "description": "Name of the function that is called when the button is pressed."
      },
      {
        "type": "const string",
        "name": "btnLabel",
        "description": "The label used for the button."
      }
    ],
    "returnValue": "The id of the button. Negative value indicates an error.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.add.chart": {
    "name": "dialog.add.chart",
    "type": "function",
    "syntax": "function long dialog.add.chart (long dlg, long initial.type [, long allowed.types])",
    "description": "Note that this function only effects the WebUI and LN UI User Interface.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "long",
        "name": "initial.type",
        "description": "Initial type of the chart. Supported types: CHART_TYPE_BAR, CHART_TYPE_BARHORIZONTAL, CHART_TYPE_LINE, CHART_TYPE_LINE_STAIR, CHART_TYPE_LINE_SPLINE, CHART_TYPE_LINE_SCATTER, CHART_TYPE_PIE, CHART_TYPE_AREA."
      },
      {
        "type": "[long",
        "name": "allowed.types ]",
        "description": "Chart types from which the user might choose at runtime. Value is the sum of the supported type values (e.g. CHART_TYPE_BAR + CHART_TYPE_LINE)."
      }
    ],
    "returnValue": "This function returns a chart id which must be used in further chart calls. In case of an error the value 0 is returned.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.add.field": {
    "name": "dialog.add.field",
    "type": "function",
    "syntax": "function long dialog.add.field (long dlg, const string fldName(), const string fldLabel() [, long attribute, value,...])",
    "description": "This function creates a new field on the dialog.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "const string",
        "name": "fldName()",
        "description": "Name of the field. Preferably, there should also be a variable declared as extern in the script with the same name. The value of the dialog field will then be set in this variable. If such a variable does not exist, the attribute DLG_FIELD_DYNAMIC should be set to true and it will be created at runtime. Then, the value can be accessed with the function get.var() ."
      },
      {
        "type": "const string",
        "name": "fldLabel()",
        "description": "The label used for the field."
      },
      {
        "type": "[long",
        "name": "attribute, value,... ]",
        "description": "Use these optional arguments to set the dialog field's attributes. For each attribute you specify, you must include the attribute type (for example, DLG_DOMAIN or DLG_MANDATORY), and the attribute value."
      }
    ],
    "returnValue": "0 Success <0 The negative sequence number of the erroneous argument. E.g. a return value of -7 indicates an error in the 7th argument.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.add.listbox": {
    "name": "dialog.add.listbox",
    "type": "function",
    "syntax": "function long dialog.add.listbox (long dlg, const string fldName(), const string fldLabel(), const long no.items, long enum.vals(), string enum.desc(,) [, string attribute, value,...])",
    "description": "This function creates a dynamic list box (not representing an enum domain) on the dialog. If there is an enum domain, use the function dialog.add.field() .",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "const string",
        "name": "fldName()",
        "description": "Name of the field. This field must be declared as an extern long in the script. In case of a drop-down combo box (see possible attributes of last argument) this field must be declared as an extern string in the script instead."
      },
      {
        "type": "const string",
        "name": "fldLabel()",
        "description": "The label used for the field."
      },
      {
        "type": "const long",
        "name": "no.items",
        "description": "Number of items in the arrays enum.vals and enum.desc."
      },
      {
        "type": "long",
        "name": "enum.vals()",
        "description": "Array of longs, representing the return values."
      },
      {
        "type": "string",
        "name": "enum.desc(,)",
        "description": "Array of strings, representing the descriptions of the list items."
      },
      {
        "type": "[string",
        "name": "attribute, value,... ]",
        "description": "Possible attributes are: DLG_FIELD_SIZE: see dialog.add.field() DLG_MANDATORY: see dialog.add.field() DLG_FIELD_TYPE: Create a drop-down combo box (DLG_TYPE_COMBOBOX), in stead of the default drop-down list box (DLG_TYPE_LISTBOX)."
      }
    ],
    "returnValue": "None.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.add.text": {
    "name": "dialog.add.text",
    "type": "function",
    "syntax": "function long dialog.add.text (long dlg, string text() [, long attribute, value, ...])",
    "description": "This function creates static texts on the dialog. Purpose of this text can be for explanation or additional help.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "string",
        "name": "text()",
        "description": "The text to be displayed."
      },
      {
        "type": "[long",
        "name": "attribute, value, ... ]",
        "description": "Possible attributes are: DLG_FIELD_WIDTH: The number of characters to be displayed on one line."
      }
    ],
    "returnValue": "None.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.new": {
    "name": "dialog.new",
    "type": "function",
    "syntax": "function long dialog.new (string dialogName [, long attribute, value, ...])",
    "description": "Creates a new dialog. dialog.name will be used for the title bar of the new dialog. Possible attributes are:",
    "arguments": [
      {
        "type": "string",
        "name": "dialogName",
        "description": ""
      },
      {
        "type": "[long",
        "name": "attribute, value, ... ]",
        "description": "Possible attributes are: DLG_FIELD_WIDTH: The number of characters to be displayed on one line."
      }
    ],
    "returnValue": "The id of the created dialog. This id identifies the dialog in further dialog calls. It is the id of an XML tree that can be debugged during the whole process.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.refresh.field": {
    "name": "dialog.refresh.field",
    "type": "function",
    "syntax": "function long dialog.refresh.field (long dlg, const string fldName())",
    "description": "Refreshes the value of a field. This function can be used in a button function if the value for a field has changed.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "const string",
        "name": "fldName()",
        "description": "Name of the field that needs to be refreshed."
      }
    ],
    "returnValue": "0 OK -1 The dialog doesn't exist -2 The field doesn't exist.",
    "category": "functions_programmable_dialogs"
  },
  "dialog.show": {
    "name": "dialog.show",
    "type": "function",
    "syntax": "function long dialog.show (long dlg [, long previous_window] [, long load_defaults])",
    "description": "Displays the created dialog and start interaction with the user. This function returns when the user clicks the OK or Cancel button. Created dialogs can be used multiple times.",
    "arguments": [
      {
        "type": "long",
        "name": "dlg",
        "description": "The identifier of the dialog. The identifier must be created with the function dialog.new() ."
      },
      {
        "type": "[long",
        "name": "previous_window ]",
        "description": "This can be used in wizards (see DSBUTTONWIZARD in dialog.new() . It should be passed to dialog.show for every dialog. It contains information about the position and dimensions of the window which is passed from one dialog to the next."
      },
      {
        "type": "[long",
        "name": "load_defaults ]",
        "description": "When load_defaults = 1 then the saved defaults are load when the dialog is started."
      }
    ],
    "returnValue": "END.PROGRAM The user pressed the OK (or Finish) button 0 The user pressed the Cancel button NEXT.FRM The user pressed the Next button PREV.FRM The user pressed the Back button",
    "category": "functions_programmable_dialogs"
  },
  "programmable dialogs example": {
    "name": "Programmable Dialogs Example",
    "type": "function",
    "syntax": "function Programmable Dialogs Example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_programmable_dialogs"
  },
  "example chart": {
    "name": "Example chart",
    "type": "function",
    "syntax": "function Example chart()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_programmable_dialogs"
  },
  "programmable dialogs synopsis": {
    "name": "Programmable dialogs synopsis",
    "type": "function",
    "syntax": "function Programmable dialogs synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_programmable_dialogs"
  },
  "change.progress.delay": {
    "name": "change.progress.delay",
    "type": "function",
    "syntax": "function void change.progress.delay (long delay)",
    "description": "Changes the delay time of the progress indicator. The delay time is the time in milliseconds after which the progress indicator will appear to the user. This can be used to prevent flashing progress indicators, in case the number of elements to process is low, (i.e. a progress indicator that starts and stops within one or two seconds). By setting the delay time this flashing can be prevented.",
    "arguments": [
      {
        "type": "long",
        "name": "delay",
        "description": "The time in milliseconds that must have elapsed before the progress indicator will appear. This time starts counting when create.progress.indicator() is called."
      }
    ],
    "returnValue": "",
    "category": "functions_progress_indicators"
  },
  "change.progress.indicator": {
    "name": "change.progress.indicator",
    "type": "function",
    "syntax": "function long change.progress.indicator (long perc [, string message, ...])",
    "description": "This changes the value of the progress indicator.",
    "arguments": [
      {
        "type": "long",
        "name": "perc",
        "description": "A value in the range 0 � 100. This indicates the percentage of completion of the operation."
      },
      {
        "type": "[string",
        "name": "message, ... ]",
        "description": "This optional argument displays a string that provides information about the progress of the operation. For example, if the process involves multiple stages, you could add a short description of each stage to the progress indicator. If you include more than one message argument, each successive message is displayed below the previous one. A subsequent call to change.progress.indicator() may not give less messages than the first one."
      }
    ],
    "returnValue": "0 No signal sent. PROGRESS.STOP Stop button pressed. Function must stop. PROGRESS.CANCEL Cancel button pressed. Function must stop and cancel any changes made.",
    "category": "functions_progress_indicators"
  },
  "change.progress.title": {
    "name": "change.progress.title",
    "type": "function",
    "syntax": "function void change.progress.title (string title)",
    "description": "Changes the title of the progress indicator.",
    "arguments": [
      {
        "type": "string",
        "name": "title",
        "description": "The new title."
      }
    ],
    "returnValue": "",
    "category": "functions_progress_indicators"
  },
  "create.progress.indicator": {
    "name": "create.progress.indicator",
    "type": "function",
    "syntax": "function long create.progress.indicator (string title [, long mode])",
    "description": "This creates a progress indicator with the specified title displayed in its title bar. The progress indicator is activated after the first update (using change.progress.indicator() ). It is removed again using destroy.progress.indicator() , or automatically if PROGRESS.NOAUTODESTROY is not specified.",
    "arguments": [
      {
        "type": "string",
        "name": "title",
        "description": "The title for the progress indicator window."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This optional argument can specify a combination of the following values: PROGRESS.BAR"
      }
    ],
    "returnValue": "0 Success -1 Error",
    "category": "functions_progress_indicators"
  },
  "destroy.progress.indicator": {
    "name": "destroy.progress.indicator",
    "type": "function",
    "syntax": "function void destroy.progress.indicator ()",
    "description": "Destroys the progress indicator.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_progress_indicators"
  },
  "progress indicators sample program": {
    "name": "Progress indicators sample program",
    "type": "function",
    "syntax": "function Progress indicators sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_progress_indicators"
  },
  "progress indicators overview and synopsis": {
    "name": "Progress indicators overview and synopsis",
    "type": "function",
    "syntax": "function Progress indicators overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_progress_indicators"
  },
  "progress.indicator.exists": {
    "name": "progress.indicator.exists",
    "type": "function",
    "syntax": "function boolean progress.indicator.exists ()",
    "description": "This checks if a progress indicator was already created.",
    "arguments": [],
    "returnValue": "True Progress Indicator Exists False No Progress Indicator Exists",
    "category": "functions_progress_indicators"
  },
  "array fetching hint": {
    "name": "Array fetching hint",
    "type": "function",
    "syntax": "function Array fetching hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "array size hint": {
    "name": "Array size hint",
    "type": "function",
    "syntax": "function Array size hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "buffer hint": {
    "name": "Buffer hint",
    "type": "function",
    "syntax": "function Buffer hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "execution plan hints": {
    "name": "Execution plan hints",
    "type": "function",
    "syntax": "function Execution plan hints()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "hints for a split query in level-2": {
    "name": "Hints for a split query in level-2",
    "type": "function",
    "syntax": "function Hints for a split query in level-2()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "hints in a distributed environment": {
    "name": "Hints in a distributed environment",
    "type": "function",
    "syntax": "function Hints in a distributed environment()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "hint types": {
    "name": "Hint types",
    "type": "function",
    "syntax": "function Hint types()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "index hint": {
    "name": "Index hint",
    "type": "function",
    "syntax": "function Index hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "logging": {
    "name": "Logging",
    "type": "function",
    "syntax": "function Logging()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "'no hints' hint": {
    "name": "'No hints' hint",
    "type": "function",
    "syntax": "function 'No hints' hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "ordered hint": {
    "name": "Ordered hint",
    "type": "function",
    "syntax": "function Ordered hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "query hints overview": {
    "name": "Query hints overview",
    "type": "function",
    "syntax": "function Query hints overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "row mode hint": {
    "name": "Row mode hint",
    "type": "function",
    "syntax": "function Row mode hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "string hint": {
    "name": "String hint",
    "type": "function",
    "syntax": "function String hint()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_query_hints"
  },
  "random number generators overview and synopsis": {
    "name": "Random number generators overview and synopsis",
    "type": "function",
    "syntax": "function Random number generators overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_random_number_generator"
  },
  "random": {
    "name": "random",
    "type": "function",
    "syntax": "function long random ()",
    "description": "This function uses a system-independent random number generator. On all systems, the generator will generate the same random numbers, provided that the same seed is supplied.",
    "arguments": [],
    "returnValue": "A random number.",
    "category": "functions_random_number_generator"
  },
  "rnd.d": {
    "name": "rnd.d",
    "type": "function",
    "syntax": "function double rnd.d ()",
    "description": "This function uses a system-independent random number generator. On all systems, the generator will generate the same random numbers, provided that the same seed is supplied.",
    "arguments": [],
    "returnValue": "A random number in the range 0.0 to 1.0.",
    "category": "functions_random_number_generator"
  },
  "rnd.i": {
    "name": "rnd.i",
    "type": "function",
    "syntax": "function long rnd.i ( [long range])",
    "description": "This function uses a system-independent random number generator. On all systems, the generator will generate the same random numbers, provided that the same seed is supplied.",
    "arguments": [
      {
        "type": "[long",
        "name": "range ]",
        "description": ""
      }
    ],
    "returnValue": "A random number in the default or specified range.",
    "category": "functions_random_number_generator"
  },
  "rnd.init": {
    "name": "rnd.init",
    "type": "function",
    "syntax": "function void rnd.init (long seed)",
    "description": "rnd.d() and rnd.i() use a system-independent random number generator to generate random numbers. On all systems, the generator will generate the same random numbers, provided that the same seed is supplied.",
    "arguments": [
      {
        "type": "long",
        "name": "seed",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_random_number_generator"
  },
  "srand": {
    "name": "srand",
    "type": "function",
    "syntax": "function void srand (long seed)",
    "description": "random() generates random numbers using a multiplicative congruential random number generator. The default seed is 1. srand() resets the random number generator to the starting point specified by the seed argument (the seed can be any long value).",
    "arguments": [
      {
        "type": "long",
        "name": "seed",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_random_number_generator"
  },
  "is.rbhp.mode": {
    "name": "is.rbhp.mode",
    "type": "function",
    "syntax": "function boolean is.rbhp.mode ()",
    "description": "This function can be used to check if this 4GL session is directly started from a Role Based Home Page.",
    "arguments": [],
    "returnValue": "true session started from a Role Based Home Page false sessioin not started from a Role Based Home Page",
    "category": "functions_rbhp"
  },
  "role based home pages overview": {
    "name": "Role Based Home Pages overview",
    "type": "function",
    "syntax": "function Role Based Home Pages overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "rbhp.get.parameter": {
    "name": "rbhp.get.parameter",
    "type": "function",
    "syntax": "function string rbhp.get.parameter (const string name)",
    "description": "This function returns the named drillback parameter value which was passed by the Role Based Home Page drillback URL. This function can be called from the application function: tcint.dll0001.drill.back(). This function can also be called from a 4GL session when it was started from a Role Based Home Page drillback.",
    "arguments": [
      {
        "type": "const string",
        "name": "name",
        "description": "The name of the parameter for which the value is requested. For example LogicalId. These names are case sensitive !"
      }
    ],
    "returnValue": "The value of the named parameter or an empty string when this parameter was not present.",
    "category": "functions_rbhp"
  },
  "rbhp.query.extend.from": {
    "name": "rbhp.query.extend.from",
    "type": "function",
    "syntax": "function void rbhp.query.extend.from (const string from.extension)",
    "description": "Set the FROM clause extension to be used when starting the session. No syntax checking on the passed extension will be done. This extension will be appended to the extension set by the session. This function can only be called from the application function: tcint.dll0001.drill.back().",
    "arguments": [
      {
        "type": "const string",
        "name": "from.extension",
        "description": "A string containing FROM clause extension."
      }
    ],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "rbhp.query.extend.select": {
    "name": "rbhp.query.extend.select",
    "type": "function",
    "syntax": "function void rbhp.query.extend.select (const string select.extension)",
    "description": "Set the SELECT clause extension to be used when starting the session. No syntax checking on the passed extension will be done. This extension will be appended to the extension set by the session. This function can only be called from the application function: tcint.dll0001.drill.back().",
    "arguments": [
      {
        "type": "const string",
        "name": "select.extension",
        "description": "A string containing SELECT clause extension."
      }
    ],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "rbhp.query.extend.where": {
    "name": "rbhp.query.extend.where",
    "type": "function",
    "syntax": "function void rbhp.query.extend.where (const string where.extension)",
    "description": "Set the WHERE clause extension to be used when starting the session. No syntax checking on the passed extension will be done. This extension will be appended to the extension set by the session. This function can only be called from the application function: tcint.dll0001.drill.back().",
    "arguments": [
      {
        "type": "const string",
        "name": "where.extension",
        "description": "A string containing WHERE clause extension."
      }
    ],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "rbhp.set.error.message": {
    "name": "rbhp.set.error.message",
    "type": "function",
    "syntax": "function void rbhp.set.error.message (const string mess.or.code [, void arg ...])",
    "description": "Set error message and/or error code to be reported to the end user when during the tcint.dll0001.drill.back() function an error occurred. This function can only be called from the application function: tcint.dll0001.drill.back().",
    "arguments": [
      {
        "type": "const string",
        "name": "mess.or.code",
        "description": "Specifies either the data dictionary code for the message or a literal string. In the latter case, the value of mess.or.code must start with the at sign [@]. Note that using a literal string makes the script language dependent."
      },
      {
        "type": "[void",
        "name": "arg ... ]",
        "description": "The literal string or message specified with mess.or.code can contain format characters for parameter substitution. The values which must be substituted are specified in the 2nd, 3rd, ... arguments of the function. The number of these arguments is variable. For details about formatting a string see the sprintf$() ."
      }
    ],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "rbhp.set.session": {
    "name": "rbhp.set.session",
    "type": "function",
    "syntax": "function void rbhp.set.session (const string session.code, long mode, long company [, long session.index])",
    "description": "Set the session to be started, the mode of this session, the company number in which this session and the start index of the session. This function can only be called by either the application function: tcint.dll0001.drill.back() or the tools function icm.drillback() of the tticmdll0002 library.",
    "arguments": [
      {
        "type": "const string",
        "name": "session.code",
        "description": "The code of the session that must be started"
      },
      {
        "type": "long",
        "name": "mode",
        "description": "SINGLE_OCC The session is started as a single-occurrence (details) session. MULTI_OCC The session is started as a multi occurrence (overview) session. MULTI_OCC+MODAL The session is started as a multi occurrence in zoom mode."
      },
      {
        "type": "long",
        "name": "company",
        "description": "The company number in which the session must be started."
      },
      {
        "type": "[long",
        "name": "session.index ]",
        "description": "Optional argument specifying the initial index of the started session."
      }
    ],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "role based home pages synopsis": {
    "name": "Role Based Home Pages synopsis",
    "type": "function",
    "syntax": "function Role Based Home Pages synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_rbhp"
  },
  "brp.close": {
    "name": "brp.close",
    "type": "function",
    "syntax": "function void brp.close (long brp_id)",
    "description": "This stops the report writer for the specified report. brp_id is the report ID returned by brp.open() or brp.open.language() when the report was activated. The report is sorted (if necessary) and sent to the printer spooler.",
    "arguments": [
      {
        "type": "long",
        "name": "brp_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_reports"
  },
  "brp.open": {
    "name": "brp.open",
    "type": "function",
    "syntax": "function long brp.open (string rep_name(16), string device(14), long mode)",
    "description": "This activates a specified report and opens a specified spooler device (if it is not already open). Several reports can be active simultaneously. In a 4GL script, the name of the current report is stored in the predefined variable spool.report . This variable is available in the on.choice subsection of a choice.print.data section.",
    "arguments": [
      {
        "type": "string",
        "name": "rep_name(16)",
        "description": "The name of the report. Do not include a language code. The language of the user is automatically used."
      },
      {
        "type": "string",
        "name": "device(14)",
        "description": "The code of the device on which the report must be printed. This code must be defined in the data dictionary. If you specify an empty string here, you can use the mode argument to display a window in which the user can select the required device."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "0 User is not prompted to select a spooler device. 1 A window is displayed in which the user can select a spooler device. A Cancel button enables the user to cancel the operation. 2 A window is displayed in which the user can select a spooler device. There is no option for canceling the operation."
      }
    ],
    "returnValue": ">0 an ID for the activated report 0 report could not be activated -1 spooler could not be opened",
    "category": "functions_reports"
  },
  "brp.open.language": {
    "name": "brp.open.language",
    "type": "function",
    "syntax": "function long brp.open.language (string rep_name(16), string lang, string device(14), long mode)",
    "description": "This is the same as brp.open() in most respects, except that it includes a language argument. This enables you to specify a language for the report other than the default user language.",
    "arguments": [
      {
        "type": "string",
        "name": "rep_name(16)",
        "description": ""
      },
      {
        "type": "string",
        "name": "lang",
        "description": ""
      },
      {
        "type": "string",
        "name": "device(14)",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": ">0 an ID for the activated report 0 report could not be activated -1 spooler could not be opened",
    "category": "functions_reports"
  },
  "brp.ready": {
    "name": "brp.ready",
    "type": "function",
    "syntax": "function long brp.ready (long brp_id)",
    "description": "This signals the report writer that a record is ready to be imported into a particular report. The report writer then prints the record. You call this function after filling the fields of a record that the report writer can process. The fields are specified in the report and must be declared as EXTERN in the program script.",
    "arguments": [
      {
        "type": "long",
        "name": "brp_id",
        "description": "This identifies the particular report into which the record must be imported. It is the ID returned by brp.open() or brp.open.language() when the report was activated."
      }
    ],
    "returnValue": "0 success -1 error: unknown ID specified",
    "category": "functions_reports"
  },
  "choice.report": {
    "name": "choice.report",
    "type": "function",
    "syntax": "function long choice.report (ref string reportname(15))",
    "description": "This returns the name of a report from the session data in the data dictionary. The report is taken from the group defined in the predefined variable reportgrp (default = 1). If there is more than one report in the group, the user is presented with a menu from which to select the required report.",
    "arguments": [
      {
        "type": "ref string",
        "name": "reportname(15)",
        "description": ""
      }
    ],
    "returnValue": ">0 sequence number of report in the group -1 report not found, or no report selected by user",
    "category": "functions_reports"
  },
  "reports overview and synopsis": {
    "name": "Reports overview and synopsis",
    "type": "function",
    "syntax": "function Reports overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_reports"
  },
  "rprt_close": {
    "name": "rprt_close",
    "type": "function",
    "syntax": "function void rprt_close ( [long mess_flag])",
    "description": "This is a short version of brp.close() . It closes the report writer for the current report. You can use the function in a 4GL script in the subsection on.choice of the section choice.print.data . In this section, the predefined variable spool.report is available. This variable stores the name of the current report.",
    "arguments": [
      {
        "type": "[long",
        "name": "mess_flag ]",
        "description": "This optional argument can have one of the following values (default is 0): 0 If no data is printed, the following message appears: �No data present within selection� 1 If no data is printed, the following message appears: �No data found for report, no report is printed� 2 If no data is printed, no message appears."
      }
    ],
    "returnValue": "",
    "category": "functions_reports"
  },
  "rprt_open": {
    "name": "rprt_open",
    "type": "function",
    "syntax": "function long rprt_open ()",
    "description": "This is a short version of brp.open() . It has the same effect as:",
    "arguments": [],
    "returnValue": ">0 an ID for the activated report 0 report could not be activated -1 spooler could not be opened",
    "category": "functions_reports"
  },
  "rprt_send": {
    "name": "rprt_send",
    "type": "function",
    "syntax": "function void rprt_send ()",
    "description": "This is a short version of brp.ready() . It has the same effect as:",
    "arguments": [],
    "returnValue": "",
    "category": "functions_reports"
  },
  "set.spool.main.report": {
    "name": "set.spool.main.report",
    "type": "function",
    "syntax": "function void set.spool.main.report (string rep_name)",
    "description": "This stores a specified report name in the predefined variable spool.main.report .",
    "arguments": [
      {
        "type": "string",
        "name": "rep_name",
        "description": "The name of the report that must be used as main report."
      }
    ],
    "returnValue": "",
    "category": "functions_reports"
  },
  "resource sets overview": {
    "name": "Resource sets overview",
    "type": "function",
    "syntax": "function Resource sets overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "rsc.font.spec": {
    "name": "rsc.font.spec",
    "type": "function",
    "syntax": "function string rsc.font.spec (long font_weight, long font_slant, long font_height, long font_points, long font_spacing, long font_width, long font_charwidth)",
    "description": "This returns a string that defines a font with the specified characteristics.",
    "arguments": [
      {
        "type": "long",
        "name": "font_weight",
        "description": "The font width. Possible values are: FNTMEDIUM, FNTBOLD or FNTNORMAL."
      },
      {
        "type": "long",
        "name": "font_slant",
        "description": "The font slant. Possible values are: FNTROMAN or FNTITALIC."
      },
      {
        "type": "long",
        "name": "font_height",
        "description": "The font height in pixels."
      },
      {
        "type": "long",
        "name": "font_points",
        "description": "The font height in tenths of a point (a point is 1/72th of an inch)."
      },
      {
        "type": "long",
        "name": "font_spacing",
        "description": "The type of spacing. Possible values are: FNTFIXED or FNTVARIABLE."
      },
      {
        "type": "long",
        "name": "font_width",
        "description": "The average width of the font, in tenths of a pixel."
      },
      {
        "type": "long",
        "name": "font_charwidth",
        "description": "The average character width, in pixels. This overides the font_width value."
      }
    ],
    "returnValue": "A string that defines a font with the specified characteristics.",
    "category": "functions_resource_sets"
  },
  "rsc.get": {
    "name": "rsc.get",
    "type": "function",
    "syntax": "function void rsc.get (ref string values(), string package_code(2), string resource_set(16), string resource_id(24),...)",
    "description": "",
    "arguments": [
      {
        "type": "ref string",
        "name": "values()",
        "description": "The returned resource values. This argument must be long enough to accommodate the number of requested resources."
      },
      {
        "type": "string",
        "name": "package_code(2)",
        "description": "The package code."
      },
      {
        "type": "string",
        "name": "resource_set(16)",
        "description": "The resource set ID."
      },
      {
        "type": "string",
        "name": "resource_id(24),...",
        "description": "One or more IDs of individual resources."
      }
    ],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "rsc.boolean, rsc.double, rsc.enum, rsc.long, rsc.string": {
    "name": "rsc.boolean, rsc.double, rsc.enum, rsc.long, rsc.string",
    "type": "function",
    "syntax": "function void rsc.boolean (string variable)",
    "description": "These convert a specified program variable to the corresponding resource value format (boolean, double, enum, and so on).",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "rsc.put": {
    "name": "rsc.put",
    "type": "function",
    "syntax": "function void rsc.put (string package_code(2), string resource_set(16), string resource_id(16), value(40) [, string resource_id(16), value(40) . . .])",
    "description": "This updates one or more resource values in a specified resource set. You can use the following functions to convert program variables to a resource value format: rsc.boolean(), rsc.double(), rsc.enum(), rsc.long(), rsc.string() , rsc.boolean(), rsc.double(), rsc.enum(), rsc.long(), rsc.string() , rsc.boolean(), rsc.double(), rsc.enum(), rsc.long(), rsc.string() , rsc.boolean(), rsc.double(), rsc.enum(), rsc.long(), rsc.string() , and rsc.boolean(), rsc.double(), rsc.enum(), rsc.long(), rsc.string() .",
    "arguments": [
      {
        "type": "string",
        "name": "package_code(2)",
        "description": "The package code."
      },
      {
        "type": "string",
        "name": "resource_set(16)",
        "description": "The resource set ID."
      },
      {
        "type": "string",
        "name": "resource_id(16), value(40)",
        "description": "One or more name/value pairs. Each pair consists of the ID of a resource that must be updated and the new value for that resource."
      },
      {
        "type": "[string",
        "name": "resource_id(16), value(40) . . . ]",
        "description": "One or more name/value pairs. Each pair consists of the ID of a resource that must be updated and the new value for that resource."
      }
    ],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "rsc.setboolean *": {
    "name": "rsc.setboolean *",
    "type": "function",
    "syntax": "function void rsc.setboolean (string variable, string value(40))",
    "description": "These store a resource value of a particular type in a specified program variable.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": ""
      },
      {
        "type": "string",
        "name": "value(40)",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "resource sets synopsis": {
    "name": "Resource sets synopsis",
    "type": "function",
    "syntax": "function Resource sets synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_resource_sets"
  },
  "domainof": {
    "name": "domainof",
    "type": "function",
    "syntax": "function string domainof (string variable)",
    "description": "This compile time function returns the name of the domain of the supplied variable.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": "The type of this variable must be a domain type, otherwise a compile time error will occur."
      }
    ],
    "returnValue": "The name of the domain of the supplied variable.",
    "category": "functions_runtime_dictionary_information"
  },
  "get.session.permission": {
    "name": "get.session.permission",
    "type": "function",
    "syntax": "function long get.session.permission (string session(13))",
    "description": "Retrieves the permission of the session ( session ) in a bit pattern (see return values). Each of the listed 'return values' represents one bit. Multiple values can be bitwise OR-ed into one pattern and returned by the function. In cases of internal errors in the function, the value SESSION_NO_PERMISSION will be returned.",
    "arguments": [
      {
        "type": "string",
        "name": "session(13)",
        "description": ""
      }
    ],
    "returnValue": "SESSION_NO_PERMISSION SESSION_DELETE_PERMISSION SESSION_INSERT_PERMISSION SESSION_MODIFY_PERMISSION SESSION_DISPLAY_PERMISSION SESSION_PRINT_PERMISSION",
    "category": "functions_runtime_dictionary_information"
  },
  "runtime dictionary information overview and synopsis": {
    "name": "Runtime dictionary information overview and synopsis",
    "type": "function",
    "syntax": "function Runtime dictionary information overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.audit.hosts": {
    "name": "rdi.audit.hosts",
    "type": "function",
    "syntax": "function long rdi.audit.hosts (string table_name(9), long comp_nr, ref string hosts())",
    "description": "This returns the names of the hosts on which audit information for a particular table is stored.",
    "arguments": [
      {
        "type": "string",
        "name": "table_name(9)",
        "description": "The name of the table."
      },
      {
        "type": "long",
        "name": "comp_nr",
        "description": "The company number of the table."
      },
      {
        "type": "ref string",
        "name": "hosts()",
        "description": "This returns a string containing the names of all hosts on which audit information for the specified table is stored. The host names are separated by commas [,]. The local host is referred to as 'localhost'."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.column.combined": {
    "name": "rdi.column.combined",
    "type": "function",
    "syntax": "function long rdi.column.combined (string column_name(18), string ref child_colums(18, 32))",
    "description": "This returns information about the child columns of a specified column.",
    "arguments": [
      {
        "type": "string",
        "name": "column_name(18)",
        "description": "The name of the column for which you wish to retrieve information."
      },
      {
        "type": "string",
        "name": "ref child_colums(18, 32)",
        "description": "This returns an array containing the names of the child columns of the specified column. It can contain the names of up to 32 child columns."
      }
    ],
    "returnValue": "The function returns the number of filled children. -1 indicates that the column does not exist, or is not combined",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.column": {
    "name": "rdi.column",
    "type": "function",
    "syntax": "function long rdi.column (string column_name(18), ref string domain_name(14), ref long offset, ref long size, ref long dept, ref long type, ref long flag, ref string default_value(.))",
    "description": "This returns information about a specified table column.",
    "arguments": [
      {
        "type": "string",
        "name": "column_name(18)",
        "description": "The name of the column about which you want to retrieve information."
      },
      {
        "type": "ref string",
        "name": "domain_name(14)",
        "description": "This returns the name of the column's domain."
      },
      {
        "type": "ref long",
        "name": "offset",
        "description": "This returns the position of the column in the row."
      },
      {
        "type": "ref long",
        "name": "size",
        "description": "This returns the size of the column, in bytes. See this list of database types and related byte counts ."
      },
      {
        "type": "ref long",
        "name": "dept",
        "description": "This returns the depth of the column (array columns only)."
      },
      {
        "type": "ref long",
        "name": "type",
        "description": "This returns the database type of the column. For example, DB.LONG, DB.FLOAT, and so on. See this list of database types ."
      },
      {
        "type": "ref long",
        "name": "flag",
        "description": "This returns a bit pattern that represents one or more of the following values: DB.ARRAY DB.CDF DB.CHILD DB.FILLED"
      },
      {
        "type": "ref string",
        "name": "default_value(.)",
        "description": "This returns the default value of the column."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.ctoe": {
    "name": "rdi.ctoe",
    "type": "function",
    "syntax": "function long rdi.ctoe (string domain_name(14), string enum_name)",
    "description": "This gets an enum as string and returns the enum-value as long belonging to it in the specified domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "string",
        "name": "enum_name",
        "description": "A string representing an enum-value in the domain."
      }
    ],
    "returnValue": "Enum-value as long on success -1 Domain name hasn't been found -2 Incorrect domain information found -3 Enum-name not found in domain",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.date.input.format$": {
    "name": "rdi.date.input.format$",
    "type": "function",
    "syntax": "function string rdi.date.input.format$ (string date_format(7) [, ref string display_format()])",
    "description": "This returns the input format defined in the data dictionary for a specified date format. The input format can be any combination of day-in-week (D), week-in-year (W), and year (Y), or any combination of day-in-month (D), month-in-year (M), and year (Y). For example, if the function returns MDY, the input format on a form field must be month, day-in-month, and year (for example, 12311998).",
    "arguments": [
      {
        "type": "string",
        "name": "date_format(7)",
        "description": "A date format defined in the data dictionary. This must be specified as %D n [, lang ], where n is the date format code and lang is the language code. See sprintf$()sprintf."
      },
      {
        "type": "[ref string",
        "name": "display_format() ]",
        "description": "Optional argument which returns the display format for the specified date format."
      }
    ],
    "returnValue": "The input format defined in the data dictionary for the specified date format.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.byte": {
    "name": "rdi.domain.byte",
    "type": "function",
    "syntax": "function long rdi.domain.byte (string domain_name(14), ref long digits)",
    "description": "This returns information about a domain of type DB.BYTE.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits",
        "description": "This returns the number of digits defined for the byte-type domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.combined": {
    "name": "rdi.domain.combined",
    "type": "function",
    "syntax": "function long rdi.domain.combined (string domain_name(14), ref string child_domains(14, 32))",
    "description": "This returns information about a domain of type DB.COMBINED.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref string",
        "name": "child_domains(14, 32)",
        "description": "This returns an array containing the names of the children of the specified domain. It can contain the names of up to 32 children."
      }
    ],
    "returnValue": "The number of filled children.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.date": {
    "name": "rdi.domain.date",
    "type": "function",
    "syntax": "function long rdi.domain.date (string domain_name(14), ref long digits)",
    "description": "This returns information about a domain of type DB.DATE.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits",
        "description": "This returns the number of digits defined for the date-type domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.double": {
    "name": "rdi.domain.double",
    "type": "function",
    "syntax": "function long rdi.domain.double (string domain_name(14), ref long digits_before, ref long digits_after, ref long divide_factor, ref long round_code)",
    "description": "This returns information about a domain of type DB.DOUBLE.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits_before",
        "description": "This returns the number of digits before the decimal point in the specified domain."
      },
      {
        "type": "ref long",
        "name": "digits_after",
        "description": "This returns the number of digits after the decimal point."
      },
      {
        "type": "ref long",
        "name": "divide_factor",
        "description": "This returns the divide factor for the specified domain."
      },
      {
        "type": "ref long",
        "name": "round_code",
        "description": "This returns the rounding mode for the specified domain. Possible values are: 0 truncate (for example, both 1.5 and 1.49 are rounded down to 1) 1 normal round (for example, 1.5 is rounded up to 2; 1.49 is rounded down to 1) 2 round up (for example, both 1.5 and 1.49 are rounded up to 2)"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.enum": {
    "name": "rdi.domain.enum",
    "type": "function",
    "syntax": "function long rdi.domain.enum (string domain_name(14), ref long no_enum_items)",
    "description": "This returns information about a domain of type DB.ENUM.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "no_enum_items",
        "description": "The number of enum items in the specified domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.enum.value": {
    "name": "rdi.domain.enum.value",
    "type": "function",
    "syntax": "function long rdi.domain.enum.value (string domain_name, long enum_item, string language, ref string keyword(.), ref string descr(.), ref long value)",
    "description": "This returns information about a specified item in an enumerated domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name",
        "description": "The name of the domain."
      },
      {
        "type": "long",
        "name": "enum_item",
        "description": "The position of the enum item for which you want to retrieve information."
      },
      {
        "type": "string",
        "name": "language",
        "description": "The language code for the enumerated domain."
      },
      {
        "type": "ref string",
        "name": "keyword(.)",
        "description": "This returns the constant name of the specified enum item."
      },
      {
        "type": "ref string",
        "name": "descr(.)",
        "description": "This returns the description of the specified enum item."
      },
      {
        "type": "ref long",
        "name": "value",
        "description": "This returns the constant value of the specified enum item."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.float": {
    "name": "rdi.domain.float",
    "type": "function",
    "syntax": "function long rdi.domain.float (string domain_name(14), ref long digits_before, ref long digits_after, ref long divide_factor, ref long round_code)",
    "description": "This returns information about a domain of type DB.FLOAT.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits_before",
        "description": "This returns the number of digits before the decimal point in the specified domain."
      },
      {
        "type": "ref long",
        "name": "digits_after",
        "description": "This returns the number of digits after the decimal point."
      },
      {
        "type": "ref long",
        "name": "divide_factor",
        "description": "This returns the divide factor for the specified domain."
      },
      {
        "type": "ref long",
        "name": "round_code",
        "description": "This returns the rounding mode for the specified domain. Possible values are: 0 truncate (for example, both 1.5 and 1.49 are rounded down to 1) 1 normal round (for example, 1.5 is rounded up to 2; 1.49 is rounded down to 1) 2 round up (for example, both 1.5 and 1.49 are rounded up to 2)"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain": {
    "name": "rdi.domain",
    "type": "function",
    "syntax": "function long rdi.domain (string domain_name(14), ref string oformat(.), ref string lechar(.), ref string ilchar(.), ref long adjust, ref string errmess(.), ref long range_expr_id [, ref long plen] [, ref string iformat(.)])",
    "description": "This returns information about a specified domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain for which you want to retrieve information."
      },
      {
        "type": "ref string",
        "name": "oformat(.)",
        "description": "This returns the output format of the domain."
      },
      {
        "type": "ref string",
        "name": "lechar(.)",
        "description": "This returns the legal characters for the domain."
      },
      {
        "type": "ref string",
        "name": "ilchar(.)",
        "description": "This returns the illegal characters for the domain."
      },
      {
        "type": "ref long",
        "name": "adjust",
        "description": "This returns the domain's alignment mode. Possible values are: RDI.NONE RDI.LEFT RDI.RIGHT RDI.CENTER"
      },
      {
        "type": "ref string",
        "name": "errmess(.)",
        "description": "This returns the domain's error message."
      },
      {
        "type": "ref long",
        "name": "range_expr_id",
        "description": "This returns the ID of the compiled expression for the range check."
      },
      {
        "type": "[ref long",
        "name": "plen ]",
        "description": "This returns the maximum field length (in display width) used on forms and reports."
      },
      {
        "type": "[ref string",
        "name": "iformat(.) ]",
        "description": "This returns the domain's internal format."
      }
    ],
    "returnValue": "The function returns the domain type, or -1 if an errors occurs. The possible domain types are: DB.BYTE DB.DOUBLE DB.ENUM DB.INTEGER DB.STRING DB.BITSET DB.LONG DB.DATE DB.COMBINED DB.FLOAT DB.TEXT DB.MULTIBYTE DB.TIME DB.RAW",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.integer": {
    "name": "rdi.domain.integer",
    "type": "function",
    "syntax": "function long rdi.domain.integer (string domain_name(14), ref long digits)",
    "description": "This returns information about a domain of type DB.INTEGER.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits",
        "description": "This returns the number of digits defined for the integer-type domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.long": {
    "name": "rdi.domain.long",
    "type": "function",
    "syntax": "function long rdi.domain.long (string domain_name(14), ref long digits)",
    "description": "This returns information about a domain of type DB.LONG.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits",
        "description": "This returns the number of digits defined for the long-type domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.raw": {
    "name": "rdi.domain.raw",
    "type": "function",
    "syntax": "function long rdi.domain.raw (string domain_name(14), ref long length)",
    "description": "This returns information about a domain of type DB.RAW.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "length",
        "description": "This returns the defined length of the raw string (in bytes)."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.set": {
    "name": "rdi.domain.set",
    "type": "function",
    "syntax": "function long rdi.domain.set (string domain_name(14), ref long no_enum_items)",
    "description": "This returns information about a domain of type DB.BITSET.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "no_enum_items",
        "description": "The number of set items in the specified domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.set.value": {
    "name": "rdi.domain.set.value",
    "type": "function",
    "syntax": "function long rdi.domain.set.value (string domain_name(14), long enum_item, string language, ref string keyword(.), string descr(.), ref string value)",
    "description": "This returns information about a specified item in a set-type domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "long",
        "name": "enum_item",
        "description": "The numeric code of the set item for which you want to retrieve information."
      },
      {
        "type": "string",
        "name": "language",
        "description": "The language code for the set domain."
      },
      {
        "type": "ref string",
        "name": "keyword(.)",
        "description": "This returns the name of the specified set item."
      },
      {
        "type": "string",
        "name": "descr(.)",
        "description": "This returns the description of the specified set item."
      },
      {
        "type": "ref string",
        "name": "value",
        "description": "This returns the value of the specified set item."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.string": {
    "name": "rdi.domain.string",
    "type": "function",
    "syntax": "function long rdi.domain.string (string domain_name(14), ref long length, ref long convert)",
    "description": "This returns information about a domain of type DB.STRING.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "length",
        "description": "This returns the defined length of the string (in bytes)."
      },
      {
        "type": "ref long",
        "name": "convert",
        "description": "This returns the conversion mode of the domain. Possible values are: RDI.UPPER RDI.LOWER RDI.NONE"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.domain.text": {
    "name": "rdi.domain.text",
    "type": "function",
    "syntax": "function long rdi.domain.text (string domain_name(14), ref long digits)",
    "description": "This returns information about a domain of type DB.TEXT.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "ref long",
        "name": "digits",
        "description": "This returns the number of digits defined for the text-type domain."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.etoc$": {
    "name": "rdi.etoc$",
    "type": "function",
    "syntax": "function string rdi.etoc$ (string domain_name(14), long enum_value as long)",
    "description": "This gets an enum-value as long and returns a string representing it in the specified domain.",
    "arguments": [
      {
        "type": "string",
        "name": "domain_name(14)",
        "description": "The name of the domain."
      },
      {
        "type": "long",
        "name": "enum_value as long",
        "description": "An enum-value in the specified domain."
      }
    ],
    "returnValue": "filled string, success empty string, error occurred",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.first.day.of.week": {
    "name": "rdi.first.day.of.week",
    "type": "function",
    "syntax": "function long rdi.first.day.of.week ()",
    "description": "This function returns the first day of the week as defined for the company of the user. The returned number is relative to Sunday (=1). So, for example, if the function returns 2, this indicates that Monday is the user's first day of the week.",
    "arguments": [],
    "returnValue": "The user's first day of the week.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.format.digits": {
    "name": "rdi.format.digits",
    "type": "function",
    "syntax": "function long rdi.format.digits (string format(), ref long digits.before, ref long digits.after [, ref string display.format()])",
    "description": "This returns information about a specified format.",
    "arguments": [
      {
        "type": "string",
        "name": "format()",
        "description": "The format code of a double or float."
      },
      {
        "type": "ref long",
        "name": "digits.before",
        "description": "Number of digits before the decimal point"
      },
      {
        "type": "ref long",
        "name": "digits.after",
        "description": "Number of digits after the decimal point"
      },
      {
        "type": "[ref string",
        "name": "display.format() ]",
        "description": "Optional argument where the display format is stored"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.index": {
    "name": "rdi.index",
    "type": "function",
    "syntax": "function long rdi.index (string table_name(9), long index_no, ref long parts(32, 3), ref boolean duplicate, ref boolean active)",
    "description": "This returns information about a specified index.",
    "arguments": [
      {
        "type": "string",
        "name": "table_name(9)",
        "description": "The name of the relevant table (omit the leading 't')."
      },
      {
        "type": "long",
        "name": "index_no",
        "description": "The index ID."
      },
      {
        "type": "ref long",
        "name": "parts(32, 3)",
        "description": "This returns the start position, length, and type of the index parts (up to a maximum of 32 parts): parts(i,1) Start position of part i in record parts(i,2) Length of part i . See this list of database types and related byte counts . parts(i,3) Type of part i . See this list of database types ."
      },
      {
        "type": "ref boolean",
        "name": "duplicate",
        "description": "Indicates whether or not duplicate values are permitted. Possible values are: TRUE duplicates permitted FALSE duplicates not permitted"
      },
      {
        "type": "ref boolean",
        "name": "active",
        "description": "Indicates whether or not the index is active. Possible values are: TRUE index is active FALSE index is not active"
      }
    ],
    "returnValue": "The number of filled parts.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.is.application.column": {
    "name": "rdi.is.application.column",
    "type": "function",
    "syntax": "function boolean rdi.is.application.column (const string column.name [, long column.type] [, long column.offset] [, long table.real.length])",
    "description": "This function checks whether the given column is an application column, or one that is automatically added by tools.",
    "arguments": [
      {
        "type": "const string",
        "name": "column.name",
        "description": "The column (including table name) to check."
      },
      {
        "type": "[long",
        "name": "column.type ]",
        "description": "Optional input, the column's database type as returned by e.g. rdi.column() ."
      },
      {
        "type": "[long",
        "name": "column.offset ]",
        "description": "Optional input, the column's offset in the record as returned by e.g. rdi.column() ."
      },
      {
        "type": "[long",
        "name": "table.real.length ]",
        "description": "Optional input, the table record's length without internal data as returned by rdi.table() (real_length)."
      }
    ],
    "returnValue": "True if the column is a regular application column, false if the column is one that is automatically added by tools.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.reference": {
    "name": "rdi.reference",
    "type": "function",
    "syntax": "function long rdi.reference (string column_name(18), ref string ref_column(18), ref long ref_mode, ref string ref_mess() [, ref boolean check_by_db] [, ref long ref_update_mode] [, ref long ref_delete_mode])",
    "description": "If a database column references a column in another table, use this function to retrieve information about the referenced column.",
    "arguments": [
      {
        "type": "string",
        "name": "column_name(18)",
        "description": "The name of the column which references the column about which you want to retrieve information."
      },
      {
        "type": "ref string",
        "name": "ref_column(18)",
        "description": "This returns the name of the column to which the column specified in column_name refers."
      },
      {
        "type": "ref long",
        "name": "ref_mode",
        "description": "This returns the relation type. Possible values are: 1 mandatory 2 mandatory unless empty 3 not mandatory"
      },
      {
        "type": "ref string",
        "name": "ref_mess()",
        "description": "This returns the error message of the referenced column."
      },
      {
        "type": "[ref boolean",
        "name": "check_by_db ]",
        "description": "This indicates whether or not a referential integrity check is performed by the database driver. Possible values are: false check ignored true check performed by database driver"
      },
      {
        "type": "[ref long",
        "name": "ref_update_mode ]",
        "description": "This returns the action to be done by the system, if an occurrence in the table referred to (= parent table) is updated. Possible values are: DB.REF.RESTRICTED DB.REF.CASCADE DB.REF.NULLIFY DB.REF.CHK.RUNTIME DB.REF.NOP"
      },
      {
        "type": "[ref long",
        "name": "ref_delete_mode ]",
        "description": "This returns the action to be done by the system, if an occurrence in the table referred to (= parent table) is deleted. Possible values are: DB.REF.RESTRICTED DB.REF.CASCADE DB.REF.NULLIFY DB.REF.CHK.RUNTIME DB.REF.NOP"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.report.sensitivity": {
    "name": "rdi.report.sensitivity",
    "type": "function",
    "syntax": "function long rdi.report.sensitivity (const string reportname)",
    "description": "Returns sensitivity of current report if no reportname was specified, otherwise the given reportname is used.",
    "arguments": [
      {
        "type": "const string",
        "name": "reportname",
        "description": "optional argument: the name of the report for which you need to know the sensitivity."
      }
    ],
    "returnValue": "A value of 0 means that the report is not sensitive. A value of 1 - 99 is the sensitivity level. A value of 0 < 0 or > 99 indicates an error.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.session.sensitivity": {
    "name": "rdi.session.sensitivity",
    "type": "function",
    "syntax": "function long rdi.session.sensitivity ()",
    "description": "Returns sensitivity of current session. The function rdi.session.sensitivity also checks all table fields on a form (if any). The returned sensitivity is the highest sensitivity applicable to a session of table field on a form.",
    "arguments": [],
    "returnValue": "A value of 0 means that the session is not sensitive. A value of 1 - 99 is the sensitivity level. A value of 0 < 0 or > 99 indicates an error.",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.table.column": {
    "name": "rdi.table.column",
    "type": "function",
    "syntax": "function long rdi.table.column (string table_name(9), long column_number, ref string column_name, ref string domain_name(14), ref long offset, ref long size, ref long dept, ref long type, ref long flag, ref string default_value [, long flag_filter])",
    "description": "This returns information about a specified column which is identified by the table name and the column number. Note that the first columns in the table are reserved for the following columns: Refcntd, Refcntu, _compnr, _dlock, and _index<number> (one column for each index).",
    "arguments": [
      {
        "type": "string",
        "name": "table_name(9)",
        "description": "The name of the table in which the column occurs (omit the leading 't')."
      },
      {
        "type": "long",
        "name": "column_number",
        "description": "The column number."
      },
      {
        "type": "ref string",
        "name": "column_name",
        "description": "This returns the name of the column."
      },
      {
        "type": "ref string",
        "name": "domain_name(14)",
        "description": "This returns the name of the column's domain."
      },
      {
        "type": "ref long",
        "name": "offset",
        "description": "This returns the position of the column in the row."
      },
      {
        "type": "ref long",
        "name": "size",
        "description": "This returns the size of the column, in bytes. See this list of database types and related byte counts ."
      },
      {
        "type": "ref long",
        "name": "dept",
        "description": "This returns the depth of the column (array columns only)."
      },
      {
        "type": "ref long",
        "name": "type",
        "description": "This returns the database type of the column. For example, DB.LONG, DB.FLOAT, and so on. See this list of database types ."
      },
      {
        "type": "ref long",
        "name": "flag",
        "description": "This returns a bit pattern that represents one or more of the following values: DB.ARRAY DB.CDF DB.CHILD DB.FILLED DB.MLF"
      },
      {
        "type": "ref string",
        "name": "default_value",
        "description": "This returns the default value of the column."
      },
      {
        "type": "[long",
        "name": "flag_filter ]",
        "description": "This optional argument can be used to get a filtered list of columns that have the specified flag set. For example, the 2nd CDF column from a table can be retrieved by calling this function with column_name = 2 and flag_filter = DB.CDF"
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.table": {
    "name": "rdi.table",
    "type": "function",
    "syntax": "function long rdi.table (string table_name(9), ref long no_keys, ref long no_columns, ref long int_length, ref long real_length [, ref long no_cdf] [, ref boolean mlf_table_all_languages])",
    "description": "This returns information about a specified table.",
    "arguments": [
      {
        "type": "string",
        "name": "table_name(9)",
        "description": "The table name (omit the leading 't')."
      },
      {
        "type": "ref long",
        "name": "no_keys",
        "description": "This returns the number of indices that have been created on the table."
      },
      {
        "type": "ref long",
        "name": "no_columns",
        "description": "This returns the number of columns that are in the table, including the following columns: Refcntd Refcntu _compnr _dlock _index< number > (a column for each index)"
      },
      {
        "type": "ref long",
        "name": "int_length",
        "description": "This returns the length of the internal buffer that is needed for a row in the table and its internal data like '_compnr' and '_dlock'."
      },
      {
        "type": "ref long",
        "name": "real_length",
        "description": "This returns the length of a row in the table without the internal data. This length is at least the sum of the byte counts of the individual columns. See this list of database types and related byte counts ."
      },
      {
        "type": "[ref long",
        "name": "no_cdf ]",
        "description": "This optional argument returns the number of CDF columns that are in the table."
      },
      {
        "type": "[ref boolean",
        "name": "mlf_table_all_languages ]",
        "description": "This optional argument returns whether the table is configured for selection of all languages of its multi language fields, even when the resource mle_all_data_languages is set to the value 0 (indicating that by default only the current language must be selected). If this optional argument is used, then first the no_cdf argument must be supplied. This optional argument can be used as of TIV level 2140 ."
      }
    ],
    "returnValue": "0 success -1 error",
    "category": "functions_runtime_dictionary_information"
  },
  "rdi.tablefield.sensitivity": {
    "name": "rdi.tablefield.sensitivity",
    "type": "function",
    "syntax": "function long rdi.tablefield.sensitivity (const string tablefield)",
    "description": "Returns sensitivity of the provided table field.",
    "arguments": [
      {
        "type": "const string",
        "name": "tablefield",
        "description": "the name of table field for which you need to know the sensitivity."
      }
    ],
    "returnValue": "A value of 0 means that the report is not sensitive. A value of 1 - 99 is the sensitivity level. A value of 0 < 0 or > 99 indicates an error.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.bobject.desc": {
    "name": "tt.bobject.desc",
    "type": "function",
    "syntax": "function string tt.bobject.desc (string b_object(10), ref string desc() mb)",
    "description": "This retrieves the description of a specified business object ( b_object ). It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "b_object(10)",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "The chart type."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.cdf": {
    "name": "tt.cdf",
    "type": "function",
    "syntax": "function long tt.cdf (const string cdf, ref boolean active, ref boolean internal)",
    "description": "This function returns information about the given given Customer Defined Field (CDF) as defined for the current Package Combination.",
    "arguments": [
      {
        "type": "const string",
        "name": "cdf",
        "description": "The name of the CDF"
      },
      {
        "type": "ref boolean",
        "name": "active",
        "description": "This indicates whether the CDF is currently marked as active. A CDF that is not yet available is never considered active."
      },
      {
        "type": "ref boolean",
        "name": "internal",
        "description": "This indicates whether the CDF is marked for internal use (which should not be shared with e.g. Business Partners)."
      }
    ],
    "returnValue": "0 Success -1 The CDF was not found",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.chart.desc": {
    "name": "tt.chart.desc",
    "type": "function",
    "syntax": "function string tt.chart.desc (string chart [, ref string desc() mb])",
    "description": "This retrieves the name of the specified chart ( chart ). It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "chart",
        "description": ""
      },
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": "The chart type."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.comp.desc": {
    "name": "tt.comp.desc",
    "type": "function",
    "syntax": "function string tt.comp.desc ( [ref string desc() mb])",
    "description": "This retrieves the name of the current company. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": "The chart type."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.company": {
    "name": "tt.company",
    "type": "function",
    "syntax": "function boolean tt.company (long company, ref string comp_desc() mb, ref string deflt_curr(), ref long first_weekday)",
    "description": "This returns information about a specified company.",
    "arguments": [
      {
        "type": "long",
        "name": "company",
        "description": "The company number."
      },
      {
        "type": "ref string",
        "name": "comp_desc() mb",
        "description": "This returns the company description."
      },
      {
        "type": "ref string",
        "name": "deflt_curr()",
        "description": "This returns a string containing the default currency of the company."
      },
      {
        "type": "ref long",
        "name": "first_weekday",
        "description": "This returns the first day of the week defined for the company in the data dictionary. The returned number is relative to Sunday(=1)"
      }
    ],
    "returnValue": "false error; company not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.currency": {
    "name": "tt.currency",
    "type": "function",
    "syntax": "function boolean tt.currency (string cur(3), ref string cur_desc() mb, ref string thous_sign, ref string dec_sign, ref string symbol())",
    "description": "This returns information about a specified currency.",
    "arguments": [
      {
        "type": "string",
        "name": "cur(3)",
        "description": "The currency code."
      },
      {
        "type": "ref string",
        "name": "cur_desc() mb",
        "description": "This returns the currency description."
      },
      {
        "type": "ref string",
        "name": "thous_sign",
        "description": "This returns the thousands sign for the specified currency."
      },
      {
        "type": "ref string",
        "name": "dec_sign",
        "description": "This returns the decimal sign for the specified currency."
      },
      {
        "type": "ref string",
        "name": "symbol()",
        "description": "This returns the currency symbol."
      }
    ],
    "returnValue": "false error; currency not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.device": {
    "name": "tt.device",
    "type": "function",
    "syntax": "function boolean tt.device (string device(9), ref string desc() mb, ref long device_type)",
    "description": "This returns information about a specified device.",
    "arguments": [
      {
        "type": "string",
        "name": "device(9)",
        "description": "The device name."
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "This returns the device description."
      },
      {
        "type": "ref long",
        "name": "device_type",
        "description": "This indicates the device type. Possible values are: 1 physical printer 2 logical printer 3 append to file 4 rewrite file 6 direct 7 display 8 Windows printer 9 Mail API 10 Windows Server Printer 11 External Reporting Services 12 Document Output Management"
      }
    ],
    "returnValue": "false error; device not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.field.desc": {
    "name": "tt.field.desc",
    "type": "function",
    "syntax": "function string tt.field.desc (string field(17), ref string desc() mb)",
    "description": "This retrieves information about a specified table field. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "field(17)",
        "description": "The field name."
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "This returns the field description in the user's current language."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.index.desc": {
    "name": "tt.index.desc",
    "type": "function",
    "syntax": "function string tt.index.desc (string tabl(8), long indexnr [, ref string desc() mb])",
    "description": "This returns information about a specified table index. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "tabl(8)",
        "description": "The table name."
      },
      {
        "type": "long",
        "name": "indexnr",
        "description": "The index number."
      },
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": "This returns the description (in the user's current language) of the specified index."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.is.domain.separated": {
    "name": "tt.is.domain.separated",
    "type": "function",
    "syntax": "function boolean tt.is.domain.separated (const string a_domain() [, ref long numberOfSeparators] [, ref string separatorCharacter()])",
    "description": "Returns whether or not a segmented domain should be printed with separators",
    "arguments": [
      {
        "type": "const string",
        "name": "a_domain()",
        "description": "The domain name."
      },
      {
        "type": "[ref long",
        "name": "numberOfSeparators ]",
        "description": "An optional long, when passed it will return the number of separator characters that are used when printing this domain."
      },
      {
        "type": "[ref string",
        "name": "separatorCharacter() ]",
        "description": "An optional string (length 1 is sufficient), when passed it will return the separator character that is used, if any."
      }
    ],
    "returnValue": "True when the domain is separated, false otherwise .",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.label.desc.by.lang": {
    "name": "tt.label.desc.by.lang",
    "type": "function",
    "syntax": "function string tt.label.desc.by.lang (string label_code(19), string language(1) [, long label_width] [, long label_height] [, domain ttadv.cont label_context])",
    "description": "Returns the label description of the specified label in the specified language.",
    "arguments": [
      {
        "type": "string",
        "name": "label_code(19)",
        "description": "The label code, including the package code."
      },
      {
        "type": "string",
        "name": "language(1)",
        "description": "The language in which the label decsription should be."
      },
      {
        "type": "[long",
        "name": "label_width ]",
        "description": "Maximum width of the label description. Default is 70."
      },
      {
        "type": "[long",
        "name": "label_height ]",
        "description": "Maximum height of the label description. Default is 1."
      },
      {
        "type": "[domain ttadv.cont",
        "name": "label_context ]",
        "description": "The label's context. The possible values are: tt.label.desc() Default is ttadv.cont.general: General Use (for labels on forms and reports)."
      }
    ],
    "returnValue": "Label description of specified label code in specified language.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.label.desc": {
    "name": "tt.label.desc",
    "type": "function",
    "syntax": "function string tt.label.desc (string label_code(19), domain ttadv.cont label_context, ref string desc)",
    "description": "This returns information of the specified label. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "label_code(19)",
        "description": "The label code, including the package code."
      },
      {
        "type": "domain ttadv.cont",
        "name": "label_context",
        "description": "The label's context. The possible values are: ttadv.cont.general: General Use (for labels on forms and reports) ttadv.cont.description: Session, Table or Report Descriptions ttadv.cont.enumerate: Enumerate descriptions ttadv.cont.indices: Index descriptions ttadv.cont.charts: Chart descriptions ttadv.cont.menus: Menu and menu field descriptions ttadv.cont.ch.opt: Chart Application Option descriptions ttadv.cont.bus.obj: Business Object descriptions ttadv.cont.sub.func: Subfunction descriptions ttadv.cont.form.cmd: Form Command descriptions ttadv.cont.external: Descriptions for External Use ttadv.cont.form.casc.menu: Cascading item on button descriptions"
      },
      {
        "type": "ref string",
        "name": "desc",
        "description": "This returns the longest description (in the user's current language) of the specified label."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.langdesc": {
    "name": "tt.langdesc",
    "type": "function",
    "syntax": "function boolean tt.langdesc (string language, ref string desc() mb)",
    "description": "",
    "arguments": [
      {
        "type": "string",
        "name": "language",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": ""
      }
    ],
    "returnValue": "false error; language not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.language": {
    "name": "tt.language",
    "type": "function",
    "syntax": "function boolean tt.language (string lang, ref string desc() mb, ref string dec_sign, ref string thous_sign, ref string date_sep, ref string time_sep)",
    "description": "This returns information about a specified language.",
    "arguments": [
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which you want to retrieve information."
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "This returns the language description."
      },
      {
        "type": "ref string",
        "name": "dec_sign",
        "description": "This returns the decimal sign defined for the language."
      },
      {
        "type": "ref string",
        "name": "thous_sign",
        "description": "This returns the thousands sign defined for the language."
      },
      {
        "type": "ref string",
        "name": "date_sep",
        "description": "This returns the date separator defined for the language."
      },
      {
        "type": "ref string",
        "name": "time_sep",
        "description": "This returns the time separator defined for the language."
      }
    ],
    "returnValue": "false error; language not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.languages": {
    "name": "tt.languages",
    "type": "function",
    "syntax": "function boolean tt.languages (boolean isolanguagecodes, ref long languages)",
    "description": "This returns information about all available LN software languages.",
    "arguments": [
      {
        "type": "boolean",
        "name": "isolanguagecodes",
        "description": "If the iso codes for the languages (lowercase language - uppercase country) should be included."
      },
      {
        "type": "ref long",
        "name": "languages",
        "description": "This returns all available LN software languages in XML format. The returned structure looks like: <Languages> <Language> <LanguageCode>1</LanguageCode> <Description>Nederlands</Description> <IsoCode>nl-NL</IsoCode> </Language> <Language> <LanguageCode>2</LanguageCode> <Description>English</Description> <IsoCode>en-US</IsoCode> </Language> <Language> <LanguageCode>3</LanguageCode> <Description>Deutsch</Description> <IsoCode>de-DE</IsoCode> </Language> </Languages> If isolanguagecodes is set to false, the IsoCode elements are not included."
      }
    ],
    "returnValue": "false error; no languages found true success; languages found",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.library": {
    "name": "tt.library",
    "type": "function",
    "syntax": "function boolean tt.library (string library.code, ref string library.desc() mb)",
    "description": "",
    "arguments": [
      {
        "type": "string",
        "name": "library.code",
        "description": "The library code."
      },
      {
        "type": "ref string",
        "name": "library.desc() mb",
        "description": "This returns the library description."
      }
    ],
    "returnValue": "false error; library not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.menu.desc": {
    "name": "tt.menu.desc",
    "type": "function",
    "syntax": "function string tt.menu.desc (string menu(13), string par_menu [, ref string desc() mb])",
    "description": "This returns information about a specified menu. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "menu(13)",
        "description": "The menu name."
      },
      {
        "type": "string",
        "name": "par_menu",
        "description": "In the case of parallel menus, specify the menu sequence number here. Otherwise, enter 1."
      },
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": "This returns the description (in the user's current language) of the specified menu."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.menu.present": {
    "name": "tt.menu.present",
    "type": "function",
    "syntax": "function boolean tt.menu.present (string menu(13), string par_menu)",
    "description": "This checks if the specified menu of the current package is present in the runtime dictionary.",
    "arguments": [
      {
        "type": "string",
        "name": "menu(13)",
        "description": "The menu name."
      },
      {
        "type": "string",
        "name": "par_menu",
        "description": "In the case of parallel menus, specify the menu sequence number here. Otherwise, enter 1."
      }
    ],
    "returnValue": "false error; menu not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.report.desc": {
    "name": "tt.report.desc",
    "type": "function",
    "syntax": "function string tt.report.desc (string reprt(15) [, ref string desc() mb])",
    "description": "This retrieves the description (in the user's current language) of a specified report ( reprt ). It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "reprt(15)",
        "description": ""
      },
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": ""
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.reportgroup.exists": {
    "name": "tt.reportgroup.exists",
    "type": "function",
    "syntax": "function boolean tt.reportgroup.exists (string session(13), long report_group)",
    "description": "This checks if a specified report group ( report_group ) is present in the definition of the specified session ( session ).",
    "arguments": [
      {
        "type": "string",
        "name": "session(13)",
        "description": ""
      },
      {
        "type": "long",
        "name": "report_group",
        "description": ""
      }
    ],
    "returnValue": "TRUE report group exists FALSE report group does not exist",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.session.desc": {
    "name": "tt.session.desc",
    "type": "function",
    "syntax": "function string tt.session.desc (string session(13) [, ref string desc() mb] [, string language])",
    "description": "This retrieves the description of a specified session ( session ). It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "session(13)",
        "description": ""
      },
      {
        "type": "[ref string",
        "name": "desc() mb ]",
        "description": ""
      },
      {
        "type": "[string",
        "name": "language ]",
        "description": ""
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.session.present": {
    "name": "tt.session.present",
    "type": "function",
    "syntax": "function long tt.session.present (string session(13))",
    "description": "This checks if the specified session is present in the runtime dictionary.",
    "arguments": [
      {
        "type": "string",
        "name": "session(13)",
        "description": ""
      }
    ],
    "returnValue": "0 session not present 1 session present but not in the user configuration 2 session present and in the configuration of the user",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.short.field.desc": {
    "name": "tt.short.field.desc",
    "type": "function",
    "syntax": "function string tt.short.field.desc (string field(17), long length, ref string desc() mb)",
    "description": "This returns the description (in the user's current language) of a specified table field. It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "field(17)",
        "description": "The field name."
      },
      {
        "type": "long",
        "name": "length",
        "description": "The number of characters of the description that must be returned."
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "This returns the field description. Only the first length characters of the description are returned."
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.table.desc": {
    "name": "tt.table.desc",
    "type": "function",
    "syntax": "function string tt.table.desc (string table(8), ref string desc() mb)",
    "description": "This retrieves the description (in the user's current language) of a specified table ( table ). It is returned, and optionally also stored in the desc argument. (The optional argument is only present for backward compatibility.)",
    "arguments": [
      {
        "type": "string",
        "name": "table(8)",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": ""
      }
    ],
    "returnValue": "The description is returned.",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.user.data": {
    "name": "tt.user.data",
    "type": "function",
    "syntax": "function boolean tt.user.data (string user(12), long property, ...)",
    "description": "This function retrieves one or more properties of an Infor LN user.",
    "arguments": [
      {
        "type": "string",
        "name": "user(12)",
        "description": ""
      },
      {
        "type": "long",
        "name": "property",
        "description": "After the 'user', one or more pairs follow, with property (long) and value (ref): Property"
      }
    ],
    "returnValue": "false error; user not found or invalid input true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.user": {
    "name": "tt.user",
    "type": "function",
    "syntax": "function boolean tt.user (string user(12), ref string name() mb)",
    "description": "This retrieves the name of the specified user ( user ) and stores it in the name argument.",
    "arguments": [
      {
        "type": "string",
        "name": "user(12)",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "name() mb",
        "description": ""
      }
    ],
    "returnValue": "false error; user not found true success",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.chm.appl.desc": {
    "name": "tt.chm.appl.desc",
    "type": "function",
    "syntax": "function long tt.chm.appl.desc (string appl(40), ref string desc() mb)",
    "description": "This retrieves the description (in the user's current language) of a specified Chart Manager application.",
    "arguments": [
      {
        "type": "string",
        "name": "appl(40)",
        "description": "The name of the Chart Manager application. This takes the form: ppmmxxxx , where pp is the package code, mmm is the module code, and xxx is the name of the Chart Manager application. This argument must refer to a record in the Maintain Chart Manager Application Data session (ttchm1500m000)."
      },
      {
        "type": "ref string",
        "name": "desc() mb",
        "description": "This returns the description of the specified Chart manager application."
      }
    ],
    "returnValue": "0 success 1 error; application not found",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.chm.application": {
    "name": "tt.chm.application",
    "type": "function",
    "syntax": "function boolean tt.chm.application (string appl)",
    "description": "This checks if the specified Chart Manager application is present in the runtime dictionary.",
    "arguments": [
      {
        "type": "string",
        "name": "appl",
        "description": "The name of the Chart Manager application. This takes the form: ppmmxxxx , where pp is the package code, mmm is the module code, and xxx is the name of the Chart Manager application. This argument must refer to a record in the Maintain Chart Manager Application Data session (ttchm1500m000)."
      }
    ],
    "returnValue": "false application not found true application found",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.chm.chart": {
    "name": "tt.chm.chart",
    "type": "function",
    "syntax": "function boolean tt.chm.chart (string appl(40), string chart_name(16))",
    "description": "This checks if the specified chart is present in the specified Chart Manager application.",
    "arguments": [
      {
        "type": "string",
        "name": "appl(40)",
        "description": "The name of the Chart Manager application. This takes the form: ppmmxxxx , where pp is the package code, mmm is the module code, and xxx is the name of the Chart Manager application. This argument must refer to a record in the Maintain Chart Manager Application Data session (ttchm1500m000)."
      },
      {
        "type": "string",
        "name": "chart_name(16)",
        "description": "The name of the chart."
      }
    ],
    "returnValue": "false success true error; chart or application not found",
    "category": "functions_runtime_dictionary_information"
  },
  "tt.chm.charttype": {
    "name": "tt.chm.charttype",
    "type": "function",
    "syntax": "function boolean tt.chm.charttype (string appl(40), string chart_type(16))",
    "description": "This checks if the specified chart type is present in the specified Chart Manager application.",
    "arguments": [
      {
        "type": "string",
        "name": "appl(40)",
        "description": "The name of the Chart Manager application. This takes the form: ppmmxxxx , where pp is the package code, mmm is the module code, and xxx is the name of the Chart Manager application. This argument must refer to a record in the Maintain Chart Manager Application Data session (ttchm1500m000)."
      },
      {
        "type": "string",
        "name": "chart_type(16)",
        "description": "The chart type."
      }
    ],
    "returnValue": "false success true error; chart type or application not found",
    "category": "functions_runtime_dictionary_information"
  },
  "table searching and sorting sample programs": {
    "name": "Table searching and sorting sample programs",
    "type": "function",
    "syntax": "function Table searching and sorting sample programs()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_searching_sorting_data"
  },
  "searching and sorting data overview and synopsis": {
    "name": "Searching and sorting data overview and synopsis",
    "type": "function",
    "syntax": "function Searching and sorting data overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_searching_sorting_data"
  },
  "qss.search": {
    "name": "qss.search",
    "type": "function",
    "syntax": "function long qss.search (long flag, void search, ref void array, ref long def [, long dept])",
    "description": "This searches a specified array for a particular value, which is referred to as the search key. By default, it reads the array sequentially until it finds the specified value (that is, it performs a linear search). To perform a binary search instead, you must first sort the data, for example with qss.sort() and then call qss.search() with the flag argument set to QSS.SRC.IS.SORTED. If the same search key occurs more than once, then you should also specify the QSS.SRC.DUPL.ALLOWED option, or else it is not predictable which one of the duplicate records is found.",
    "arguments": [
      {
        "type": "long",
        "name": "flag",
        "description": "This specifies which array element is to be retrieved and the type of search to be performed. You can set the argument to one of the following possible values: QSS.FIRST Find the first record in the array; the search argument is ignored."
      }
    ],
    "returnValue": ">0 index in the array where the search key was found -1 error; search argument not found -11 search argument must be of same type as array; def is not of type long array or array not of type array -12 search argument not correct; string not expected -13 dept must be positive -14 def argument not correctly declared -15 search argument does not fit in declared array -16 QSS.TYPE not correct -17 array argument not correct -18 no definition found in def -21 flag LOOKUP.FOR.STRUCT is used; search argument must be a string -22 search argument not correct; probably a size problem - size of search must match size of an element in array if LOOKUP.FOR.STRUCT is set or (if LOOKUP.FOR.STRUCT is not set) must be at least the sum of lengths of the key fields (set by qss.length()) -23 search argument not correct; probably a type problem",
    "category": "functions_searching_sorting_data"
  },
  "qss.sort": {
    "name": "qss.sort",
    "type": "function",
    "syntax": "function long qss.sort (ref void array, ref long def [, long dept])",
    "description": "This function performs a fast sort of a specified array.",
    "arguments": [
      {
        "type": "ref void",
        "name": "array",
        "description": "The name of the array to be sorted."
      },
      {
        "type": "ref long",
        "name": "def",
        "description": "This determines how the array is to be sorted. The argument must be declared as follows: long def(x,4) | x is the number of sort fields You can define several sort fields (1 to x ). When performing a sort, the system sorts on the first sort field. Then, if there are duplicate values in the first sort field, the system sorts on the second sort field, and so on. For each sort field, you define the four sort properties by using the following functions. In each case, the field_number argument specifies the sequence number (1 to x ) of the sort field. void qss.start( ref long def, long field_number, long position ) This specifies the start position of the sort field in the array elements."
      }
    ],
    "returnValue": "0 success -1 error, array and/or def is empty -11 def is not of type long array or array not of type array -12 array of strings must have > 1 dimension -13 dept must be positive -14 def argument not correctly declared -15 def size exceeds array size -16 QSS.TYPE not correct -17 array argument not correct -18 no definition found in def",
    "category": "functions_searching_sorting_data"
  },
  "create.extra.toolbar": {
    "name": "create.extra.toolbar",
    "type": "function",
    "syntax": "function long create.extra.toolbar (string form_command, string gif_file [, string form_command] [, string gif_file])",
    "description": "This adds a secondary toolbar to a session.",
    "arguments": [
      {
        "type": "string",
        "name": "form_command",
        "description": ""
      },
      {
        "type": "string",
        "name": "gif_file",
        "description": ""
      },
      {
        "type": "[string",
        "name": "form_command ]",
        "description": ""
      },
      {
        "type": "[string",
        "name": "gif_file ]",
        "description": ""
      }
    ],
    "returnValue": ">0 success 0 toolbar not allowed in this type of session -1 incorrect number of arguments",
    "category": "functions_secondary_toolbars"
  },
  "secondary toolbars overview and synopsis": {
    "name": "Secondary toolbars overview and synopsis",
    "type": "function",
    "syntax": "function Secondary toolbars overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_secondary_toolbars"
  },
  "improved record selection cookbook": {
    "name": "Improved Record selection Cookbook",
    "type": "function",
    "syntax": "function Improved Record selection Cookbook()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_selection"
  },
  "do.parent.selection": {
    "name": "do.parent.selection",
    "type": "function",
    "syntax": "function void do.parent.selection (long function_name [, ...])",
    "description": "This function can be used to process records selected in a parent session. For example: in a print session only print the records that are selected in the parent.",
    "arguments": [
      {
        "type": "long",
        "name": "function_name",
        "description": "The name of the function that must be executed for each marked occurrence. The function must be of type long."
      },
      {
        "type": "[",
        "name": "... ]",
        "description": "Use these optional arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "",
    "category": "functions_selection"
  },
  "ncrs.is.session.empty": {
    "name": "ncrs.is.session.empty",
    "type": "function",
    "syntax": "function boolean ncrs.is.session.empty ()",
    "description": "This function can be used in a print or a processing session in an init.form section. The function can be used to decide whether the functional default command should be triggered. Possible the default command is another one, than the command that actually trigges the wanted functionality. The function tells whether the session has no fields left, because the selection group has been made invisible.",
    "arguments": [],
    "returnValue": "TRUE No fields are left, session won't be shown FALSE Session will be shown",
    "category": "functions_selection"
  },
  "record selection overview": {
    "name": "Record selection Overview",
    "type": "function",
    "syntax": "function Record selection Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_selection"
  },
  "sel.add.parent.tables": {
    "name": "sel.add.parent.tables",
    "type": "function",
    "syntax": "function boolean sel.add.parent.tables (long group_id, string parent_table)",
    "description": "In the Dynamic Form Editor you can already indicate the main table of the parent session for which a session can handle the selection. You should specify that table at the \"selection range group\" in which the user can specify the range if the selection of the parent session is not used. Because you can only specify one table per group, you need to use this function if you want to add one or more extra tables to a group.",
    "arguments": [
      {
        "type": "long",
        "name": "group_id",
        "description": "The number of the group for which you want to add a table. The number can be found in the Dynamic Form Editor"
      },
      {
        "type": "string",
        "name": "parent_table",
        "description": "The table code (e.g. tccom100) of which you need to process records."
      }
    ],
    "returnValue": "true Tables are added for the group with the specified number. false The supplied arguments are not of the right type, or the group with the specified number doesn't exist.",
    "category": "functions_selection"
  },
  "sel.num.selected": {
    "name": "sel.num.selected",
    "type": "function",
    "syntax": "function long sel.num.selected ()",
    "description": "This function returns the number of records that is selected in the session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_selection"
  },
  "sel.parent.num.selected": {
    "name": "sel.parent.num.selected",
    "type": "function",
    "syntax": "function long sel.parent.num.selected ()",
    "description": "This function returns the number of records that is selected in the parent of the current session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_selection"
  },
  "sel.use.parent.selection": {
    "name": "sel.use.parent.selection",
    "type": "function",
    "syntax": "function boolean sel.use.parent.selection (string parent_table)",
    "description": "This function can be used in a print or a processing session to determine whether to user wants to print/process based on a selection range, or based on the selection that is made in the parent. If the user wants to use the selection of the parent, you should use the function do.parent.selection() to get the selection. The user can indicate his choice with an optionset. Read below how to create that option set.",
    "arguments": [
      {
        "type": "string",
        "name": "parent_table",
        "description": "The table code (e.g. tccom100) of which you need to process records."
      }
    ],
    "returnValue": "true User wants to use the selection of the given table. (This also means that the parent session has the given table as maintable.) false User wants to specify a custom range.",
    "category": "functions_selection"
  },
  "record selection synopsis": {
    "name": "Record selection Synopsis",
    "type": "function",
    "syntax": "function Record selection Synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_selection"
  },
  "sha.add.data": {
    "name": "sha.add.data",
    "type": "function",
    "syntax": "function void sha.add.data (long id, string data.in)",
    "description": "Adds one block of data to be hashed. It is not needed to supply all input data at once in one large block. Sha.add.data() may be called several times with relatively small blocks. Internally, the SHA-1 algorithm processes the input in 512 bit blocks, i.e. 64 byte at a time.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "Id of the Secure Hash Algorithm state, allocated by sha.create() ."
      },
      {
        "type": "string",
        "name": "data.in",
        "description": "String with input data."
      }
    ],
    "returnValue": "",
    "category": "functions_sha"
  },
  "sha.compute.output": {
    "name": "sha.compute.output",
    "type": "function",
    "syntax": "function long sha.compute.output (long id, ref string data.out)",
    "description": "Adds some padding and a bit count to the message, as prescibed in the standard, and computes the resulting message digest. After this, the Secure Hash Algorithm state may be reused for hashing another message, by calling sha.initialize() , sha.add.data() , and sha.compute.output() again.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "Id of the Secure Hash Algorithm state, allocated by sha.create() ."
      },
      {
        "type": "ref string",
        "name": "data.out",
        "description": "String which will receive the Secure Hash Algorithm output."
      }
    ],
    "returnValue": "The size of the Secure Hash Algorithm output is returned. If this value is greater than the size of data.out, then no output at all is written to data.out, and sha.compute.output() may be called again with a larger output buffer. The size of the Secure Hash Algorithm output is in all cases 20 bytes.",
    "category": "functions_sha"
  },
  "sha.create": {
    "name": "sha.create",
    "type": "function",
    "syntax": "function long sha.create ()",
    "description": "Allocates memory to contain the state of the Secure Hash Algorithm.",
    "arguments": [],
    "returnValue": "An Id corresponding to the allocated state is returned. This Id can be used in subsequent calls to sha.initialize() , sha.add.data() , and sha.compute.output() . The returned Id can only be used in the original BAAN process where sha.create was called, and is useless in other BAAN processes in the same bshell. The allocated memory is freed explicitly by passing the Id to sha.destroy() . The allocated memory is freed implicitly when the BAAN process exits. Any number of Secure Hash Algorithm states may be in use concurrently.",
    "category": "functions_sha"
  },
  "sha.destroy": {
    "name": "sha.destroy",
    "type": "function",
    "syntax": "function void sha.destroy (long id)",
    "description": "Destroys the Secure Hash Algorithm state.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "Id of the Secure Hash Algorithm state, allocated by sha.create() ."
      }
    ],
    "returnValue": "",
    "category": "functions_sha"
  },
  "sha.initialize": {
    "name": "sha.initialize",
    "type": "function",
    "syntax": "function void sha.initialize (long id)",
    "description": "Initializes the state of the Secure Hash Algorithm.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "Id of the Secure Hash Algorithm state, allocated by sha.create() ."
      }
    ],
    "returnValue": "",
    "category": "functions_sha"
  },
  "secure hash algorithm overview": {
    "name": "Secure Hash Algorithm overview",
    "type": "function",
    "syntax": "function Secure Hash Algorithm overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sha"
  },
  "secure hash algorithm synopsis": {
    "name": "Secure Hash Algorithm synopsis",
    "type": "function",
    "syntax": "function Secure Hash Algorithm synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sha"
  },
  "soap client overview": {
    "name": "SOAP client overview",
    "type": "function",
    "syntax": "function SOAP client overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_soap"
  },
  "soap.addheader": {
    "name": "soap.addHeader",
    "type": "function",
    "syntax": "function void soap.addHeader (long soapMessage, long method)",
    "description": "Adds the specified Header Element to the Header of the SOAP Envelope of the given SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to the SOAP Message to add the specified header to"
      },
      {
        "type": "long",
        "name": "method",
        "description": "a handle to the Header Element which must be added to the SOAP Envelope of the given SOAP message"
      }
    ],
    "returnValue": "",
    "category": "functions_soap"
  },
  "soap.addmethod": {
    "name": "soap.addMethod",
    "type": "function",
    "syntax": "function void soap.addMethod (long soapMessage, long method)",
    "description": "Adds the specified Method to the Body of the SOAP Envelope of the given SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to the SOAP Message to add the specified Method to"
      },
      {
        "type": "long",
        "name": "method",
        "description": "a handle to the Method to add to the SOAP Envelope of the given SOAP message"
      }
    ],
    "returnValue": "",
    "category": "functions_soap"
  },
  "soap.deletemessage": {
    "name": "soap.deleteMessage",
    "type": "function",
    "syntax": "function void soap.deleteMessage (ref long soapMessage)",
    "description": "Deletes the specified SOAP Message from memory, including all contained data. When the SOAP Message contains a SOAP Envelope, the SOAP Envelope is deleted as well. The passed soapMessage handle is set to 0 on return.",
    "arguments": [
      {
        "type": "ref long",
        "name": "soapMessage",
        "description": "a handle to the SOAP Message to delete; is set to 0 on return"
      }
    ],
    "returnValue": "",
    "category": "functions_soap"
  },
  "soap.getbody": {
    "name": "soap.getBody",
    "type": "function",
    "syntax": "function long soap.getBody (long soapMessage)",
    "description": "Returns the Body of the SOAP Envelope of the given SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      }
    ],
    "returnValue": "<> 0 a handle to the SOAP Body 0 when the SOAP Body is not found",
    "category": "functions_soap"
  },
  "soap.getenvelope": {
    "name": "soap.getEnvelope",
    "type": "function",
    "syntax": "function long soap.getEnvelope (long soapMessage)",
    "description": "Returns the SOAP Envelope of the given SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      }
    ],
    "returnValue": "<> 0 a handle to the SOAP Envelope 0 when the SOAP Envelope is not found",
    "category": "functions_soap"
  },
  "soap.getfault": {
    "name": "soap.getFault",
    "type": "function",
    "syntax": "function long soap.getFault (long soapMessage)",
    "description": "Returns the Fault which is contained in the Body of the SOAP Envelope of the specified SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      }
    ],
    "returnValue": "<> 0 a handle to the Fault 0 when the Fault is not found",
    "category": "functions_soap"
  },
  "soap.getheader": {
    "name": "soap.getHeader",
    "type": "function",
    "syntax": "function long soap.getHeader (long soapMessage)",
    "description": "Returns the Header of the SOAP Envelope of the given SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      }
    ],
    "returnValue": "<> 0 a handle to the SOAP Header 0 when the SOAP Header is not found",
    "category": "functions_soap"
  },
  "soap.getmethod": {
    "name": "soap.getMethod",
    "type": "function",
    "syntax": "function long soap.getMethod (long soapMessage)",
    "description": "Returns the Method which is contained in the Body of the SOAP Envelope of the specified SOAP message.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      }
    ],
    "returnValue": "<> 0 a handle to the Method 0 when the Method is not found",
    "category": "functions_soap"
  },
  "soap.init": {
    "name": "soap.init",
    "type": "function",
    "syntax": "function long soap.init ()",
    "description": "Initializes the SOAP client.",
    "arguments": [],
    "returnValue": "0 On success <> 0 In case of an error",
    "category": "functions_soap"
  },
  "soap.invoke": {
    "name": "soap.invoke",
    "type": "function",
    "syntax": "function long soap.invoke (long soapMessage, const string url, ref long responseMessage)",
    "description": "Invokes a SOAP request as specified by the given SOAP Message. The request is sent to a SOAP service which is identified by the specified url. On return the response SOAP Message is returned in the responseMessage argument.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to the SOAP Message containing a SOAP Envelope describing the SOAP request"
      },
      {
        "type": "const string",
        "name": "url",
        "description": "the url to sent the SOAP request to"
      },
      {
        "type": "ref long",
        "name": "responseMessage",
        "description": "on return this will contain the returned SOAP response message; note that this SOAP Message must be deleted with soap.deleteMessage() when it is no longer needed"
      }
    ],
    "returnValue": "0 when communication with the SOAP service was succesfull <> 0 in case of a communication error with the SOAP service Note that in case 0 is returned the response SOAP Envelope can still contain a Fault node, describing either a client or a server side error.",
    "category": "functions_soap"
  },
  "soap.newmessage": {
    "name": "soap.newMessage",
    "type": "function",
    "syntax": "function long soap.newMessage (const string soapNsURI)",
    "description": "Creates a new SOAP Message, including a new SOAP Envelope and returns a handle to the new SOAP Message. The new SOAP Envelope will be created based on the specified SOAP namespace URI.",
    "arguments": [
      {
        "type": "const string",
        "name": "soapNsURI",
        "description": "the soap namespace URI; use URI_SOAP11 for a SOAP 1.1 Envelope; use URI_SOAP12 for a SOAP 1.2 Envelope."
      }
    ],
    "returnValue": "<> 0 a handle to the created SOAP Message object; this SOAP Message contains the created SOAP Envelope XML document 0 in case of an error",
    "category": "functions_soap"
  },
  "soap.setaction": {
    "name": "soap.setAction",
    "type": "function",
    "syntax": "function void soap.setAction (long soapMessage, const string soapAction)",
    "description": "Sets the SOAP Action of the specified SOAP Message. This action is sent together with the the SOAP Envelope to the SOAP service.",
    "arguments": [
      {
        "type": "long",
        "name": "soapMessage",
        "description": "a handle to a SOAP Message"
      },
      {
        "type": "const string",
        "name": "soapAction",
        "description": "a string containing the SOAP action; often a (part of a) URL"
      }
    ],
    "returnValue": "",
    "category": "functions_soap"
  },
  "soap client synopsis": {
    "name": "SOAP client synopsis",
    "type": "function",
    "syntax": "function SOAP client synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_soap"
  },
  "spooling overview and synopsis": {
    "name": "Spooling overview and synopsis",
    "type": "function",
    "syntax": "function Spooling overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_spooling"
  },
  "spool.buf": {
    "name": "spool.buf",
    "type": "function",
    "syntax": "function void spool.buf (const string buffer, long length)",
    "description": "This sends the contents of the buffer argument to the current spooler. The current spooler must be already open. The name of the current spooler is available in the predefined variable spool.id .",
    "arguments": [
      {
        "type": "const string",
        "name": "buffer",
        "description": ""
      },
      {
        "type": "long",
        "name": "length",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_spooling"
  },
  "spool.close": {
    "name": "spool.close",
    "type": "function",
    "syntax": "function void spool.close ()",
    "description": "This closes the spooler specified by the predefined variable spool.id . By default spool.id contains the ID of the current spooler. If more than one spooler is currently open, set spool.id to the ID of the required spooler before you call this function. After the spooler is closed, spool.id is set to zero.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_spooling"
  },
  "spool.line": {
    "name": "spool.line",
    "type": "function",
    "syntax": "function void spool.line ()",
    "description": "This sends the contents of the predefined variable spool.pr.line and a newline character to the spooler specified by the predefined variable spool.id . By default spool.id contains the ID of the current spooler. If more than one spooler is currently open, set spool.id to the ID of the required spooler before you call this function. After this function has been executed, spool.pr.line is cleared.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_spooling"
  },
  "spool.open": {
    "name": "spool.open",
    "type": "function",
    "syntax": "function long spool.open (string reportname, string device, string mode)",
    "description": "This opens a specified spooler device.",
    "arguments": [
      {
        "type": "string",
        "name": "reportname",
        "description": "If you specify a report name in the reportname argument, it is stored in the predefined variable spool.report , and the current date and time are stored in the predefined variables spool.date and spool.time . The settings for the predefined variables spool.fontnumber , spool.paper.type , and spool.left.mrg are taken from the default settings for the specified report. If both reportname and device are specified, the defaults for the predefined variables are taken from the default settings for the specified report. The device name is stored in spool.device . If both reportname and device are empty (\"\"), the predefined variables retain their values from the previous spool action."
      },
      {
        "type": "string",
        "name": "device",
        "description": "If you specify a device name in the device argument, it is stored in the predefined variable spool.device . The settings for the predefined variables spool.paper.type , spool.left.mrg , spool.fileout , and spool.pg.length are taken from the default settings for the specified device."
      },
      {
        "type": "string",
        "name": "mode",
        "description": "This determines whether or not a window is displayed where the user can change the device settings: 0 no window displayed 1 window displayed with a Cancel button 2 window displayed without a Cancel button"
      }
    ],
    "returnValue": "0 spooler cannot be opened >0 ID of opened spooler � this is also available in spool.id",
    "category": "functions_spooling"
  },
  "spool.restore.variables": {
    "name": "spool.restore.variables",
    "type": "function",
    "syntax": "function boolean spool.restore.variables ( [long brp.id])",
    "description": "This function sets the predefined spool variables to the values they had when the spooler was opened. If the optional argument is not specified, this function uses the predefined variable spool.id to look up the spooler to use.",
    "arguments": [
      {
        "type": "[long",
        "name": "brp.id ]",
        "description": "Optional, use this to restore the variables using a report id instead of spooler id."
      }
    ],
    "returnValue": "true if the spooler was found and the variables are restored, false otherwise.",
    "category": "functions_spooling"
  },
  "clear.query.extend.in.zoom": {
    "name": "clear.query.extend.in.zoom",
    "type": "function",
    "syntax": "function void clear.query.extend.in.zoom ()",
    "description": "This clears a query extension that was previously defined in the selection.filter section. The 4GL engine automatically clears the extension in the after.zoom section of the session. Use this function to force an earlier removal of the query extension. For example, to clear the query extension before defining an extension for another zoom session.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "column filtering": {
    "name": "Column filtering",
    "type": "function",
    "syntax": "function Column filtering()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query extensions sample program": {
    "name": "Query extensions sample program",
    "type": "function",
    "syntax": "function Query extensions sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "sql query extensions overview": {
    "name": "SQL query extensions overview",
    "type": "function",
    "syntax": "function SQL query extensions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.define.sort.order": {
    "name": "query.define.sort.order",
    "type": "function",
    "syntax": "function long query.define.sort.order (long table.index, const string field.var, direction.var [, const string ..., ...])",
    "description": "With this function the direction of an index-field or the whole index of an table-index can be set.",
    "arguments": [
      {
        "type": "long",
        "name": "table.index",
        "description": "Sequence number of the referenced table-index."
      },
      {
        "type": "const string",
        "name": "field.var, direction.var",
        "description": "field order direction set For each set, specify the order direction with the name of the relevant field and it's direction of sorting field.var: 1) Field must exist in the table index by parameter table.index or 2) the whole of the referenced table-index with name: file _index< number > field.var equals indexname cannot combined with another field.var. direction.var: Presentation direction, possible values direction \"ASC\" or \"DESC\"."
      },
      {
        "type": "[const string",
        "name": "..., ... ]",
        "description": "next pair of [field.var, direction.var]. Use these optional pair of arguments to pass one or more arguments to the specified function. Use commas (,) to separate the arguments."
      }
    ],
    "returnValue": "0 Success. -n Negative value of the parameter with the wrong value. -9999 Too many parameters. The input exceeds the maximum number of index parts.",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.fld.from": {
    "name": "query.extend.fld.from",
    "type": "function",
    "syntax": "function long query.extend.fld.from (string select_column, string extension_string)",
    "description": "With the query.extend.fld� interface the metadata is stored in the 4gl engine. The query.extend.fld� information is used to build the standard query for retrieving requested data, inclusive the application fields. The result is used for the display of the field. The value of easy filter on the application field and the query.extend.fld� information is used to extend the WHERE clause of the standard query. The standard query is used to display the session.",
    "arguments": [
      {
        "type": "string",
        "name": "select_column",
        "description": "Name of the form field in the form."
      },
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the names of the tables to be included in the FROM statement. Use commas [,] to separate the table names."
      }
    ],
    "returnValue": "0 On success. <> 0 error",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.fld.select": {
    "name": "query.extend.fld.select",
    "type": "function",
    "syntax": "function long query.extend.fld.select (string select_column, string select_expression)",
    "description": "With the query.extend.fld� interface the metadata is stored in the 4gl engine. The query.extend.fld� information is used to build the standard query for retrieving requested data, inclusive the application fields. The result is used for the display of the field. The value of easy filter on the application field and the query.extend.fld� information is used to extend the WHERE clause of the standard query. The standard query is used to display the session.",
    "arguments": [
      {
        "type": "string",
        "name": "select_column",
        "description": "Name of the form field in the form."
      },
      {
        "type": "string",
        "name": "select_expression",
        "description": "SQL instruction for SELECT clause."
      }
    ],
    "returnValue": "0 On success. <> 0 error",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.fld.where": {
    "name": "query.extend.fld.where",
    "type": "function",
    "syntax": "function long query.extend.fld.where (string select_column, string where_condition)",
    "description": "With the query.extend.fld� interface the metadata is stored in the 4gl engine. The query.extend.fld� information is used to build the standard query for retrieving requested data, inclusive the application fields. The result is used for the display of the field. The value of easy filter on the application field and the query.extend.fld� information is used to extend the WHERE clause of the standard query. The standard query is used to display the session.",
    "arguments": [
      {
        "type": "string",
        "name": "select_column",
        "description": "Name of the form field in the form."
      },
      {
        "type": "string",
        "name": "where_condition",
        "description": "SQL instruction for WHERE clause."
      }
    ],
    "returnValue": "0 On success. <> 0 error",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.from": {
    "name": "query.extend.from",
    "type": "function",
    "syntax": "function void query.extend.from (string extension_string [, long mode])",
    "description": "Use this to construct a query extension for the FROM clause of a database query. Use this function for non-zoom sessions. Use query.extend.from.in.zoom() for defining query filters for zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the names of the tables to be included in the FROM statement. Use commas [,] to separate the table names."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This optional argument can have one of the following values: EXTEND_OVERWRITE replaces any existing query extension (this is the default mode)"
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.from.in.zoom": {
    "name": "query.extend.from.in.zoom",
    "type": "function",
    "syntax": "function void query.extend.from.in.zoom (string extension_string)",
    "description": "Use this to construct a query extension for the FROM clause of a database query. Use this function for zoom sessions. Use query.extend.from() for defining query filters in non-zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the names of the tables to be included in the FROM statement. Use commas [,] to separate the tables names."
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.hint": {
    "name": "query.extend.hint",
    "type": "function",
    "syntax": "function void query.extend.hint (string extension_string [, long mode])",
    "description": "Use this to construct a query extension for the HINT clause of a database query. Use this function for non-zoom sessions. Use query.extend.hint.in.zoom() for defining query filters for zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the hints to be included in the HINT statement."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This optional argument can have one of the following values: EXTEND_OVERWRITE replaces any existing query extension (this is the default mode)"
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.hint.in.zoom": {
    "name": "query.extend.hint.in.zoom",
    "type": "function",
    "syntax": "function void query.extend.hint.in.zoom (string extension_string)",
    "description": "Use this to construct a query extension for the HINT clause of a database query. Use this function for zoom sessions. Use query.extend.hint() for defining query filters in non-zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the hint to be included in the HINT statement."
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.select": {
    "name": "query.extend.select",
    "type": "function",
    "syntax": "function void query.extend.select (string extension_string [, long mode])",
    "description": "Use this to construct a query extension for the SELECT clause of a database query. Use this function for non-zoom sessions. Use query.extend.select.in.zoom() for defining query filters for zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the names of the fields to be included in the SELECT statement. Use commas [,] to separate the field names."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This optional argument can have one of the following values: EXTEND_OVERWRITE replaces any existing query extension (this is the default mode)"
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.select.in.zoom": {
    "name": "query.extend.select.in.zoom",
    "type": "function",
    "syntax": "function void query.extend.select.in.zoom (string extension_string)",
    "description": "Use this to construct a query extension for the SELECT clause of a database query. Use this function for zoom sessions. Use query.extend.select() for defining query filters in non-zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing the names of the fields to be included in the SELECT statement. Use commas [,] to separate the field names."
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.where": {
    "name": "query.extend.where",
    "type": "function",
    "syntax": "function void query.extend.where (string extension_string [, long mode])",
    "description": "Use this to construct a query extension for the WHERE clause of a database query. Use this function for non-zoom sessions. Use query.extend.where.in.zoom() for defining query filters for zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing conditions to be included in the WHERE statement."
      },
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This optional argument can have one of the following values: EXTEND_OVERWRITE replaces any existing query extension (this is the default mode)"
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "query.extend.where.in.zoom": {
    "name": "query.extend.where.in.zoom",
    "type": "function",
    "syntax": "function void query.extend.where.in.zoom (string extension_string)",
    "description": "Use this to construct a query extension for the WHERE clause of a database query. Use this function for zoom sessions. Use query.extend.where() for defining query filters in non-zoom sessions.",
    "arguments": [
      {
        "type": "string",
        "name": "extension_string",
        "description": "A string containing conditions to be included in the WHERE statement."
      }
    ],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "rebuild.query": {
    "name": "rebuild.query",
    "type": "function",
    "syntax": "function void rebuild.query ()",
    "description": "Use this function to rebuild a query. If the query.extend functions are used the default query should be rebuild. This is done automatically after the before.program and the before.open.object.set sections. If these functions are used in other sections (to adjust them dynamically), the 4GLE has to be informed when the query has to be rebuild.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "sql query extensions synopsis": {
    "name": "SQL query extensions synopsis",
    "type": "function",
    "syntax": "function SQL query extensions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_sql_query_extensions"
  },
  "abort": {
    "name": "abort",
    "type": "function",
    "syntax": "function void abort ()",
    "description": "This cancels execution of a program script and returns control to the application. The database is not updated. The function has the same effect in both 3GL and 4GL scripts.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_starting_and_stopping_programs"
  },
  "end": {
    "name": "end",
    "type": "function",
    "syntax": "function void end ()",
    "description": "When used in a 3GL script, this ends the program and returns control to the application. The database is not updated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_starting_and_stopping_programs"
  },
  "exit": {
    "name": "exit",
    "type": "function",
    "syntax": "function void exit ( [void exitvalue])",
    "description": "When included in a 3GL program that is not activated by a 4GL program, exit() has the same effect as end() and end() in a 3GL program.",
    "arguments": [
      {
        "type": "[void",
        "name": "exitvalue ]",
        "description": "Exit value to be returned to the calling program. Implicit conversion of the supplied value from its original type to the string type is performed."
      }
    ],
    "returnValue": "",
    "category": "functions_starting_and_stopping_programs"
  },
  "starting and stopping programs: overview and synopsis": {
    "name": "Starting and stopping programs: overview and synopsis",
    "type": "function",
    "syntax": "function Starting and stopping programs: overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_starting_and_stopping_programs"
  },
  "run.baan.prog": {
    "name": "run.baan.prog",
    "type": "function",
    "syntax": "function long run.baan.prog (const string progname, const string arguments, long mode [, string stdin] [, string stdout] [, string stderr])",
    "description": "The function run.baan.prog() runs a program from $BSE/bin.",
    "arguments": [
      {
        "type": "const string",
        "name": "progname",
        "description": "The name of the program or command to be executed. run.baan.prog() expands progname to $BSE/bin/ progname . Translation to platform specific suffixes (like 6.2 or .exe) or bshell to ntbshell.exe is handled by the bshell. Programmers should not use suffixes, but only provide names like e.g. 'bshell' or 'bsql'. The argument can specify a remote host. For example, if progname is \"tahoe!sort\", the function runs the sort program on the tahoe host. The maximum number of remote programs that can run concurrently depends on available system resources."
      },
      {
        "type": "const string",
        "name": "arguments",
        "description": "The function starts the program or command with the parameters specified here."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "This specifies the execution mode of the program or command. The possible values are: RP_WAIT"
      }
    ],
    "returnValue": "0 program executed successfully. When mode RP_NOWAIT was used, it means the program was started successfully. <0 program could not be started. >0 program did not execute successfully. Note that the return value cannot be retrieved when the mode argument is set to RP_NOWAIT.",
    "category": "functions_starting_and_stopping_programs"
  },
  "run.prog": {
    "name": "run.prog",
    "type": "function",
    "syntax": "function long run.prog (const string progname, const string arguments, long mode [, string stdin] [, string stdout] [, string stderr])",
    "description": "The function run.prog() runs an operating system command. It is a system-dependent function. It must not be used in applications that are distributed across different platforms.",
    "arguments": [
      {
        "type": "const string",
        "name": "progname",
        "description": "The name of the program or command to be executed. run.baan.prog() expands progname to $BSE/bin/ progname { release }. If the progname argument in run.prog() does not supply the full path (absolute or relative), the system searches for the command using the standard facilities of the operating system platform, e.g. PATH environment variable (if set). The argument can specify a remote host. For example, if progname is \"tahoe!sort\", the function runs the sort program on the tahoe host. The maximum number of remote programs that can run concurrently depends on available system resources."
      },
      {
        "type": "const string",
        "name": "arguments",
        "description": "The function start the program or command with the parameters specified here."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "This specifies the execution mode of the program or command. The possible values are: RP_WAIT"
      }
    ],
    "returnValue": "0 program executed successfully <0 program could not be started >0 program did not execute successfully Note that the return value cannot be retrieved when the mode argument is set to RP_NOWAIT.",
    "category": "functions_starting_and_stopping_programs"
  },
  "shell": {
    "name": "shell",
    "type": "function",
    "syntax": "function long shell (string command, long mode)",
    "description": "Deprecated. This function is supported for backward compatibility only. In new applications, use run.prog() and run.baan.prog() instead.",
    "arguments": [
      {
        "type": "string",
        "name": "command",
        "description": "The command to be executed."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "This can be a combination of the following options: 0"
      },
      {
        "type": "",
        "name": "SHELL_BACKGROUND",
        "description": "Background processing. No main window is created and the process produces no output. This is similar to SHELL_NO_OUTPUT + SHELL_NO_WAIT."
      },
      {
        "type": "",
        "name": "SHELL_CLS",
        "description": "Current screen is cleared before the command is executed."
      },
      {
        "type": "",
        "name": "SHELL_CONFIRM",
        "description": "Displays the message \"Press RETURN\", or its local equivalent, in the right lower corner of the window after the shell process has finished."
      },
      {
        "type": "",
        "name": "SHELL_MAXWINSIZE",
        "description": "The terminal emulator sizes its main window to the maximum size. A new main window is created."
      },
      {
        "type": "",
        "name": "SHELL_NO_WAIT",
        "description": "The shell function does not wait for the emulator to end. This is useful for starting shell processes (such as an editor) while continuing processing. The variable shell.pid is set to the process number of the activated terminal emulator process. A new main window is created."
      },
      {
        "type": "",
        "name": "SHELL_NO_OUTPUT",
        "description": "The terminal emulator does produce any output. This implies the SHELL_NO_MWINDOW option."
      },
      {
        "type": "",
        "name": "SHELL_MWINDOW",
        "description": "A main window is created. This displays the output of the shell command."
      }
    ],
    "returnValue": ">0 return code of command 0 success -1 maximum number of pty's is reached; general error code -2 cannot open the master pty -3 pipe command failed -4 fork of reader process or shell process failed -6 cannot start terminal emulator",
    "category": "functions_starting_and_stopping_programs"
  },
  "start.session": {
    "name": "start.session",
    "type": "function",
    "syntax": "function string start.session (long mode, const string session.code, const string zoomname, const string returnfld)",
    "description": "This starts a session from a program script.",
    "arguments": [
      {
        "type": "long",
        "name": "mode",
        "description": "Specifies the start mode for the new session. Possible values are: MODAL The parent session is blocked until the child session exits, in case of a multi-occurrence the session will be started as a zoom session. MODELESS Parent and child are parallel sessions that can be manipulated simultaneously. MODELESS_ALWAYS Even if the session is a Dailog it will be started Modeless MODAL_OVERVIEW The parent session is blocked until the child session exits, in case of a multi-occurrence the session will be started as an overview session. For dynamic sessions, other possible values are: SINGLE_OCC The session is started as a single-occurrence (details) session. MULTI_OCC The session is started as a multioccurrence (overview) session. Note: you can combine one of these with one of the other three; so e.g. MODELESS+SINGLE_OCC"
      },
      {
        "type": "const string",
        "name": "session.code",
        "description": "The code of the session that must be started."
      },
      {
        "type": "const string",
        "name": "zoomname",
        "description": "The name of the calling process. This is used in the 4GL zoom.from sections sections in the child session. If no name is provided here, zoom.from sections in the child session are not executed."
      },
      {
        "type": "const string",
        "name": "returnfld",
        "description": "Indicates the name of the variable to be returned by the function. If you specify an empty string, the function returns the exit value of the zoom process. This argument is relevant only if the start mode is MODAL. You can also specify an index name in this variable. In this case, the values of all component fields of the index are set by the zoom session and exported back to the calling process."
      }
    ],
    "returnValue": "If you specify a variable name in the returnfld argument, the function returns the value of the specified variable. If you specify an index name in returnfld , the function returns the value of returnfld . If you specify an empty string in returnfld , the function returns the exit value of the zoom process. If the session is canceled, the function returns an empty string.",
    "category": "functions_starting_and_stopping_programs"
  },
  "stop": {
    "name": "stop",
    "type": "function",
    "syntax": "function void stop ()",
    "description": "This ends the program. The program immediately exits without updating the database and without executing any further sections. The function has the same effect in both 3GL and 4GL scripts.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_starting_and_stopping_programs"
  },
  "zoom.to$": {
    "name": "zoom.to$",
    "type": "function",
    "syntax": "function string zoom.to$ (string process, long zoomcode, string zoomname, string returnfld, long formpos)",
    "description": "Use this to zoom to another session or menu.",
    "arguments": [
      {
        "type": "string",
        "name": "process",
        "description": "Specifies the name of the session or menu that must be started."
      },
      {
        "type": "long",
        "name": "zoomcode",
        "description": "This can be either Z.MENU or Z.SESSION, depending on whether it is a menu or session that is being started."
      },
      {
        "type": "string",
        "name": "zoomname",
        "description": "The name of the calling process. This is used in the 4GL zoom.from sections sections in the called process. If no name is provided here, zoom.from sections in the child session are not executed."
      },
      {
        "type": "string",
        "name": "returnfld",
        "description": "Indicates the name of the variable to be returned by the function. It must be the name of a variable in the called process. If an empty string is specified here, the function returns the exit value of the zoom process. If the argument is not filled, the function returns nothing."
      },
      {
        "type": "long",
        "name": "formpos",
        "description": "Specifies the form position for displaying the window. The default is 0"
      }
    ],
    "returnValue": "The variable specified in the returnfld argument.",
    "category": "functions_starting_and_stopping_programs"
  },
  "bytes2hex": {
    "name": "bytes2hex",
    "type": "function",
    "syntax": "function string bytes2hex (const string bytes, long length)",
    "description": "Converts a string containing raw bytes to hex characters. Note that the length of the returned string becomes twice the length specified.",
    "arguments": [
      {
        "type": "const string",
        "name": "bytes",
        "description": "a string containing raw bytes"
      },
      {
        "type": "long",
        "name": "length",
        "description": "the number of bytes in the string; this is required as the string may contain \\0 bytes"
      }
    ],
    "returnValue": "a hexadecimal representation of the bytes in the specified string",
    "category": "functions_string_operations"
  },
  "concat$": {
    "name": "concat$",
    "type": "function",
    "syntax": "function string concat$ (string separator, void value ...)",
    "description": "The function concat$ converts one or more values to strings and concatenates them, separated by a separator, to a single string. You can use string.scan() to split the string again into its individual parts.",
    "arguments": [
      {
        "type": "string",
        "name": "separator",
        "description": "The first character of this string is placed as a separator between individual values in the result string. Even individual empty string values are separated by that character. (See example)"
      },
      {
        "type": "void",
        "name": "value ...",
        "description": "One or more values of type long, double, or string. Implicit conversion of the value from its original type to type string is performed. The resulting string value is placed in the output string."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "hex2bytes": {
    "name": "hex2bytes",
    "type": "function",
    "syntax": "function long hex2bytes (const string hex, ref string bytes)",
    "description": "Converts a string of hexadecimal characters to bytes.",
    "arguments": [
      {
        "type": "const string",
        "name": "hex",
        "description": "a string containing hex characters, like \"deadbeef\" or \"9b81c3bd\""
      },
      {
        "type": "ref string",
        "name": "bytes",
        "description": "the returned binary representation of the hex value; this string should be large enough to contain the result bytes (the size of the hex string divided by 2 is enough)"
      }
    ],
    "returnValue": ">= 0 i.e. the number of bytes stored in parameter 'bytes' -1 in case of an invalid hex string",
    "category": "functions_string_operations"
  },
  "isdigit": {
    "name": "isdigit",
    "type": "function",
    "syntax": "function boolean isdigit (string str_expr)",
    "description": "This function tests whether the supplied string is the textual representation of an integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "str_expr",
        "description": ""
      }
    ],
    "returnValue": "TRUE string contains the textual representation of an integer value FALSE string does not contain the textual representation of an integer value",
    "category": "functions_string_operations"
  },
  "isspace": {
    "name": "isspace",
    "type": "function",
    "syntax": "function boolean isspace (string str_expr)",
    "description": "This tests whether the result of string_expr contains only spaces or is empty.",
    "arguments": [
      {
        "type": "string",
        "name": "str_expr",
        "description": ""
      }
    ],
    "returnValue": "TRUE string is empty or contains only spaces FALSE string is not empty and contains characters other than spaces",
    "category": "functions_string_operations"
  },
  "len": {
    "name": "len",
    "type": "function",
    "syntax": "function long len (string str_expr)",
    "description": "This returns the number of characters in string_expr . For strings declared as FIXED, the total length of the string is returned. For non-fixed strings, the current length is returned. To retrieve the length of FIXED strings, excluding trailing spaces, use strip$() .",
    "arguments": [
      {
        "type": "string",
        "name": "str_expr",
        "description": ""
      }
    ],
    "returnValue": "This returns the number of characters in string_expr . For strings declared as FIXED, the total length of the string is returned. For non-fixed strings, the current length is returned. To retrieve the length of FIXED strings, excluding trailing spaces, use strip$() .",
    "category": "functions_string_operations"
  },
  "len.in.bytes": {
    "name": "len.in.bytes",
    "type": "function",
    "syntax": "function long len.in.bytes (string str_expr)",
    "description": "This returns the number of bytes in string_expr . In the case of ASCII characters, the number of bytes equals the number of characters. In the case of multibyte characters, each character can consist of one or four bytes.",
    "arguments": [
      {
        "type": "string",
        "name": "str_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "load.byte": {
    "name": "load.byte",
    "type": "function",
    "syntax": "function long load.byte (string record$)",
    "description": "The function load.byte() treats the supplied string merely as a sequence of bytes. The byte read from the string is interpreted as the 8-bit binary representation of an unsigned integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first byte is used as input bit pattern. It is an error to supply a string with a length in bytes less than 1. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "The numerical value of the first byte of the supplied string. This is a value in the unsigned 8-bit range [0 � 2^8 - 1] (i.e. [0 � 255]).",
    "category": "functions_string_operations"
  },
  "load.double": {
    "name": "load.double",
    "type": "function",
    "syntax": "function double load.double (string record$ [, long swap])",
    "description": "The load.byte(), load.short(), load.long(), load.float() and load.double() functions treat the supplied string merely as a sequence of bytes, without trying to interpret that sequence of bytes as the encoding of a sequence of characters. Instead, the bytes are interpreted as the encoding of numerical values.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first 8 bytes are used as input bit pattern. It is an error to supply a string with a length in bytes less than 8. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "swap ]",
        "description": "This function assumes that the data in record$ is stored in machine dependent format. To compensate for a difference in the endianess of the data and the host running the program set this optional argument to 1. In effect all eight byte will be swapped."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "load.float": {
    "name": "load.float",
    "type": "function",
    "syntax": "function double load.float (string record$ [, long swap])",
    "description": "The load.byte(), load.short(), load.long(), load.float() and load.double() functions treat the supplied string merely as a sequence of bytes, without trying to interpret that sequence of bytes as the encoding of a sequence of characters. Instead, the bytes are interpreted as the encoding of numerical values.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first 4 bytes are used as input bit pattern. It is an error to supply a string with a length in bytes less than 4. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "swap ]",
        "description": "This function assumes that the data in record$ is stored in machine dependent format. To compensate for a difference in the endianess of the data and the host running the program set this optional argument to 1. In effect all four byte will be swapped."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "load.long": {
    "name": "load.long",
    "type": "function",
    "syntax": "function long load.long (string record$ [, long endian])",
    "description": "The function load.long() treats the supplied string merely as a sequence of bytes. The 4 bytes read from the string are interpreted as the 32-bit two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first 4 bytes are used as input bit pattern. It is an error to supply a string with a length in bytes less than 4. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "endian ]",
        "description": "Optional argument indicating the byte order (big endian or little endian) to be used. Value 1 indicates that little endian byte order must be used. Any other value indicates that big endian byte order must be used. Default behavior is to use big endian byte order."
      }
    ],
    "returnValue": "The numerical value of the first 4 bytes of the supplied string. This is a value in the signed 32-bit range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647]).",
    "category": "functions_string_operations"
  },
  "load.short": {
    "name": "load.short",
    "type": "function",
    "syntax": "function long load.short (string record$ [, long endian])",
    "description": "The function load.short() treats the supplied string merely as a sequence of bytes. The 2 bytes read from the string are interpreted as the 16-bit two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first 2 bytes are used as input bit pattern. It is an error to supply a string with a length in bytes less than 2. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "endian ]",
        "description": "Optional argument indicating the byte order (big endian or little endian) to be used. Value 1 indicates that little endian byte order must be used. Any other value indicates that big endian byte order must be used. Default behavior is to use big endian byte order."
      }
    ],
    "returnValue": "The numerical value of the first 2 bytes of the supplied string. This is a value in the signed 16-bit range [-2^15 � 2^15 - 1] (i.e. [-32,768 � 32,767]).",
    "category": "functions_string_operations"
  },
  "load.utc": {
    "name": "load.utc",
    "type": "function",
    "syntax": "function long load.utc (string record$ [, long endian] [, long byte.count])",
    "description": "The function load.utc() treats the supplied string merely as a sequence of bytes. The bytes read from the string are interpreted as the two�s complement representation of a signed integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "record$",
        "description": "String value of which the first byte.count bytes are used as input bit pattern. It is an error to supply a string with a length in bytes less than byte.count . In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "endian ]",
        "description": "Optional argument indicating the byte order (big endian or little endian) to be used. According to the value of this argument, either the little endian byte layout or the big endian byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used. Value 1 indicates that little endian byte order must be used. Any other value indicates that big endian byte order must be used. Default behavior is to use big endian byte order."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be read from record$ . Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used. If this optional argument is used, then first the endian argument must be supplied."
      }
    ],
    "returnValue": "The numerical value of the bytes read from the supplied string. This is a value in the signed byte.count -byte range [-(256^ byte.count )/2 � (256^ byte.count )/2 - 1]. Typically, this is a (non-negative) UTC long format value stored earlier by the function store.utc() , or prepared by any other means. This function does not perform any value check.",
    "category": "functions_string_operations"
  },
  "lval": {
    "name": "lval",
    "type": "function",
    "syntax": "function long lval (string string$)",
    "description": "This function performs explicit string to long type conversion . If the resulting value is within the limits of the signed BitCountOfLong -bit range, that value is returned. Otherwise, the concerned bound is returned.",
    "arguments": [
      {
        "type": "string",
        "name": "string$",
        "description": "String value to be converted to a long value."
      }
    ],
    "returnValue": "Condition Description Value returned by lval -2^( BitCountOfLong -1) &#8804; exact value &#8804; 2^( BitCountOfLong -1) - 1 success exact value exact value < -2^( BitCountOfLong -1) lower bound is applied -2^( BitCountOfLong -1) 2^( BitCountOfLong -1) - 1 < exact value upper bound is applied 2^( BitCountOfLong -1) - 1",
    "category": "functions_string_operations"
  },
  "not.fixed": {
    "name": "not.fixed",
    "type": "function",
    "syntax": "function void not.fixed (string string_var)",
    "description": "You can fill a string with or without specifying a start position. If you specify a start position, unused positions in the string are filled with spaces. You can prevent the string from being filled out with spaces by calling not.fixed() before filling the string. Note that, when you assign a new value to the string variable, positions after the new value are not changed.",
    "arguments": [
      {
        "type": "string",
        "name": "string_var",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "string operations overview": {
    "name": "String operations overview",
    "type": "function",
    "syntax": "function String operations overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "pos": {
    "name": "pos",
    "type": "function",
    "syntax": "function long pos (string source, string part [, long offset])",
    "description": "This returns the start position of a specified substring ( part ) in a specified string ( source ). source and part can be either strings or string expressions.",
    "arguments": [
      {
        "type": "string",
        "name": "source",
        "description": "The string to search in"
      },
      {
        "type": "string",
        "name": "part",
        "description": "The part to search"
      },
      {
        "type": "[long",
        "name": "offset ]",
        "description": "Optional search starting position; when not specified the search starts at position 1. Note that: If offset <= 1 , then searching start at position 1. If offset > len(source) , then 0 is returned. This parameter can be used as of TIV 1700 ."
      }
    ],
    "returnValue": "The start position of the substring in the string. Or 0 if the substring is not found.",
    "category": "functions_string_operations"
  },
  "quoted.string": {
    "name": "quoted.string",
    "type": "function",
    "syntax": "function string quoted.string (string expr)",
    "description": "quoted.string() assures that the contents of the variable can be used as a string for the query processor. If the string_expr contains a quote or double quote, the query processor will generate an error. This function inserts the necessary escapes for the string.",
    "arguments": [
      {
        "type": "string",
        "name": "expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "rpos": {
    "name": "rpos",
    "type": "function",
    "syntax": "function long rpos (string source, string part [, long offset])",
    "description": "This returns the start position of a specified substring ( part ) in a specified string ( source ). source and part can be either strings or string expressions.",
    "arguments": [
      {
        "type": "string",
        "name": "source",
        "description": "The string to search in"
      },
      {
        "type": "string",
        "name": "part",
        "description": "The part to search"
      },
      {
        "type": "[long",
        "name": "offset ]",
        "description": "Optional search starting position; when not specified the search starts at the end of the source string. Note that: If offset < 1 , then 0 is returned. If offset > len(source) , then searching start at the end of the source string (position len(source) ). This parameter can be used as of TIV 1700 ."
      }
    ],
    "returnValue": "The start position of the substring in the string. Or 0 if the substring is not found.",
    "category": "functions_string_operations"
  },
  "set.strip.mode": {
    "name": "set.strip.mode",
    "type": "function",
    "syntax": "function long set.strip.mode (long table.id, long mode)",
    "description": "set.strip.mode() sets or resets the 'strip-on-assignment' flag for all string fields of the table specified by table_id . The mode argument indicates whether the flag is to be set on or off. 1 indicates set flag on, 0 indicates set flag off. Setting this flag on a symbol a means that assignments to other variables from this value will behave as an assignment from",
    "arguments": [
      {
        "type": "long",
        "name": "table.id",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "0 success <0 error",
    "category": "functions_string_operations"
  },
  "set.symbol.strip.mode": {
    "name": "set.symbol.strip.mode",
    "type": "function",
    "syntax": "function long set.symbol.strip.mode (ref string str, long mode)",
    "description": "set.symbol.strip.mode() sets or resets the 'strip-on-assignment' flag for all string fields of the table specified by table_id . The mode argument indicates whether the flag is to be set on or off. 1 indicates set flag on, 0 indicates set flag off. Setting this flag on a symbol a means that assignments to other variables from this value will behave as an assignment from",
    "arguments": [
      {
        "type": "ref string",
        "name": "str",
        "description": ""
      },
      {
        "type": "long",
        "name": "mode",
        "description": ""
      }
    ],
    "returnValue": "0 success <0 error",
    "category": "functions_string_operations"
  },
  "shiftc$": {
    "name": "shiftc$",
    "type": "function",
    "syntax": "function string shiftc$ (string str)",
    "description": "This centers the specified string by equaling the number of leading and trailing spaces. If there is an odd number of spaces, the extra space becomes a trailing space. The returned string always has the same length as the input string.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "shiftl$": {
    "name": "shiftl$",
    "type": "function",
    "syntax": "function string shiftl$ (string str)",
    "description": "This function returns the specified string with any leading spaces removed.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "shiftr$": {
    "name": "shiftr$",
    "type": "function",
    "syntax": "function string shiftr$ (string str)",
    "description": "This function moves the contents of the specified string to the right, if there are trailing spaces. The length of the result is always the same as the length of the input string (this is not necessarily the declaration length).",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.byte": {
    "name": "store.byte",
    "type": "function",
    "syntax": "function void store.byte (long value, ref string rec$)",
    "description": "The function store.byte() treats the supplied string merely as a sequence of bytes.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the string. It is not an error (but it is not encouraged) to supply a value outside the unsigned 8-bit value range [0 � 2^8 - 1] (i.e. [0 � 255]), for which the inverse function load.byte() will retrieve the original supplied integer value. Explicit wrapping of the input value may be done beforehand by means of the 'remainder after division by 256' operator \\ 256 . However, for a negative input value, the result of the expression value \\ 256 is still not in the desired range [0 � 255] but in the range [-255 � 0]. For complete wrapping to the desired range [0 � 255], the following expression may be used: (value \\ 256 + 256) \\ 256 . In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647])."
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first byte will be filled. It is an error to supply a string with a length in bytes less than 1. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.double": {
    "name": "store.double",
    "type": "function",
    "syntax": "function void store.double (double value, ref string rec$)",
    "description": "The store.byte(), store.short(), store.long(), store.float() and store.double() functions treat the supplied string merely as a sequence of bytes. The bytes written to the string are not the encoding of certain characters, but the encoding of the numerical value of the first argument of each function.",
    "arguments": [
      {
        "type": "double",
        "name": "value",
        "description": "The value to write into the string."
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first 8 bytes will be filled. It is an error to supply a string with a length in bytes less than 8. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.float": {
    "name": "store.float",
    "type": "function",
    "syntax": "function void store.float (double value, ref string rec$)",
    "description": "The store.byte(), store.short(), store.long(), store.float() and store.double() functions treat the supplied string merely as a sequence of bytes. The bytes written to the string are not the encoding of certain characters, but the encoding of the numerical value of the first argument of each function.",
    "arguments": [
      {
        "type": "double",
        "name": "value",
        "description": "The value to write into the string."
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first 4 bytes will be filled. It is an error to supply a string with a length in bytes less than 4. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.long": {
    "name": "store.long",
    "type": "function",
    "syntax": "function void store.long (long value, ref string rec$)",
    "description": "The function store.long() treats the supplied string merely as a sequence of bytes.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the string. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-0x80000000 � 0x7fffffff] or [-2,147,483,648 � 2,147,483,647]). Explicit wrapping of the input value may be done beforehand by means of the 'remainder after division by 0x100000000' operator \\ 0x100000000 . However, the result of the expression value \\ 0x100000000 is still not in the desired range [-0x80000000 � 0x7fffffff]. For a positive value, the result is in the range [0 � 0xffffffff], for a negative value it is in the range [-0xffffffff � 0]. For complete wrapping to the desired range [-0x80000000 � 0x7fffffff], the following expression may be used: (value \\ 0x100000000 + 0x180000000) \\ 0x100000000 - 0x80000000 . Notice that the long constants 0x80000000, 0x100000000 and 0x180000000 used above are outside the signed 32-bit value range supported by the compiler. Therefore, these values must be computed at runtime. See the following example. long x4000_0000 long x8000_0000 long x1_0000_0000 long x1_8000_0000 x4000_0000 = 0x40000000 x8000_0000 = x4000_0000 + x4000_0000 x1_0000_0000 = x8000_0000 + x8000_0000 x1_8000_0000 = x1_0000_0000 + x8000_0000 value = (value \\ x1_0000_0000 + x1_8000_0000) \\ x1_0000_0000 - x8000_0000"
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first 4 bytes will be filled. It is an error to supply a string with a length in bytes less than 4. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.short": {
    "name": "store.short",
    "type": "function",
    "syntax": "function void store.short (long value, ref string rec$)",
    "description": "The function store.short() treats the supplied string merely as a sequence of bytes.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the string. It is not an error (but it is not encouraged) to supply a value outside the signed 16-bit value range [-2^15 � 2^15 - 1] (i.e. [-0x8000 � 0x7fff] or [-32,768 � 32,767]), for which the inverse function load.short() will retrieve the original supplied integer value. Explicit wrapping of the input value may be done beforehand by means of the 'remainder after division by 0x10000' operator \\ 0x10000 . However, the result of the expression value \\ 0x10000 is still not in the desired range [-0x8000 � 0x7fff]. For a positive value, the result is in the range [0 � 0xffff], for a negative value it is in the range [-0xffff � 0]. For complete wrapping to the desired range [-0x8000 � 0x7fff], the following expression may be used: (value \\ 0x10000 + 0x18000) \\ 0x10000 - 0x8000 . In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a value outside the signed 32-bit value range [-2^31 � 2^31 - 1] (i.e. [-2,147,483,648 � 2,147,483,647])."
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first 2 bytes will be filled. It is an error to supply a string with a length in bytes less than 2. In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "store.utc": {
    "name": "store.utc",
    "type": "function",
    "syntax": "function void store.utc (long value, ref string rec$ [, long byte.count])",
    "description": "The function store.utc() treats the supplied string merely as a sequence of bytes.",
    "arguments": [
      {
        "type": "long",
        "name": "value",
        "description": "The value to write into the string. Typically, this is a (non-negative) UTC long format value. In 64-bit mode , the bshell is less forgiving than in 32-bit mode . When the bshell is in 64-bit mode, it is a fatal error to supply a negative value . When the bshell is in 64-bit mode, it is a fatal error to supply a value which cannot be stored in the available byte.count bytes without loss of information. Typically, this is the case when byte.count is 4 and the supplied value is outside the signed 32-bit value range, i.e. is greater than 2,147,483,647 (0x7fff,ffff), which corresponds to January 19, 2038, 03:14:07 UTC. When the bshell is in 64-bit mode, it is a fatal error to supply a value which is a UTC long format value greater than the current maximum DB.TIME domain value. Typically, this maximum is 253,402,214,400 (0x3a,fff2,f000), which corresponds to the begin of the last day of the last four-digit year, i.e. December 31, 9999, 00:00:00 UTC."
      },
      {
        "type": "ref string",
        "name": "rec$",
        "description": "String of which the first byte.count bytes will be filled. It is an error to supply a string with a length in bytes less than byte.count . In such a case, at least a log message will be generated. Above that, it may cause (now or in a future bshell version) the current 3GL process to be terminated."
      },
      {
        "type": "[long",
        "name": "byte.count ]",
        "description": "Optional argument specifying the amount of bytes to be written to rec$ . Allowed values are 4, 5, and 8. Any other value is interpreted as 4. Default value is ByteCountOfUtc . According to the value of this argument, the (big endian) byte layout of the Utc32 mode , the Utc40 mode , or the Utc64 mode is used."
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "str.compare": {
    "name": "str.compare",
    "type": "function",
    "syntax": "function long str.compare (const string a$, const string b$ [, boolean ignorecase])",
    "description": "Compares two strings on equality and returns whether string a$ is greater than, equal to or less than string b$ . By default the test is done in a case sensitive way, e.g. \"A\" is not equal to \"a\". Optionally the comparison can be done case insensitive.",
    "arguments": [
      {
        "type": "const string",
        "name": "a$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "b$",
        "description": "another string"
      },
      {
        "type": "[boolean",
        "name": "ignorecase ]",
        "description": "when true is specified the comparison is done case-insensitive; when this argument is not specified the comparison is case sensitive"
      }
    ],
    "returnValue": "> 0 the value of a$ is greater than the value of b$ < 0 the value of a$ is less than the value of b$ 0 the value of a$ is equal to the value of b$",
    "category": "functions_string_operations"
  },
  "str.containsmbchar": {
    "name": "str.containsMBchar",
    "type": "function",
    "syntax": "function boolean str.containsMBchar (const string string$)",
    "description": "Tests whether the specified string contains at least one multi byte character. It does not matter if the string to search in is declared as a single byte or a multi byte string.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      }
    ],
    "returnValue": "true string$ contains at least one multi byte character false in any other case",
    "category": "functions_string_operations"
  },
  "str.endswith": {
    "name": "str.endswith",
    "type": "function",
    "syntax": "function boolean str.endswith (const string string$, const string part$ [, boolean ignorecase])",
    "description": "Determines whether the end of the specified string matches the specified part. Optionally the test can be done case insensitive.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "part$",
        "description": "another string"
      },
      {
        "type": "[boolean",
        "name": "ignorecase ]",
        "description": "when true is specified the comparison is done case-insensitive; when this argument is not specified the comparison is case sensitive"
      }
    ],
    "returnValue": "true the specified part matches the end of the specified string or is empty false in any other case",
    "category": "functions_string_operations"
  },
  "str.equals": {
    "name": "str.equals",
    "type": "function",
    "syntax": "function boolean str.equals (const string a$, const string b$ [, boolean ignorecase])",
    "description": "Tests two strings on equality. By default the test is done in a case sensitive way, e.g. \"A\" is not equal to \"a\". Optionally the test can be done case insensitive.",
    "arguments": [
      {
        "type": "const string",
        "name": "a$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "b$",
        "description": "another string"
      },
      {
        "type": "[boolean",
        "name": "ignorecase ]",
        "description": "when true is specified the test on equality is done case-insensitive; when this argument is not specified the test is case sensitive"
      }
    ],
    "returnValue": "true the value of a$ is equal to the value of b$ false the value of a$ is different from the value of b$",
    "category": "functions_string_operations"
  },
  "str$": {
    "name": "str$",
    "type": "function",
    "syntax": "function string str$ (void input.value)",
    "description": "The function str$ converts the supplied input value from its original type to type string.",
    "arguments": [
      {
        "type": "void",
        "name": "input.value",
        "description": ""
      }
    ],
    "returnValue": "Implicit conversion of the input value from its original type to type string is performed. The resulting string value is returned.",
    "category": "functions_string_operations"
  },
  "str.insert$": {
    "name": "str.insert$",
    "type": "function",
    "syntax": "function string str.insert$ (const string string$, long offset, const string part$)",
    "description": "Returns a copy of a string having a specified part inserted at a specified character position.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "long",
        "name": "offset",
        "description": "the character position of the insertion; note that: if offset <= 1 , then part$ prepended if offset > len(string$) , then part$ appended"
      },
      {
        "type": "const string",
        "name": "part$",
        "description": "the string to insert at the specified offset"
      }
    ],
    "returnValue": "A string equivalent to the specified string but with the specified part inserted at the specified offset",
    "category": "functions_string_operations"
  },
  "str.join$": {
    "name": "str.join$",
    "type": "function",
    "syntax": "function string str.join$ (const string separator$, void ...)",
    "description": "Joins the specified arguments to a single string. Non-string arguments are first converted to strings. The strings are separated with the specified separator.",
    "arguments": [
      {
        "type": "const string",
        "name": "separator$",
        "description": "a separator string, may be an empty string"
      },
      {
        "type": "void",
        "name": "...",
        "description": "the values to join into one string"
      }
    ],
    "returnValue": "A single string containing all specified values separated by the specified separator",
    "category": "functions_string_operations"
  },
  "str.remove$": {
    "name": "str.remove$",
    "type": "function",
    "syntax": "function string str.remove$ (const string string$, long offset, long nchars)",
    "description": "Returns a copy of a string having a number of characters deleted, beginning at a specified character position.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "long",
        "name": "offset",
        "description": "the character position to begin deleting characters; note that: if offset < 1 , then nothing is removed if offset > len(string$) , then nothing is removed"
      },
      {
        "type": "long",
        "name": "nchars",
        "description": "the number of characters to remove; note that: if nchars < 0 , then all characters starting at offset are removed if nchars = 0 , then nothing is removed if offset + nchars > len(string$) , then all characters starting at offset are removed"
      }
    ],
    "returnValue": "A string equivalent to the specified string less the specified number of characters",
    "category": "functions_string_operations"
  },
  "str.replace$": {
    "name": "str.replace$",
    "type": "function",
    "syntax": "function string str.replace$ (const string string$, const string oldstr$, const string newstr$)",
    "description": "Returns a (null terminated) copy of string$ that will have all instances of oldstr$ replaced with newstr$ .",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "oldstr$",
        "description": "the part to replace"
      },
      {
        "type": "const string",
        "name": "newstr$",
        "description": "the part to replace oldstr$ with"
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "str.replace": {
    "name": "str.replace",
    "type": "function",
    "syntax": "function void str.replace (const string string$, const string oldstr$, const string newstr$, ref string result$)",
    "description": "Returns as an output argument a (null terminated) copy of string$ that will have all instances of oldstr$ replaced with newstr$ .",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "oldstr$",
        "description": "the part to replace"
      },
      {
        "type": "const string",
        "name": "newstr$",
        "description": "the part to replace oldstr$ with"
      },
      {
        "type": "ref string",
        "name": "result$",
        "description": "a copy of string$ , with all instances of oldstr$ replaced with newstr$"
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "str.sizeof": {
    "name": "str.sizeof",
    "type": "function",
    "syntax": "function long str.sizeof (const string string$)",
    "description": "Returns the size of the specified string, i.e. the number of bytes the string can contain.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      }
    ],
    "returnValue": "the number of bytes the specified string can contain; or zero in case the string is not allocated.",
    "category": "functions_string_operations"
  },
  "str.startswith": {
    "name": "str.startswith",
    "type": "function",
    "syntax": "function boolean str.startswith (const string string$, const string part$ [, boolean ignorecase])",
    "description": "Determines whether the beginning of the specified string matches the specified part. Optionally the test can be done case insensitive.",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "const string",
        "name": "part$",
        "description": "another string"
      },
      {
        "type": "[boolean",
        "name": "ignorecase ]",
        "description": "when true is specified the comparison is done case-insensitive; when this argument is not specified the comparison is case sensitive"
      }
    ],
    "returnValue": "true the specified part matches the beginning of the specified string or is empty false in any other case",
    "category": "functions_string_operations"
  },
  "str.substring$": {
    "name": "str.substring$",
    "type": "function",
    "syntax": "function string str.substring$ (const string string$, long beginpos [, long endpos])",
    "description": "Returns a substring from the specified string. The substring starts at the specified begin position. When an end position is specified, the substring extends to the character at position endpos - 1 .",
    "arguments": [
      {
        "type": "const string",
        "name": "string$",
        "description": "a string"
      },
      {
        "type": "long",
        "name": "beginpos",
        "description": "the begin position, inclusive; note that: if beginpos <= 0 , beginpos is set to 1 if beginpos > len(string$) , then an empty string is returned"
      },
      {
        "type": "[long",
        "name": "endpos ]",
        "description": "optional, the end position, exclusive; note that: if endpos <= beginpos , an empty string is returned if endpos > len(string$) , then endpos is not taken into account"
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "string.set$": {
    "name": "string.set$",
    "type": "function",
    "syntax": "function string string.set$ (string string_expr, long num_expr)",
    "description": "This returns a string that contains string_expr repeated num_expr times.",
    "arguments": [
      {
        "type": "string",
        "name": "string_expr",
        "description": ""
      },
      {
        "type": "long",
        "name": "num_expr",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "string.to.bounded.long": {
    "name": "string.to.bounded.long",
    "type": "function",
    "syntax": "function long string.to.bounded.long (string string$, long lowerbound, long upperbound [, ref long appliedbounds])",
    "description": "This function performs explicit string to long type conversion . If the resulting value is within the specified bounds, that value is returned. Otherwise, the concerned bound is returned.",
    "arguments": [
      {
        "type": "string",
        "name": "string$",
        "description": "String value to be converted to a long value."
      },
      {
        "type": "long",
        "name": "lowerbound",
        "description": "Lower bound to be applied to the exact long value resulting from the conversion. If the exact result is less than this lower bound, then the lower bound is returned rather than the exact result."
      },
      {
        "type": "long",
        "name": "upperbound",
        "description": "Upper bound to be applied to the exact long value resulting from the conversion. If the exact result is greater than this upper bound, then the upper bound is returned rather than the exact result."
      },
      {
        "type": "[ref long",
        "name": "appliedbounds ]",
        "description": "Optional argument into which information will be written about the success of the conversion."
      }
    ],
    "returnValue": "Condition Description Value returned by string.to.bounded.long Value returned in appliedbounds lowerbound &#8804; exact value &#8804; upperbound success exact value 0 exact value < lowerbound &#8804; upperbound lower bound is applied lowerbound STRING.TO.BOUNDED.LONG.APPLIED.LOWERBOUND lowerbound &#8804; upperbound < exact value upper bound is applied upperbound STRING.TO.BOUNDED.LONG.APPLIED.UPPERBOUND upperbound < lowerbound inconsistent bounds upperbound STRING.TO.BOUNDED.LONG.APPLIED.LOWERBOUND + STRING.TO.BOUNDED.LONG.APPLIED.UPPERBOUND",
    "category": "functions_string_operations"
  },
  "strip$": {
    "name": "strip$",
    "type": "function",
    "syntax": "function string strip$ (string str)",
    "description": "This returns a specified string without trailing spaces. The input string remains unchanged.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "string operations synopsis": {
    "name": "String operations synopsis",
    "type": "function",
    "syntax": "function String operations synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "tolower$": {
    "name": "tolower$",
    "type": "function",
    "syntax": "function string tolower$ (string str)",
    "description": "This function converts all upper case characters in its argument to lower case. It returns the converted string expression. The input string remains unchanged.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "toupper$": {
    "name": "toupper$",
    "type": "function",
    "syntax": "function string toupper$ (string str)",
    "description": "This function converts all lower case characters in its argument to upper case. It returns the converted string expression. The input string remains unchanged.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "trim$": {
    "name": "trim$",
    "type": "function",
    "syntax": "function string trim$ (string str)",
    "description": "This returns a specified string without the leading and trailing spaces. The input string remains unchanged.",
    "arguments": [
      {
        "type": "string",
        "name": "str",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_string_operations"
  },
  "tt.align.according.domain": {
    "name": "tt.align.according.domain",
    "type": "function",
    "syntax": "function long tt.align.according.domain (string string_in(.), string string_out(), ref string domain_name)",
    "description": "This aligns a string according to the alignment method of a specified domain.",
    "arguments": [
      {
        "type": "string",
        "name": "string_in(.)",
        "description": "The input string. This must have the same length as the specified domain. If it is longer than the domain, its final characters are ignored. The input string remains unchanged by the function."
      },
      {
        "type": "string",
        "name": "string_out()",
        "description": "The returned string, aligned according to the alignment method of the domain. This must be the same length as the specified domain."
      },
      {
        "type": "ref string",
        "name": "domain_name",
        "description": "The name of the domain whose alignment method must be used to align the output string. The alignment method can be left, right, or centered."
      }
    ],
    "returnValue": "0 success -1 domain not found or domain is not of type string or multibyte string",
    "category": "functions_string_operations"
  },
  "val": {
    "name": "val",
    "type": "function",
    "syntax": "function double val (string expr)",
    "description": "This function converts the supplied textual representation to the represented floating point value or to the floating point value corresponding to the represented integer value.",
    "arguments": [
      {
        "type": "string",
        "name": "expr",
        "description": ""
      }
    ],
    "returnValue": "The numerical value of the supplied textual representation, or 0 if the supplied string cannot be interpreted as the textual representation of a numerical value.",
    "category": "functions_string_operations"
  },
  "create.node": {
    "name": "create.node",
    "type": "function",
    "syntax": "function void create.node (string tree_name, string parent_id, string node_id, string node_desc, long node_class [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree to which the node must be added."
      },
      {
        "type": "string",
        "name": "parent_id",
        "description": "The ID of the parent node. Specify an empty string as the parent ID for the root node."
      },
      {
        "type": "string",
        "name": "node_id",
        "description": "The ID for the new node."
      },
      {
        "type": "string",
        "name": "node_desc",
        "description": "A description for the node. This is the label displayed for the node in the tree structure."
      },
      {
        "type": "long",
        "name": "node_class",
        "description": "This is a number, in the range 1 to 9, that indicates the node class that must assigned to the node. The node class determines the color in which a node is displayed. You can subsequently assign a different class to the node by calling set.node.class() . You use set.node.class.color() to define node classes."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the server to which the node must be added, as returned by create.tree() . If you do not include this argument, the node is added to all servers with the name specified in tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "create.tree.button": {
    "name": "create.tree.button",
    "type": "function",
    "syntax": "function void create.tree.button (string tree_name, long button_id, string button_desc [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree to which the button must be added."
      },
      {
        "type": "long",
        "name": "button_id",
        "description": "The unique ID of the new button."
      },
      {
        "type": "string",
        "name": "button_desc",
        "description": "The text for the button's label."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the server to which the button must be added, as returned by create.tree() . If you do not include this argument, the button is added to all servers with the name specified in tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "create.tree": {
    "name": "create.tree",
    "type": "function",
    "syntax": "function long create.tree (string tree_name, string tree_title)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree to be started."
      },
      {
        "type": "string",
        "name": "tree_title",
        "description": "The title of the tree. This is displayed in the main window."
      }
    ],
    "returnValue": ">0 success; returns the process ID of the new tree 0 error",
    "category": "functions_structure_chart_manager"
  },
  "destroy.tree": {
    "name": "destroy.tree",
    "type": "function",
    "syntax": "function void destroy.tree (string tree_name [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree that you want to kill."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree that you want to end, as returned by create.tree() . If you do not include this argument, all trees with the name tree_name are killed."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "tree structures: example": {
    "name": "Tree structures: example",
    "type": "function",
    "syntax": "function Tree structures: example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "get.tree.default": {
    "name": "get.tree.default",
    "type": "function",
    "syntax": "function void get.tree.default ()",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "get.tree.node.dpress": {
    "name": "get.tree.node.dpress",
    "type": "function",
    "syntax": "function void get.tree.node.dpress (ref long event, ref long process_id, ref string node_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "event",
        "description": "The event containing the MSG.NODE.DPRESS command."
      },
      {
        "type": "ref long",
        "name": "process_id",
        "description": "This returns the process ID of the Structure Chart Manager that sent the message."
      },
      {
        "type": "ref string",
        "name": "node_id",
        "description": "This returns the ID of the relevant node."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "get.tree.node.press": {
    "name": "get.tree.node.press",
    "type": "function",
    "syntax": "function void get.tree.node.press (ref long event, ref long process_id, ref string node_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "event",
        "description": "The event containing the MSG.NODE.PRESS command."
      },
      {
        "type": "ref long",
        "name": "process_id",
        "description": "This returns the process ID of the Structure Chart Manager that sent the message."
      },
      {
        "type": "ref string",
        "name": "node_id",
        "description": "This returns the ID of the relevant node."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "get.tree.push.button": {
    "name": "get.tree.push.button",
    "type": "function",
    "syntax": "function void get.tree.push.button (ref long event, ref long process_id, ref string button_id, ref string node_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "ref long",
        "name": "event",
        "description": "The event containing the MSG.PUSH.BUTTON command."
      },
      {
        "type": "ref long",
        "name": "process_id",
        "description": "This returns the process ID of the Structure Chart Manager that sent the message."
      },
      {
        "type": "ref string",
        "name": "button_id",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "node_id",
        "description": "This returns the ID of the relevant node."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "structure chart manager overview": {
    "name": "Structure Chart Manager overview",
    "type": "function",
    "syntax": "function Structure Chart Manager overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.node.class.color": {
    "name": "set.node.class.color",
    "type": "function",
    "syntax": "function void set.node.class.color (string tree_name, long node_class, long class_color [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree for which the node class must be defined."
      },
      {
        "type": "long",
        "name": "node_class",
        "description": "This is the identifier of the node class. It can be any number in the range 1 to 9."
      },
      {
        "type": "long",
        "name": "class_color",
        "description": "This specifies the color for the node class. It consists of either a number returned by the rgb() function or one of the following predefined colors: RGB.BLACK RGB.MAGENTA RGB.RED RGB.BLUE RGB.GREEN RGB.WHITE RGB.YELLOW RGB.GRAY RGB.CYAN"
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree for which the node class must be defined. If you do not include this argument, the new color is assigned to the specified node class in all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.node.class": {
    "name": "set.node.class",
    "type": "function",
    "syntax": "function void set.node.class (string tree_name, string node_id, long node_class [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree to which the specified node belongs."
      },
      {
        "type": "string",
        "name": "node_id",
        "description": "The ID of the node to which you want to assign a new class."
      },
      {
        "type": "long",
        "name": "node_class",
        "description": "This is a number, in the range 1 to 9, that indicates the node class that must assigned to the node. You use set.node.class.color() to define node classes."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree for which you want to change the class of the specified node. If you do not include this argument, the node class is changed for the specified node in all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.tree.background": {
    "name": "set.tree.background",
    "type": "function",
    "syntax": "function void set.tree.background (string tree_name, long color [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree whose background color you want to change."
      },
      {
        "type": "long",
        "name": "color",
        "description": "This specifies the new background color for the tree. The value can be a number returned by the rgb() function or one of the following predefined colors: RGB.BLACK RGB.MAGENTA RGB.RED RGB.BLUE RGB.GREEN RGB.WHITE RGB.YELLOW RGB.GRAY RGB.CYAN"
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree whose background color you want to change. If you do not include this argument, the new background color is applied to all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.tree.font": {
    "name": "set.tree.font",
    "type": "function",
    "syntax": "function void set.tree.font (string tree_name, long visible_level, long font [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree for which you want to change the font."
      },
      {
        "type": "long",
        "name": "visible_level",
        "description": "This is a number, in the range 1 to 3, that specifies the node level to which the new font is to be applied. Visible level 1 specifies the highest level currently visible in the tree. Visible level 3 specifies levels three and below. See view.tree() ."
      },
      {
        "type": "long",
        "name": "font",
        "description": "The font to be applied to the specified node level."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree for which the font must be changed. If you do not include this argument, the new font is applied to the specified level in all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.tree.foreground": {
    "name": "set.tree.foreground",
    "type": "function",
    "syntax": "function void set.tree.foreground (string tree_name, long color [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree whose foreground color you want to change."
      },
      {
        "type": "long",
        "name": "color",
        "description": "This specifies the new foreground color for the tree. The value can be a number returned by the rgb() function or one of the following predefined colors: RGB.BLACK RGB.MAGENTA RGB.RED RGB.BLUE RGB.GREEN RGB.WHITE RGB.YELLOW RGB.GRAY RGB.CYAN"
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree whose foreground color you want to change. If you do not include this argument, the new foreground color is applied to all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.tree.linewidth": {
    "name": "set.tree.linewidth",
    "type": "function",
    "syntax": "function void set.tree.linewidth (string tree_name, long visible_level, long linewidth [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree for which you want to change the line width."
      },
      {
        "type": "long",
        "name": "visible_level",
        "description": "This is a number, in the range 1 to 3, that specifies the node level to which the new line width is to be applied. Visible level 1 specifies the highest level currently visible in the tree. Visible level 3 specifies levels three and below. See view.tree() ."
      },
      {
        "type": "long",
        "name": "linewidth",
        "description": "The new line width (in pixels) to be applied to the specified node level."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree for which the line width must be changed. If you do not include this argument, the new line width is applied to the specified level in all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "set.tree.name": {
    "name": "set.tree.name",
    "type": "function",
    "syntax": "function void set.tree.name (string tree_name, string tree_title [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree whose title you want to change."
      },
      {
        "type": "string",
        "name": "tree_title",
        "description": "This specifies the new title for the tree."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree whose title you want to change. If you do not include this argument, the new title is applied to all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "structure chartmanager synopsis": {
    "name": "Structure ChartManager synopsis",
    "type": "function",
    "syntax": "function Structure ChartManager synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "view.tree": {
    "name": "view.tree",
    "type": "function",
    "syntax": "function void view.tree (string tree_name, string node_id, long depth [, long process_id])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "string",
        "name": "tree_name",
        "description": "The name of the tree whose visible levels you want to change."
      },
      {
        "type": "string",
        "name": "node_id",
        "description": "This specifies the ID of node that you want to become the new root node of the visible part of the tree."
      },
      {
        "type": "long",
        "name": "depth",
        "description": "This specifies the number of levels that you want to be visible. The recommended number of visible levels is four."
      },
      {
        "type": "[long",
        "name": "process_id ]",
        "description": "This optional argument indicates the process ID of the tree whose visible levels you want to change. If you do not include this argument, the new settings are applied to all trees with the name tree_name ."
      }
    ],
    "returnValue": "",
    "category": "functions_structure_chart_manager"
  },
  "substitute session sample program": {
    "name": "Substitute session sample program",
    "type": "function",
    "syntax": "function Substitute session sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_substitute_sessions"
  },
  "substitute session overview": {
    "name": "Substitute session overview",
    "type": "function",
    "syntax": "function Substitute session overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_substitute_sessions"
  },
  "substitute.session": {
    "name": "substitute.session",
    "type": "function",
    "syntax": "function long substitute.session (long old.pid, string new.session, long new.pid [, void ...])",
    "description": "This function overlays (substitutes) one session with another. The old session will be no longer visible and the new session will be placed on the same position with exactly the same dimensions.",
    "arguments": [
      {
        "type": "long",
        "name": "old.pid",
        "description": "The process id of the process that should be substituted."
      },
      {
        "type": "string",
        "name": "new.session",
        "description": "The session code of the new session that should be started or reactivated."
      },
      {
        "type": "long",
        "name": "new.pid",
        "description": "The process id of the session that should be reactivated. If the value is not a valid process id or if the session code of the process doesn't match with new.session , the session with session code new.session is started."
      },
      {
        "type": "[void",
        "name": "... ]",
        "description": "Arguments that should be passed to the new session."
      }
    ],
    "returnValue": "The process id of the new started process.",
    "category": "functions_substitute_sessions"
  },
  "synchronized sessions synopsis": {
    "name": "Synchronized sessions synopsis",
    "type": "function",
    "syntax": "function Synchronized sessions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "child synchronization sample program": {
    "name": "Child synchronization sample program",
    "type": "function",
    "syntax": "function Child synchronization sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "synchronized sessions overview": {
    "name": "Synchronized sessions overview",
    "type": "function",
    "syntax": "function Synchronized sessions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "refresh.parent": {
    "name": "refresh.parent",
    "type": "function",
    "syntax": "function long refresh.parent (long occurrence)",
    "description": "This refreshes the parent session of the current session. The occurrence parameter determines which ocurrence of the child session must be refreshed in the parent session.",
    "arguments": [
      {
        "type": "long",
        "name": "occurrence",
        "description": "The occurrence that must be refreshed in the parent session. If the child session is a details session, this is occurrence 1. In case the child session is an overview session, then any number between 1 and the number of occurrences displayed (filled.occ) can be given. If you specify -1, then the parent session will refresh all its occurrences."
      }
    ],
    "returnValue": "0 The parent is refreshed -1 No parent process -2 Invalid occurrence specified",
    "category": "functions_synchronized_sessions"
  },
  "set.dynamic.synchronized.dialog": {
    "name": "set.dynamic.synchronized.dialog",
    "type": "function",
    "syntax": "function void set.dynamic.synchronized.dialog (const string sessioncode [, const string parent.field] [, const string child.field, ...])",
    "description": "This function can be used to set the synchronize session when the session to start depends on data of the record, or when the synchronized session uses a child table.",
    "arguments": [
      {
        "type": "const string",
        "name": "sessioncode",
        "description": "The session code of the child session."
      },
      {
        "type": "[const string",
        "name": "parent.field ]",
        "description": ""
      },
      {
        "type": "[const string",
        "name": "child.field, ... ]",
        "description": "The parent.field and child.field parameters can be used to define the field mapping between the sessions, if the main table differs. This can be used to use a child table as synchronized session. When these arguments are specified, the synchronized session will be started in overview ( MULTI_OCC ) mode."
      }
    ],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "set.synchronized.dialog": {
    "name": "set.synchronized.dialog",
    "type": "function",
    "syntax": "function void set.synchronized.dialog (string sess_code [, boolean editable.grid] [, boolean use.dialog.for.insert])",
    "description": "This defines for the current session the dialog to synchronize with. Both sessions act on the same maintable.",
    "arguments": [
      {
        "type": "string",
        "name": "sess_code",
        "description": "The session code of the single-occurrence dialog session."
      },
      {
        "type": "[boolean",
        "name": "editable.grid ]",
        "description": "Specifies whether or not this parent session should allow an editable grid. The default is false . This parameter is irrelevant in case this parent session is a MMT controller."
      },
      {
        "type": "[boolean",
        "name": "use.dialog.for.insert ]",
        "description": "Specifies whether or not the dialog should be started for inserting or duplicating records. The default is false ."
      }
    ],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "start.synchronized.child": {
    "name": "start.synchronized.child",
    "type": "function",
    "syntax": "function long start.synchronized.child (string sess_code [, string parent.var child.var] [, long start.mode])",
    "description": "Use this to synchronize two sessions that act on different main tables. The function starts the specified child session when the user chooses a particular form command in the multioccurrence parent session. The primary key of the parent's main table must be a subset of the primary key of the child's main table.",
    "arguments": [
      {
        "type": "string",
        "name": "sess_code",
        "description": "The session code of the child session."
      },
      {
        "type": "[string",
        "name": "parent.var child.var ]",
        "description": "These are optional arguments. You use them to synchronize particular variables in the parent and child sessions. For example, to display in the child session only order lines for the order currently selected in the parent session. For each variable to be synchronized, specify the name of the relevant field in the parent's main table, followed by the name of the corresponding field in the child�s main table. For each synchronization event ( start.synchronized.child() , start.synchronized.child.with() , or synchronize.with.child() ), the child session is refreshed, and the specified variables derive their values from the parent session."
      },
      {
        "type": "[long",
        "name": "start.mode ]",
        "description": "When SINGLE_OCC is specified behind the pairs of fields, the specified session will be started in, details mode. Default the session will be started in MULTI_OCC."
      }
    ],
    "returnValue": ">0 a unique identifier for the child process 0 cannot start child -1 argument error",
    "category": "functions_synchronized_sessions"
  },
  "start.synchronized.child.with": {
    "name": "start.synchronized.child.with",
    "type": "function",
    "syntax": "function long start.synchronized.child.with (const long cmd)",
    "description": "To start a synchronized child with a command other than the default synchronization command, call this function before calling start.synchronized.child() .",
    "arguments": [
      {
        "type": "const long",
        "name": "cmd",
        "description": "This specifies the ID of the required command that is executed immediately after startup. Possible values are FIRST.SET , FIND.DATA and ADD.SET ."
      }
    ],
    "returnValue": "The function returns the specified command or 0 if the command is illegal.",
    "category": "functions_synchronized_sessions"
  },
  "stop.synchronized.child": {
    "name": "stop.synchronized.child",
    "type": "function",
    "syntax": "function long stop.synchronized.child (long child.id)",
    "description": "This ends a child session.",
    "arguments": [
      {
        "type": "long",
        "name": "child.id",
        "description": "The unique identifier for the child session to be stopped, as returned by start.synchronized.child() or start.synchronized.child.with() ."
      }
    ],
    "returnValue": "0 success <0 error",
    "category": "functions_synchronized_sessions"
  },
  "synchronize.with.child": {
    "name": "synchronize.with.child",
    "type": "function",
    "syntax": "function long synchronize.with.child (ref long child.id)",
    "description": "This refreshes (that is, resynchronizes) a child session. If the specified child session does not exist, the child.id argument is set to 0 on return.",
    "arguments": [
      {
        "type": "ref long",
        "name": "child.id",
        "description": "The unique identifier for the child session to be refreshed, as returned by start.synchronized.child() or start.synchronized.child.with() ."
      }
    ],
    "returnValue": "0 success <0 error",
    "category": "functions_synchronized_sessions"
  },
  "synchronized sessions illustration": {
    "name": "Synchronized sessions illustration",
    "type": "function",
    "syntax": "function Synchronized sessions illustration()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_synchronized_sessions"
  },
  "bse.dir$": {
    "name": "bse.dir$",
    "type": "function",
    "syntax": "function string bse.dir$ ()",
    "description": "This returns a string containing the name of the directory where the Baan Software Environment is installed. The function uses the environment variable BSE to retrieve the information. If this variable is not filled, bse.dir$() returns the string \"/usr/bse\".",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "bse.release$": {
    "name": "bse.release$",
    "type": "function",
    "syntax": "function string bse.release$ ()",
    "description": "This returns a string of 3 characters that contains the release number of BAAN Tools. For example, \"6.2\".",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "bse.tmp.dir$": {
    "name": "bse.tmp.dir$",
    "type": "function",
    "syntax": "function string bse.tmp.dir$ ()",
    "description": "This returns a string containing the name of the directory where temporary files can be created by the application. The function uses the environment variable BSE_TMP to retrieve the information. If this environment variable is not filled, bse.tmp.dir$() returns the string \"$BSE/tmp\". If the environment variable BSE is not filled, the function returns the string \"/usr/tmp\".",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "current.display": {
    "name": "current.display",
    "type": "function",
    "syntax": "function long current.display ()",
    "description": "This returns the identification number of the current display. It is provided to support the use of multiple displays in future versions of the software. Currently it always returns zero (0)",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "get.bw.hostname": {
    "name": "get.bw.hostname",
    "type": "function",
    "syntax": "function long get.bw.hostname (ref string hostname)",
    "description": "This returns the hostname of the bw client (if available)",
    "arguments": [
      {
        "type": "ref string",
        "name": "hostname",
        "description": ""
      }
    ],
    "returnValue": "1 (TRUE) Function succeeded, hostname is filled 0 (FALSE) Function failed, hostname is unchanged",
    "category": "functions_system_and_user_information"
  },
  "get.bw.ip.address": {
    "name": "get.bw.ip.address",
    "type": "function",
    "syntax": "function string get.bw.ip.address ()",
    "description": "This returns the ip-address of the system of the BW, WebUI or LN UI client (if available)",
    "arguments": [],
    "returnValue": "Return value Function succeeded, return value is the requested ip-address Empty string Information is not available",
    "category": "functions_system_and_user_information"
  },
  "get.bw.username": {
    "name": "get.bw.username",
    "type": "function",
    "syntax": "function long get.bw.username (ref string username)",
    "description": "This returns the Windows username of the user that started the BW client",
    "arguments": [
      {
        "type": "ref string",
        "name": "username",
        "description": ""
      }
    ],
    "returnValue": "1 (TRUE) Function succeeded, username is filled 0 (FALSE) Function failed, username is unchanged",
    "category": "functions_system_and_user_information"
  },
  "get.display.data": {
    "name": "get.display.data",
    "type": "function",
    "syntax": "function long get.display.data (ref long server_data(SRVMAXSIZE))",
    "description": "This retrieves information about the display server. It stores the information in the array server_data . The predefined constant SRVMAXSIZE indicates the maximum size of the array.",
    "arguments": [
      {
        "type": "ref long",
        "name": "server_data(SRVMAXSIZE)",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "get.long.byte.count": {
    "name": "get.long.byte.count",
    "type": "function",
    "syntax": "function long get.long.byte.count ()",
    "description": "This function returns the value BitCountOfLong /8, that is the amount of bytes used to store a variable of type long .",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "get.resource$": {
    "name": "get.resource$",
    "type": "function",
    "syntax": "function string get.resource$ (string resource_name)",
    "description": "This function returns the value associated with the given bshell resource of the current user. Resources are specified in the u<user> file in the '$BSE/lib/user' directory, but also in the files '$BSE/lib/defaults/<logical_name_of_bshell>' and '$BSE/lib/defaults/all'. The logical name of the bshell is the name you specify for the Bshell in BW.",
    "arguments": [
      {
        "type": "string",
        "name": "resource_name",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "get.ui.mode": {
    "name": "get.ui.mode",
    "type": "function",
    "syntax": "function long get.ui.mode ()",
    "description": "This returns a long value that indicates the UI mode in which this session is running. The possible values are:",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "get.utc.byte.count": {
    "name": "get.utc.byte.count",
    "type": "function",
    "syntax": "function long get.utc.byte.count ()",
    "description": "This function returns the value ByteCountOfUtc , that is the amount of bytes used when a UTC long format value is stored in or retrieved from a sequence of bytes.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "getenv$": {
    "name": "getenv$",
    "type": "function",
    "syntax": "function string getenv$ (string env_var)",
    "description": "This returns the value of a specified environment variable of the operating system. It returns an empty string if the variable is not available.",
    "arguments": [
      {
        "type": "string",
        "name": "env_var",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "group.exists": {
    "name": "group.exists",
    "type": "function",
    "syntax": "function boolean group.exists (const string groupname)",
    "description": "This checks whether a specified group is defined on the system. Whether group names are case-sensitive or case-insensitive is a system-dependent feature.",
    "arguments": [
      {
        "type": "const string",
        "name": "groupname",
        "description": ""
      }
    ],
    "returnValue": "TRUE group exists FALSE group does not exist",
    "category": "functions_system_and_user_information"
  },
  "hostname$": {
    "name": "hostname$",
    "type": "function",
    "syntax": "function string hostname$ ( [boolean getcanonicalname])",
    "description": "This returns the hostname of the local machine.",
    "arguments": [
      {
        "type": "[boolean",
        "name": "getcanonicalname ]",
        "description": "As of TIV level 2000 this optional parameter has been added to this function. When the value of this parameter is true, then the canonical hostname is returned. It is up to the system or DNS administrator to provide a correct name. It is a common practice to return fully qualified names (FQN) when requesting for a canonical hostname."
      }
    ],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "is.administrator": {
    "name": "is.administrator",
    "type": "function",
    "syntax": "function boolean is.administrator ()",
    "description": "This checks whether or not the user that is running the bshell has administrator rights on the server that the bshell is running. On UNIX systems, the function returns TRUE if the user has root access to the system. On Windows NT systems, the function returns TRUE if the user belongs to the administrator group.",
    "arguments": [],
    "returnValue": "TRUE user has administrator rights FALSE user does not have administrator rights",
    "category": "functions_system_and_user_information"
  },
  "ostype": {
    "name": "ostype",
    "type": "function",
    "syntax": "function long ostype ()",
    "description": "This function returns a long value that indicates the operating system environment. The possible values are:",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "system and user information overview and synopsis": {
    "name": "System and user information overview and synopsis",
    "type": "function",
    "syntax": "function System and user information overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "setenv": {
    "name": "setenv",
    "type": "function",
    "syntax": "function long setenv (string env_var, string env_value)",
    "description": "This sets the value of a specified environment variable of the operating system. It returns non-zero in case of error.",
    "arguments": [
      {
        "type": "string",
        "name": "env_var",
        "description": ""
      },
      {
        "type": "string",
        "name": "env_value",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_system_and_user_information"
  },
  "user.exists": {
    "name": "user.exists",
    "type": "function",
    "syntax": "function boolean user.exists (const string username)",
    "description": "This checks whether a specified user is defined on the system. Whether user names are case-sensitive or case-insensitive is a system-dependent feature.",
    "arguments": [
      {
        "type": "const string",
        "name": "username",
        "description": ""
      }
    ],
    "returnValue": "TRUE user exists FALSE user does not exist",
    "category": "functions_system_and_user_information"
  },
  "text fields overview": {
    "name": "Text fields overview",
    "type": "function",
    "syntax": "function Text fields overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_text_fields"
  },
  "remove.textfields": {
    "name": "remove.textfields",
    "type": "function",
    "syntax": "function void remove.textfields (const string field.name.string [, const string ...])",
    "description": "The text manager completely ignores the named text field(s) for this session.",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name.string",
        "description": "The name(s) of the text field(s) to be removed. See Text fields overview ."
      },
      {
        "type": "[const string",
        "name": "... ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_text_fields"
  },
  "set.file.for.textfield": {
    "name": "set.file.for.textfield",
    "type": "function",
    "syntax": "function void set.file.for.textfield (const string field.name.string, string filename)",
    "description": "This fills the textbox of a text field with the contents of a specified file present on the server.",
    "arguments": [
      {
        "type": "const string",
        "name": "field.name.string",
        "description": "The name of the multiline text formfield. For example, \"ttadv996.type\". For an array field, include the array element. For example, \"tttadv996.type(5)\"."
      },
      {
        "type": "string",
        "name": "filename",
        "description": "The path and the name of the file to display in the textbox."
      }
    ],
    "returnValue": "",
    "category": "functions_text_fields"
  },
  "set.multiline.text.in.html.mode": {
    "name": "set.multiline.text.in.html.mode",
    "type": "function",
    "syntax": "function long set.multiline.text.in.html.mode (string text_field)",
    "description": "This switches the editing of a text_field to html mode in a Rich Text Editor. Text edited in this way is saved in html format.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field. See Text fields overview . The"
      }
    ],
    "returnValue": "0 Succes -1 Not in LnUI -2 LnUI version to old min version is 12.0.5 -3 Object TIV to low should be >= 2150",
    "category": "functions_text_fields"
  },
  "text fields synopsis": {
    "name": "Text fields synopsis",
    "type": "function",
    "syntax": "function Text fields synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_text_fields"
  },
  "text.buf.to.field": {
    "name": "text.buf.to.field",
    "type": "function",
    "syntax": "function boolean text.buf.to.field (string text_field, string buf)",
    "description": "This function stores the text of a buffer in the specified multiline text formfield. This is only relevant for multiline text formfields in a non-maintable session. An additional 'display' of this field is needed to see the changes on the form.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the multiline text formfield that must be retrieved. See Text fields overview ."
      },
      {
        "type": "string",
        "name": "buf",
        "description": "This specifies the buffer to be set in the multiline text formfield."
      }
    ],
    "returnValue": "true text field changed. false field is not a multiline text formfield.",
    "category": "functions_text_fields"
  },
  "text.copy.between.companies": {
    "name": "text.copy.between.companies",
    "type": "function",
    "syntax": "function long text.copy.between.companies (string text_field_to, string text_field_from, long source_company, long target_company, string kw1, string kw2, string kw3, string kw4, string tgroup, string edit_opt)",
    "description": "This copies the entire text of a specified text field, for all languages, from one company to another.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field_to",
        "description": "The name of the new text field. See Text fields overview . This returns the text number for the new text field."
      },
      {
        "type": "string",
        "name": "text_field_from",
        "description": "The name of the text field that must be copied. See Text fields overview ."
      },
      {
        "type": "long",
        "name": "source_company",
        "description": "This specifies the source company."
      },
      {
        "type": "long",
        "name": "target_company",
        "description": "This specifies the destination company."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "Use these arguments to specify key words for the new text. If you specify one or more of these arguments as an empty string, the corresponding key word(s) are copied from the original text. It is possible, for example, to specify two new key words and to copy the other two from the original text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "string",
        "name": "tgroup",
        "description": "This specifies the name of the text group to which the new text must be assigned. If you specify an empty string here, the text is assigned to the user's default group."
      },
      {
        "type": "string",
        "name": "edit_opt",
        "description": "This specifies the type of window in which the text must be displayed."
      }
    ],
    "returnValue": ">0 success; returns the number of lines copied -1 error;-2 No text copied. In case of textauthorizations are set to \"Use\" value of textnumber in variable tm.field.from has been assigned to tm.field.to.",
    "category": "functions_text_fields"
  },
  "text.copy": {
    "name": "text.copy",
    "type": "function",
    "syntax": "function long text.copy (string text_field_to, string text_field_from, string kw1, string kw2, string kw3, string kw4, string tgroup, string edit_opt)",
    "description": "This makes a copy of the entire text of a specified text field, for all languages, and assigns it a new text number.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field_to",
        "description": "The name of the new text field. See Text fields overview . This returns the text number for the new text field."
      },
      {
        "type": "string",
        "name": "text_field_from",
        "description": "The name of the text field that must be copied. See Text fields overview ."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "Use these arguments to specify key words for the new text. If you specify one or more of these arguments as an empty string, the corresponding key word(s) are copied from the original text. It is possible, for example, to specify two new key words and to copy the other two from the original text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "string",
        "name": "tgroup",
        "description": "This specifies the name of the text group to which the new text must be assigned. If you specify an empty string here, the text is assigned to the user's default group."
      },
      {
        "type": "string",
        "name": "edit_opt",
        "description": "This specifies the type of window in which the text must be displayed."
      }
    ],
    "returnValue": ">0 success; returns the number of lines copied 0 the text_field_from = 0, no source text number -1 error; no permission for this text field -2 No text copied. In case of textauthorizations are set to \"Use\" value of textnumber in variable tm.field.from has been assigned to tm.field.to.",
    "category": "functions_text_fields"
  },
  "text.copy.language": {
    "name": "text.copy.language",
    "type": "function",
    "syntax": "function long text.copy.language (long textnr, string lang_from, string lang_to)",
    "description": "Deprecated. This function doesn't support shared tables and its usage is therefore deprecated. Use text.copy.language.shared() instead.",
    "arguments": [
      {
        "type": "long",
        "name": "textnr",
        "description": "The text number of the text that must be copied."
      },
      {
        "type": "string",
        "name": "lang_from",
        "description": "This specifies the language from which the text must be copied."
      },
      {
        "type": "string",
        "name": "lang_to",
        "description": "This specifies the language to which the text must be copied."
      }
    ],
    "returnValue": ">0 success; returns the number of lines copied 0 error; text not found for source language",
    "category": "functions_text_fields"
  },
  "text.copy.language.shared": {
    "name": "text.copy.language.shared",
    "type": "function",
    "syntax": "function long text.copy.language.shared (string text_field, string lang_from, string lang_to)",
    "description": "This copies a specified text from one language to another. This function takes table sharing into account.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field which must be copied. See Text fields overview . If the specified text does not exist, nothing happens and the function returns 0."
      },
      {
        "type": "string",
        "name": "lang_from",
        "description": "This specifies the language from which the text must be copied."
      },
      {
        "type": "string",
        "name": "lang_to",
        "description": "This specifies the language to which the text must be copied."
      }
    ],
    "returnValue": ">0 success; returns the number of lines copied 0 error; text not found for source language -1 error; switch to the company that stores the texts failed",
    "category": "functions_text_fields"
  },
  "text.defaults": {
    "name": "text.defaults",
    "type": "function",
    "syntax": "function long text.defaults (string text_field, ref string tgroup, ref string edit_opt [, long comp_number])",
    "description": "This retrieves the defaults for a specified text field.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field. See Text fields overview . This returns the text number of the field."
      },
      {
        "type": "ref string",
        "name": "tgroup",
        "description": "This returns the default text group of the text."
      },
      {
        "type": "ref string",
        "name": "edit_opt",
        "description": "This returns the default window type for the text."
      },
      {
        "type": "[long",
        "name": "comp_number ]",
        "description": "This specifies the company number."
      }
    ],
    "returnValue": "0 success -1 default textgroup not found -2 no update permission in textgroup -3 table does not exist in company",
    "category": "functions_text_fields"
  },
  "text.delete": {
    "name": "text.delete",
    "type": "function",
    "syntax": "function long text.delete (string text_field, string lang)",
    "description": "This deletes a specified text.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field that must be deleted. See Text fields overview . This returns the text number of the field."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which the text must be deleted. To delete the text for all languages, specify an empty string here. In this case, the text number and all attributes of the text are deleted from the text manager. This also happens if the language you specify is the only language for which the text exists."
      }
    ],
    "returnValue": ">0 success; returns the number of lines deleted -1 error",
    "category": "functions_text_fields"
  },
  "text.edit": {
    "name": "text.edit",
    "type": "function",
    "syntax": "function long text.edit (string text_field, string lang, string kw1, string kw2, string kw3, string kw4, string tgroup, string edit_opt, long mode)",
    "description": "This opens an edit window in which the specified text can be edited. If the text number associated with the specified text (i.e., the value of the field with name text_field ) is 0, the text manager prompts the user to confirm whether or not a new text must be created. After editing, the text number is stored in the field with name text_field .",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field. See Text fields overview . The text number is read from this field, and if that number is 0, the new text number is stored in this field."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which the text is to be edited."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "Use these arguments to specify the key words for the text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "string",
        "name": "tgroup",
        "description": "This specifies the name of the text group to which the new text must be assigned. If you specify an empty string here, the text is assigned to the user's default group."
      },
      {
        "type": "string",
        "name": "edit_opt",
        "description": "This specifies the type of window in which the text must be displayed."
      },
      {
        "type": "long",
        "name": "mode",
        "description": "This species the text mode. Possible values are: 1 read-only 3 read and write"
      }
    ],
    "returnValue": "The text number (0 if there was no text, and the user did not create a new one). Or <0 if an error occured (-1 means 'no permission').",
    "category": "functions_text_fields"
  },
  "text.find.other.language.shared": {
    "name": "text.find.other.language.shared",
    "type": "function",
    "syntax": "function string text.find.other.language.shared (string text_field)",
    "description": "This function returns the language in which the most recent version of the text is stored. This function takes table sharing into account.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field which must be checked. See Text fields overview . If the specified text does not exist, nothing happens and the function returns 0."
      }
    ],
    "returnValue": "The language in which the text is last stored. An empty string is returned in case of an error",
    "category": "functions_text_fields"
  },
  "text.present.in.language": {
    "name": "text.present.in.language",
    "type": "function",
    "syntax": "function long text.present.in.language (long textnr, string lang [, ref long nr_lines])",
    "description": "Deprecated. This function doesn't support shared tables and its usage is therefore deprecated. Use text.present.in.language.shared() instead.",
    "arguments": [
      {
        "type": "long",
        "name": "textnr",
        "description": "The text number of the relevant text."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which you wish to test the availability of the text."
      },
      {
        "type": "[ref long",
        "name": "nr_lines ]",
        "description": "This optional argument returns the number of lines the text occupies in the specified language."
      }
    ],
    "returnValue": "1 (true) text available in specified language 0 (false) text not available in specified language",
    "category": "functions_text_fields"
  },
  "text.present.in.language.shared": {
    "name": "text.present.in.language.shared",
    "type": "function",
    "syntax": "function long text.present.in.language.shared (string text_field, string lang [, ref long nr_lines])",
    "description": "This tests whether a specified text is available in a specified language. This function takes table sharing into account.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field which must be checked. See Text fields overview . If the specified text does not exist, nothing happens and the function returns 0."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which you wish to test the availability of the text."
      },
      {
        "type": "[ref long",
        "name": "nr_lines ]",
        "description": "This optional argument returns the number of lines the text occupies in the specified language."
      }
    ],
    "returnValue": "1 (true) text available in specified language 0 (false) text not available in specified language",
    "category": "functions_text_fields"
  },
  "text.read": {
    "name": "text.read",
    "type": "function",
    "syntax": "function long text.read (string text_field, string lang, string kw1, string kw2, string kw3, string kw4, ref string tgroup, ref string edit_opt, string tmp_file, long lock [, string rtf_file])",
    "description": "This reads a specified text and stores it in a temporary file. If this file already exists, it will be overwritten.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field that must be read. See Text fields overview . If the text number of the specified field is 0, a subprocess is started, which lists the texts associated with the current company and enables the user to select the text to be read. If no text is found, or if you abort the subprocess, text_field returns 0. Otherwise, it returns the text number of the retrieved text."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which the text must be retrieved."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "These return the key words associated with the specified text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "tgroup",
        "description": "This returns the name of the text group to which the text is assigned."
      },
      {
        "type": "ref string",
        "name": "edit_opt",
        "description": "This returns the default window type for the text."
      },
      {
        "type": "string",
        "name": "tmp_file",
        "description": "The name of the file in which the text must be stored. If this is an empty string, no text is retrieved and the function returns 0."
      },
      {
        "type": "long",
        "name": "lock",
        "description": "By default, a lock is applied to the text field when it is read. To read the field without lock, set this argument to 0."
      },
      {
        "type": "[string",
        "name": "rtf_file ]",
        "description": "The name of the file in which the RTF version of the text must be stored. This is an optional argument. The usage of this argument depends on the settings of the text group as defined in the tgroup argument. If this is an empty string, no text is retrieved and the function returns 0."
      }
    ],
    "returnValue": ">0 success; returns the number of lines read 0 no text found or subprocess aborted -1 no permission",
    "category": "functions_text_fields"
  },
  "text.rewrite": {
    "name": "text.rewrite",
    "type": "function",
    "syntax": "function long text.rewrite (string text_field, string lang, string kw1, string kw2, string kw3, string kw4, string tgroup, string edit_opt, string tmp_file [, long bidi] [, string rtf_file])",
    "description": "This writes text from a specified file to a specified text field. The new text and new text attributes replace the existing text and text attributes.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field to which the file must be copied. See Text fields overview . If the specified text does not exist, nothing happens and the function returns 0."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "The language for which the text is to be rewritten."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "Use these arguments to specify key words for the text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "string",
        "name": "tgroup",
        "description": "This specifies the name of the text group to which the text must be assigned. If you specify an empty string here, the text is assigned to the user's default group."
      },
      {
        "type": "string",
        "name": "edit_opt",
        "description": "This specifies the type of window in which the text must be displayed."
      },
      {
        "type": "string",
        "name": "tmp_file",
        "description": "The name of the file where the new text is stored. The contents of this file is changed before the text is stored, Long lines are wrapped to meet the line width of the text group to which the text is assigned."
      },
      {
        "type": "[long",
        "name": "bidi ]",
        "description": "Use this optional argument to indicate the text alignment. Possible values are: true text is right justified false text is left justified; this is the default option"
      },
      {
        "type": "[string",
        "name": "rtf_file ]",
        "description": "The name of the file in which the RTF version of the text must be stored. This is an optional argument. The usage of this argument depends on the settings of the text group as defined in the tgroup argument. If this is an empty string, no text is retrieved and the function returns 0."
      }
    ],
    "returnValue": ">0 success; returns the number of lines written to the text field 0 no such text <0 some error occurred -1 no permission for text group",
    "category": "functions_text_fields"
  },
  "text.set.keywords": {
    "name": "text.set.keywords",
    "type": "function",
    "syntax": "function boolean text.set.keywords (string text_field, string keyword1, string keyword2, string keyword3, string keyword4)",
    "description": "This stores keyword(s) to the specified multiline text formfield. When the field can be edited with the textmanager (also), attr.textkw1$, attr.textkw2$, attr.textkw3$, attr.textkw4$ in the on.choice of 4gl-section choice.text.manager. In session \"Texts overview\" (tttxt1500m000) you can search for texts based on keywords.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the multiline text formfield that must be retrieved. See Text fields overview ."
      },
      {
        "type": "string",
        "name": "keyword1",
        "description": "First keyword of textfield. When not specifying any keyfield, this first keyfield is filled with fieldname."
      },
      {
        "type": "string",
        "name": "keyword2",
        "description": "Optional. Second keyword of textfield."
      },
      {
        "type": "string",
        "name": "keyword3",
        "description": "Optional. Third keyword of textfield."
      },
      {
        "type": "string",
        "name": "keyword4",
        "description": "Optional. Fourth keyword of textfield."
      }
    ],
    "returnValue": "false field is not a multiline text formfield on the form true function successful",
    "category": "functions_text_fields"
  },
  "text.set.language": {
    "name": "text.set.language",
    "type": "function",
    "syntax": "function boolean text.set.language (string text_field, string language, void ...)",
    "description": "This function changes the language for multiline textfields that are displayed on the form and are part of the maintable. That language will be used when (one of) the textfields are/is read from the text tables. The language that is set with this function can still be overridden by setting attr.textlang$ in the before.choice section for the text.manager.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the textfield for which the language must be set."
      },
      {
        "type": "string",
        "name": "language",
        "description": "The language code."
      },
      {
        "type": "void",
        "name": "...",
        "description": ""
      }
    ],
    "returnValue": "false some error occured true function successful",
    "category": "functions_text_fields"
  },
  "text.to.buf": {
    "name": "text.to.buf",
    "type": "function",
    "syntax": "function long text.to.buf (string text_field, string lang, long nr_lines, ref string buf(,) [, long rtf.text])",
    "description": "This stores the text of a specified text field in a two-dimensional string array.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the text field that must be retrieved. See Text fields overview ."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "This specifies the relevant language."
      },
      {
        "type": "long",
        "name": "nr_lines",
        "description": "This specifies the maximum number of lines that can be stored in the buffer."
      },
      {
        "type": "ref string",
        "name": "buf(,)",
        "description": "This specifies the buffer in which the text must be stored."
      },
      {
        "type": "[long",
        "name": "rtf.text ]",
        "description": "Set this argument to true if you want the text to be stored in RTF format instead of ASCII format. This is possible only when using a text group that supports RTF data."
      }
    ],
    "returnValue": ">0 number of stored lines 0 error - 1 no permission to store the text",
    "category": "functions_text_fields"
  },
  "text.window": {
    "name": "text.window",
    "type": "function",
    "syntax": "function long text.window (string edit_opt, ref long start_column, ref long start_row, ref long number_columns, ref long number_rows)",
    "description": "This returns information about a specified window type.",
    "arguments": [
      {
        "type": "string",
        "name": "edit_opt",
        "description": "The name of the window type."
      },
      {
        "type": "ref long",
        "name": "start_column",
        "description": "This returns the number of the column where the"
      },
      {
        "type": "ref long",
        "name": "start_row",
        "description": "This returns the number of the row where the window"
      },
      {
        "type": "ref long",
        "name": "number_columns",
        "description": "This returns the number of rows in the window."
      },
      {
        "type": "ref long",
        "name": "number_rows",
        "description": "This returns the number of rows in the window."
      }
    ],
    "returnValue": "0 success -1 error; edit_opt not found",
    "category": "functions_text_fields"
  },
  "text.write": {
    "name": "text.write",
    "type": "function",
    "syntax": "function long text.write (string text_field, string lang, string kw1, string kw2, string kw3, string kw4, string tgroup, string edit_opt, string tmp_file [, long bidi] [, string rtf_file])",
    "description": "This adds a new text to the text manager and assigns a new text number to the text.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the new text field. See Text fields overview . This returns the text number for the new field."
      },
      {
        "type": "string",
        "name": "lang",
        "description": "This specifies the language for the new text."
      },
      {
        "type": "string",
        "name": "kw1",
        "description": "Use these arguments to specify key words for the text."
      },
      {
        "type": "string",
        "name": "kw2",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw3",
        "description": ""
      },
      {
        "type": "string",
        "name": "kw4",
        "description": ""
      },
      {
        "type": "string",
        "name": "tgroup",
        "description": "This specifies the name of the text group to which the text must be assigned. If you specify an empty string here, the text is assigned to the user's default group."
      },
      {
        "type": "string",
        "name": "edit_opt",
        "description": "This specifies the type of window in which the text must be displayed."
      },
      {
        "type": "string",
        "name": "tmp_file",
        "description": "The name of the file where the text for the new field is stored. The contents of this file is changed before the text is stored, Long lines are wrapped to meet the line width of the text group to which the text is assigned."
      },
      {
        "type": "[long",
        "name": "bidi ]",
        "description": "Use this optional argument to indicate the text alignment. Possible values are: true text is right justified false text is left justified; this is the default option"
      },
      {
        "type": "[string",
        "name": "rtf_file ]",
        "description": "The name of the file in which the RTF version of the text must be stored. This is an optional argument. The usage of this argument depends on the settings of the text group as defined in the tgroup argument. If this is an empty string, no text is retrieved and the function returns 0."
      }
    ],
    "returnValue": ">0 success; returns the number of lines written <0 error",
    "category": "functions_text_fields"
  },
  "textfield.to.buf": {
    "name": "textfield.to.buf",
    "type": "function",
    "syntax": "function long textfield.to.buf (string text_field, string buffer)",
    "description": "Reads the text of a multiline text formfield and stores the text into the passed buffer. The passed buffer should be defined as a based string. This is only relevant for multiline text formfields in a non-maintable session.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the multiline text formfield that must be retrieved. See Text fields overview ."
      },
      {
        "type": "string",
        "name": "buffer",
        "description": "buffer for storing the text."
      }
    ],
    "returnValue": ">0 number of characters copied to buffer -1 field is not a multiline text formfield.",
    "category": "functions_text_fields"
  },
  "textfield.to.database": {
    "name": "textfield.to.database",
    "type": "function",
    "syntax": "function long textfield.to.database (string text_field)",
    "description": "Gets the text from the text part of the specified field, and writes it into the texttable. If the text does not exist yet in the texttable, a new texttable record is created. This is only relevant for multiline text formfields in a non-maintable session.",
    "arguments": [
      {
        "type": "string",
        "name": "text_field",
        "description": "The name of the multiline text formfield that must be stored. (Should be a table field) See Text fields overview ."
      }
    ],
    "returnValue": "<0 error occurred; e.g. field is not a multiline text formfield on the form -2 can not create a tmp file. -3 the variabele text_field.text does not exist. >0 textfield-id saved in texttable.",
    "category": "functions_text_fields"
  },
  "kill.timer": {
    "name": "kill.timer",
    "type": "function",
    "syntax": "function void kill.timer (long timer_id)",
    "description": "This ends a specified timer.",
    "arguments": [
      {
        "type": "long",
        "name": "timer_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_timers"
  },
  "mtime": {
    "name": "mtime",
    "type": "function",
    "syntax": "function long mtime ()",
    "description": "This measures the time elapsed since the first mtime() call. The function is common to all processes within the same bshell. That is, when it is called by a process, the result is the number of milliseconds since the function was first called by a process in the same bshell.",
    "arguments": [],
    "returnValue": "The first call returns 0. Subsequent calls return the number of milliseconds since the first call. A negative value is returned if an error occurs.",
    "category": "functions_timers"
  },
  "timers overview and synopsis": {
    "name": "Timers overview and synopsis",
    "type": "function",
    "syntax": "function Timers overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_timers"
  },
  "set.alarm": {
    "name": "set.alarm",
    "type": "function",
    "syntax": "function long set.alarm (long msec)",
    "description": "This starts a timer that sends a single EVTTIMEREVENT event to the calling process after the number of milliseconds specified in the msec argument. The timer automatically ends after sending the event. The timer also ends automatically when the process ends or when the program explicitly kills it with kill.timer() .",
    "arguments": [
      {
        "type": "long",
        "name": "msec",
        "description": ""
      }
    ],
    "returnValue": "A unique identifier for the timer.",
    "category": "functions_timers"
  },
  "set.timer": {
    "name": "set.timer",
    "type": "function",
    "syntax": "function long set.timer (long msec)",
    "description": "This starts a timer that sends an EVTTIMEREVENT event to the calling process every msec milliseconds. The timer continues to send events until the process ends or until the program explicitly terminates the timer using kill.timer() .",
    "arguments": [
      {
        "type": "long",
        "name": "msec",
        "description": ""
      }
    ],
    "returnValue": "A unique identifier for the timer.",
    "category": "functions_timers"
  },
  "disable.table.extension": {
    "name": "disable.table.extension",
    "type": "function",
    "syntax": "function void disable.table.extension ()",
    "description": "This macro will disable the calling of ue hooks and table extension hooks. The actual state of the enabling is saved and will be used during enable.table.extension()",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uedll"
  },
  "disable.ue.dll": {
    "name": "disable.ue.dll",
    "type": "function",
    "syntax": "function void disable.ue.dll ()",
    "description": "This macro will disable the calling of ue hooks and table extension hooks. The actual state of the enabling is saved and will be used during enable.ue.dll",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uedll"
  },
  "enable.table.extension": {
    "name": "enable.table.extension",
    "type": "function",
    "syntax": "function void enable.table.extension ()",
    "description": "This macro will enable the calling of ue hooks and table extension hooks. The actual state of the enabling as saved during disable.table.extension() will be used during enable.table.extension().",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uedll"
  },
  "enable.ue.dll": {
    "name": "enable.ue.dll",
    "type": "function",
    "syntax": "function void enable.ue.dll ()",
    "description": "This macro will enable the calling of ue hooks and table extension hooks. The actual state of the enabling as saved during disable.ue.dll will be used during enable.ue.dll.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uedll"
  },
  "user exit dll overview": {
    "name": "User Exit DLL Overview",
    "type": "function",
    "syntax": "function User Exit DLL Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uedll"
  },
  "ue.after.after.destroy.object": {
    "name": "ue.after.after.destroy.object",
    "type": "function",
    "syntax": "function extern long ue.after.after.destroy.object ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.after.after.save.object": {
    "name": "ue.after.after.save.object",
    "type": "function",
    "syntax": "function extern long ue.after.after.save.object ( [long mode])",
    "description": "This hook is called in case data is saved, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.save.object() , dal.new() , or dal.update() is called.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This parameter contains either the value DAL_NEW in case of an insert, or DAL_UPDATE in case of an update."
      }
    ],
    "returnValue": "This hooks returns 0 if saving the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.after.before.destroy.object": {
    "name": "ue.after.before.destroy.object",
    "type": "function",
    "syntax": "function extern long ue.after.before.destroy.object ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.after.before.save.object": {
    "name": "ue.after.before.save.object",
    "type": "function",
    "syntax": "function extern long ue.after.before.save.object ( [long mode])",
    "description": "This hook is called in case data is saved, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.save.object() , dal.new() , or dal.update() is called.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This parameter contains either the value DAL_NEW in case of an insert, or DAL_UPDATE in case of an update."
      }
    ],
    "returnValue": "This hooks returns 0 if saving the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.before.after.destroy.object": {
    "name": "ue.before.after.destroy.object",
    "type": "function",
    "syntax": "function extern long ue.before.after.destroy.object ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.before.after.save.object": {
    "name": "ue.before.after.save.object",
    "type": "function",
    "syntax": "function extern long ue.before.after.save.object ( [long mode])",
    "description": "This hook is called in case data is saved, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.save.object() , dal.new() , or dal.update() is called.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This parameter contains either the value DAL_NEW in case of an insert, or DAL_UPDATE in case of an update."
      }
    ],
    "returnValue": "This hooks returns 0 if saving the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.before.before.destroy.object": {
    "name": "ue.before.before.destroy.object",
    "type": "function",
    "syntax": "function extern long ue.before.before.destroy.object ()",
    "description": "This hook is called in case data is deleted, either by the user pressing the delete button on the UI, or programmatically when one of the functions dal.destroy.object() or dal.destroy() is called.",
    "arguments": [],
    "returnValue": "This hooks returns 0 if deleting the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.before.before.save.object": {
    "name": "ue.before.before.save.object",
    "type": "function",
    "syntax": "function extern long ue.before.before.save.object ( [long mode])",
    "description": "This hook is called in case data is saved, either by the user pressing the save button on the UI, or programmatically when one of the functions dal.save.object() , dal.new() , or dal.update() is called.",
    "arguments": [
      {
        "type": "[long",
        "name": "mode ]",
        "description": "This parameter contains either the value DAL_NEW in case of an insert, or DAL_UPDATE in case of an update."
      }
    ],
    "returnValue": "This hooks returns 0 if saving the record is permitted. It should return a negative value like DALHOOKERROR, in case of an error.",
    "category": "functions_uedll"
  },
  "ue.get.origin": {
    "name": "ue.get.origin",
    "type": "function",
    "syntax": "function extern long ue.get.origin ()",
    "description": "This function returns the origin of the execution of the User Exit hook.",
    "arguments": [],
    "returnValue": "This hooks returns: UE_FROM_4GLE in case the hook was executed from the 4GL Engine. UE_FROM_DAL in case the hook was executed from a dal action. UE_FROM_DB in case the hook was executed from a db action.",
    "category": "functions_uedll"
  },
  "form.command.is.allowed": {
    "name": "form.command.is.allowed",
    "type": "function",
    "syntax": "function extern boolean form.command.is.allowed ()",
    "description": "You can use this hook to define the conditions under which the form command should become enabled in the UI. The 4GL engine will use this hooks to determine whether the form command must be enabled or disabled.",
    "arguments": [],
    "returnValue": "The hook should return TRUE in case the form command is allowed. In that case the 4GL engine will enable the form command on the UI. In any other case the hook should return FALSE.",
    "category": "functions_ui_template"
  },
  "ui template": {
    "name": "UI Template",
    "type": "function",
    "syntax": "function UI Template()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_ui_template"
  },
  "standard.command.is.allowed": {
    "name": "standard.command.is.allowed",
    "type": "function",
    "syntax": "function boolean standard.command.is.allowed ()",
    "description": "You can use these hooks in your UI script to define the conditions under which the specific standard command should become enabled in the UI. The 4GL engine will use these hooks to determine whether the standard commands must be enabled or disabled.",
    "arguments": [],
    "returnValue": "The hook should return TRUE in case the standard command is allowed. In that case the 4GL engine will enable the standard command on the UI. In any other case the hook should return FALSE.",
    "category": "functions_ui_template"
  },
  "change.object": {
    "name": "change.object",
    "type": "function",
    "syntax": "function void change.object (long object_id, long attribute, void value [, long size])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The object ID, as returned by create.object() when the object was created."
      },
      {
        "type": "long",
        "name": "attribute",
        "description": "Use these arguments to set new values for the object's attributes. For each attribute you specify, you must include the attribute type (for example, DsNmaximum or DsNminimum), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "void",
        "name": "value",
        "description": ""
      },
      {
        "type": "[long",
        "name": "size ]",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "change.sub.object": {
    "name": "change.sub.object",
    "type": "function",
    "syntax": "function void change.sub.object (long object, long sub_object_id, long attribute, void value, long size)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "The ID of the parent object, as returned by create.object() when the parent object was created."
      },
      {
        "type": "long",
        "name": "sub_object_id",
        "description": "The ID of the subobject, as returned by create.sub.object() or create.sub.object.by.id() when the subobject was created."
      },
      {
        "type": "long",
        "name": "attribute",
        "description": "Use these arguments to set new values for the subobject's attributes. For each attribute you specify, you must include the attribute type (for example, DsNgcBackground or DsNgcForeground), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "void",
        "name": "value",
        "description": ""
      },
      {
        "type": "long",
        "name": "size",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "compress.pixmap": {
    "name": "compress.pixmap",
    "type": "function",
    "syntax": "function long compress.pixmap (long colormap, long num_colors, string pixmap(), long width, long height, ref string buffer, ref long buffer_length)",
    "description": "This converts a specified colormap and pixmap to a picture in .gif format.",
    "arguments": [
      {
        "type": "long",
        "name": "colormap",
        "description": "The ID of the DsCcolormap object that must be converted."
      },
      {
        "type": "long",
        "name": "num_colors",
        "description": "The number of colors defined by the specified colormap object."
      },
      {
        "type": "string",
        "name": "pixmap()",
        "description": "The ID of the DsCpixmap object that must be converted."
      },
      {
        "type": "long",
        "name": "width",
        "description": "The width of the pixmap, in pixels."
      },
      {
        "type": "long",
        "name": "height",
        "description": "The height of the pixmap, in pixels."
      },
      {
        "type": "ref string",
        "name": "buffer",
        "description": "This returns the data for the .gif picture. To access the .gif picture, you must write the buffer data to a file by calling seq.write() ."
      },
      {
        "type": "ref long",
        "name": "buffer_length",
        "description": "This returns the length of the buffer."
      }
    ],
    "returnValue": "TRUE (!=0) success FALSE (=0) error",
    "category": "functions_user_interface_objects"
  },
  "create.object": {
    "name": "create.object",
    "type": "function",
    "syntax": "function long create.object (long type, long parent_object [, long attribute, value [, size]], ...)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "type",
        "description": "The type of object to be created. For example, DsCbarMenu or DsCcheckBox."
      },
      {
        "type": "long",
        "name": "parent_object",
        "description": "The ID of the parent object. You must create an object within a parent object. The parent object can be a main window, another object, or the current.display() ."
      },
      {
        "type": "[long",
        "name": "attribute, value [, size] ]",
        "description": "Use these optional arguments to set the object's attributes. For each attribute you specify, you must include the attribute type (for example, DsNmaximum or DsNminimum), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "",
        "name": "...",
        "description": ""
      }
    ],
    "returnValue": "The ID for the new object, or 0 if an error occurs. You can subsequently use the returned ID as the object_id , parent_object , or object argument in other functions.",
    "category": "functions_user_interface_objects"
  },
  "create.sub.object.by.id": {
    "name": "create.sub.object.by.id",
    "type": "function",
    "syntax": "function long create.sub.object.by.id (long object, long sub_object_id, long type, long attribute, void value [, long size])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "The ID of the parent object, as returned by create.object() when the parent object was created. The parent object is always a DsCgwindow object."
      },
      {
        "type": "long",
        "name": "sub_object_id",
        "description": "The ID for the new object."
      },
      {
        "type": "long",
        "name": "type",
        "description": "The type of subobject to be created. For example, DsCgpArc or DsCgpLine ."
      },
      {
        "type": "long",
        "name": "attribute",
        "description": "Use these arguments to set the subobject's attributes. For each attribute you specify, you must include the attribute type (for example, DsNgcBackground or DsNgcForeground), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "void",
        "name": "value",
        "description": ""
      },
      {
        "type": "[long",
        "name": "size ]",
        "description": ""
      }
    ],
    "returnValue": "The ID for the new subobject (as specified by the sub_object_id argument) or 0 if an error occurs. You can subsequently use the returned ID as the sub_object_id argument in other functions.",
    "category": "functions_user_interface_objects"
  },
  "create.sub.object": {
    "name": "create.sub.object",
    "type": "function",
    "syntax": "function long create.sub.object (long object, long type [, long attribute, value [, size]], ...)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "The ID of the parent object, as returned by create.object() when the parent object was created. The parent object is always a DsCgwindow object."
      },
      {
        "type": "long",
        "name": "type",
        "description": "The type of subobject to be created. For example, DsCgpArc or DsCgpLine."
      },
      {
        "type": "[long",
        "name": "attribute, value [, size] ]",
        "description": "Use these arguments to set the subobject's attributes. For each attribute you specify, you must include the attribute type (for example, DsNgcBackground or DsNgcForeground), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "",
        "name": "...",
        "description": ""
      }
    ],
    "returnValue": "The ID for the new subobject or 0 if an error occurs. You can subsequently use the returned ID as the sub_object_id argument in other functions.",
    "category": "functions_user_interface_objects"
  },
  "decompress.pixmap": {
    "name": "decompress.pixmap",
    "type": "function",
    "syntax": "function long decompress.pixmap (string buffer, ref long colormap, ref string pixmap)",
    "description": "This converts a picture in .gif format to a colormap and pixmap. The long array returned by the colormap argument can subsequently be used as the DsNcolorTable attribute of a DsCcolormap object. The string array returned by the pixmap argument can subsequently be used as the DsNdata attribute for a DsCpixmap object.",
    "arguments": [
      {
        "type": "string",
        "name": "buffer",
        "description": "The buffer containing the .gif file data, as returned by a seq.read() call."
      },
      {
        "type": "ref long",
        "name": "colormap",
        "description": "This returns an array of rgb values that you can use as the DsNcolorTable attribute for DsCcolormap objects."
      },
      {
        "type": "ref string",
        "name": "pixmap",
        "description": "This returns an array of indexes into the returned colormap. You can use this as the DsNdata attribute of DsCpixmap objects."
      }
    ],
    "returnValue": "TRUE (!=0) success FALSE (=0) error",
    "category": "functions_user_interface_objects"
  },
  "destroy.object": {
    "name": "destroy.object",
    "type": "function",
    "syntax": "function void destroy.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The object ID, as returned by create.object() when the object was created."
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "destroy.sub.object": {
    "name": "destroy.sub.object",
    "type": "function",
    "syntax": "function void destroy.sub.object (long object, long sub_object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "The ID of the parent object, as returned by create.object() when the parent object was created."
      },
      {
        "type": "long",
        "name": "sub_object_id",
        "description": "The ID of the subobject, as returned by create.sub.object() or create.sub.object.by.id() when the subobject was created."
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscbarmenu": {
    "name": "DsCbarMenu",
    "type": "function",
    "syntax": "function DsCbarMenu()",
    "description": "A DsCbarMenu object defines a menu bar and associated drop-down and cascaded menus. The menu bar is displayed across the top of a main window (DsCmwindow), below the title bar.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsccombox, dscddcombox, dsclistbox, dscddlistbox": {
    "name": "DsCcomBox, DsCdDComBox, DsClistBox, DsCdDListBox",
    "type": "function",
    "syntax": "function DsCcomBox, DsCdDComBox, DsClistBox, DsCdDListBox()",
    "description": "A list box (DsClistBox) displays a list of choices from which the user can select one or more items.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsccheckbox": {
    "name": "DsCcheckBox",
    "type": "function",
    "syntax": "function DsCcheckBox()",
    "description": "A check box represents a choice that has two states (selected or not selected). It appears as a square box with an accompanying label. When the choice is selected, a check mark appears in the box. When the choice is not selected, the box is empty.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsccolorcell": {
    "name": "DsCcolorCell",
    "type": "function",
    "syntax": "function DsCcolorCell()",
    "description": "A color cell is a rectangular child window that displays a color. If possible, a color cell uses only one palette entry and so saves resources. Otherwise, the number of colors used increases with every change.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsccolormap": {
    "name": "DsCcolormap",
    "type": "function",
    "syntax": "function DsCcolormap()",
    "description": "A color map defines an array of colors that can be used by a DsCpixmap object. The DsNdata attribute of a pixmap object contains an array of indexes into the color table of a DsCcolormap object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscdrawnbutton": {
    "name": "DsCdrawnButton",
    "type": "function",
    "syntax": "function DsCdrawnButton()",
    "description": "A DsCdrawnButton object has the same functionality as a DsCpushButton object except that it displays a graphical image instead of a text label.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscfield": {
    "name": "DsCfield",
    "type": "function",
    "syntax": "function DsCfield()",
    "description": "A DsCfield object provides a rectangular child window where the user can enter and edit text. It can be defined to support a single line or multiple lines of text. A DsCfield object provides the same functionality as a Windows text box (also referred to as an edit control).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscfontset": {
    "name": "DsCfontSet",
    "type": "function",
    "syntax": "function DsCfontSet()",
    "description": "A DsCfontSet object defines a set of font attributes that other objects can apply to text strings. Objects indicate the font set to use by specifying the object ID of the font set in their DsNfontSet attribute.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscframe": {
    "name": "DsCframe",
    "type": "function",
    "syntax": "function DsCframe()",
    "description": "A DsCframe object places a three-dimensional border around a single child object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgc": {
    "name": "DsCgc",
    "type": "function",
    "syntax": "function DsCgc()",
    "description": "A graphical context object (DsCgc) defines a set of attributes that can be applied to graphical parts (that is, to subobjects of type DsCgpArc, DsCgpLine, DsCgpPie, and so on).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgparc": {
    "name": "DsCgpArc",
    "type": "function",
    "syntax": "function DsCgpArc()",
    "description": "A DsCgpArc object defines a circular or elliptical arc inside a rectangle. The center of the circle or ellipse is the center of the rectangle. The major and minor axes are specified by the width and height attributes respectively. The parent object is always a graphical window (DsCgwindow).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpcomposite": {
    "name": "DsCgpComposite",
    "type": "function",
    "syntax": "function DsCgpComposite()",
    "description": "A DsCgpComposite subobject groups a number of graphical parts so that you can manipulate them as a single unit. The parent object is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpgroupbox": {
    "name": "DsCgpGroupBox",
    "type": "function",
    "syntax": "function DsCgpGroupBox()",
    "description": "A DsCgpGroupBox object defines a frame on the parent window. It can also display a text string at the top of the frame. The parent object is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpheader": {
    "name": "DsCgpHeader",
    "type": "function",
    "syntax": "function DsCgpHeader()",
    "description": "A DsCgpHeader subobject defines a header line on the parent window. The line can include a centered title string. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpimage": {
    "name": "DsCgpImage",
    "type": "function",
    "syntax": "function DsCgpImage()",
    "description": "A DsCgpImage object defines a graphical image to be drawn in the parent window. It is linked to a DsCpixmap object, which defines an array of pixels, with a specified width, height, and depth (number of planes), but no screen coordinates. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpline": {
    "name": "DsCgpLine",
    "type": "function",
    "syntax": "function DsCgpLine()",
    "description": "A DsCgpLine subobject defines a line to be drawn between two specified points in the parent window. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgpolesite": {
    "name": "DsCgpOleSite",
    "type": "function",
    "syntax": "function DsCgpOleSite()",
    "description": "A DsCgpOleSite subobject defines a rectangle that can embed an OLE object. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgppie": {
    "name": "DsCgpPie",
    "type": "function",
    "syntax": "function DsCgpPie()",
    "description": "A DsCgpPie subobject defines a filled circular or elliptical arc, within a bounding rectangle. This subobject is similar to a DsCgpArc subobject, except that it is filled with a color and fill style. The parent object is always a graphical window (DsCgwindow).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgppolygon": {
    "name": "DsCgpPolygon",
    "type": "function",
    "syntax": "function DsCgpPolygon()",
    "description": "A DsCgpPolygon subobject defines a closed figure, bounded by three or more straight sides, which is drawn in the parent window. It is basically a polyline whose first and last points are joined. A polygon subobject can have a fill color and style. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgppolyline": {
    "name": "DsCgpPolyline",
    "type": "function",
    "syntax": "function DsCgpPolyline()",
    "description": "A DsCgpPolyline subobject defines a line to be drawn between a number of specified points in the parent window. The points are stored in the DsNpointArray attribute. If the first and last points coincide, the lines are joined according to the setting of the DsNgcJoinStyle attribute. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgprectangle": {
    "name": "DsCgpRectangle",
    "type": "function",
    "syntax": "function DsCgpRectangle()",
    "description": "A DsCgpRectangle subobject defines a rectangle within the parent window. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgptext": {
    "name": "DsCgpText",
    "type": "function",
    "syntax": "function DsCgpText()",
    "description": "A DsCgpText subobject defines a text string to be drawn as a graphical part in the parent window. The parent window is always a DsCgwindow object.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgraph": {
    "name": "DsCgraph",
    "type": "function",
    "syntax": "function DsCgraph()",
    "description": "A graph is a rectangular child window that displays a graph. The DsCgraph object is not part of the standard Infor ERP Enterprise Server object library. It is a third-party OCX control. It can be controlled from 3GL scripts in the same way as standard objects. Several graphs can be displayed simultaneously within the same main window. A wide range of graph types is supported.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgrid": {
    "name": "DsCgrid",
    "type": "function",
    "syntax": "function DsCgrid()",
    "description": "A DsCgrid object is a rectangular child window that displays a spreadsheet grid. Cells in the grid can contain not only data but also controls such as text boxes, list boxes, and check boxes.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscgwindow": {
    "name": "DsCgwindow",
    "type": "function",
    "syntax": "function DsCgwindow()",
    "description": "A graphical window (DsCgwindow) is a window in which applications can draw graphical parts such as lines, rectangles, polygons, and so on. Graphical windows also support user interface controls such as buttons, edit controls, list boxes, and so on.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsclabel": {
    "name": "DsClabel",
    "type": "function",
    "syntax": "function DsClabel()",
    "description": "A DsClabel object provides a text string for labeling other objects.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscmwindow": {
    "name": "DsCmwindow",
    "type": "function",
    "syntax": "function DsCmwindow()",
    "description": "A main window (DsCmwindow) acts as the frame window for applications. It is used for starting processes and for creating graphical and character windows. Typically, a main window contains a border, title bar, control menu box, sizing controls, menu bar, toolbar, status bar, work area, and scroll bars.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscpixmap": {
    "name": "DsCpixmap",
    "type": "function",
    "syntax": "function DsCpixmap()",
    "description": "A DsCpixmap object defines a graphical image. It consists of a two-dimensional array of pixels, with a specified width, height, and depth (number of planes), but no screen coordinates. A pixmap is a resource that is used by other objects that can display an image. Objects that can use a pixmap include DsCdrawnButton, DsCgpImage and DsCtoolBar objects.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscpushbutton": {
    "name": "DsCpushButton",
    "type": "function",
    "syntax": "function DsCpushButton()",
    "description": "A pushbutton, also referred to as a command button, represents an action that is carried out when the user selects the button. A pushbutton displays a text label.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscradiobox": {
    "name": "DsCradioBox",
    "type": "function",
    "syntax": "function DsCradioBox()",
    "description": "A DsCradioBox object is an instance of DsCrowColumn object that contains radio buttons (also referred to as option buttons).",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscradiobutton": {
    "name": "DsCradioButton",
    "type": "function",
    "syntax": "function DsCradioButton()",
    "description": "A radio button (also referred to as an option button) represents a single option within a set of mutually exclusive options. It is either set or not set. Within a group of radio buttons, only one option in the group can be set. Selecting one radio button automatically deselects all others in the group. A partially filled in circle indicates the currently selected button. All radio buttons have an associated label.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscrowcolumn": {
    "name": "DsCrowColumn",
    "type": "function",
    "syntax": "function DsCrowColumn()",
    "description": "A DsCrowColumn object is a container object that displays its children in rows and columns.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscscrollbar": {
    "name": "DsCscrollbar",
    "type": "function",
    "syntax": "function DsCscrollbar()",
    "description": "Scroll bars enable users to scroll data that is too large to fit in the viewing window. They can be either horizontal or vertical. A scroll bar consists of the following components:",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscscrollwindow": {
    "name": "DsCscrollWindow",
    "type": "function",
    "syntax": "function DsCscrollWindow()",
    "description": "A DsCscrollWindow object provides a scrollable view of a child object. It supports a single child object only. Scroll bars enable users to view the data not currently visible in the window. Scroll bars are visible only when the child object is larger than the scroll window.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscslider": {
    "name": "DsCslider",
    "type": "function",
    "syntax": "function DsCslider()",
    "description": "A slider object is used to set a value in a continuous range of values (for example, volume or brightness). It consists of a scroll bar that represents the full range of values and a movable slider whose position represents the current value. It also includes labels that indicate the slider's current, maximum, and minimum values. Tick marks are optional.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dscstatusbar": {
    "name": "DsCstatusBar",
    "type": "function",
    "syntax": "function DsCstatusBar()",
    "description": "A DsCstatusBar object provides a status bar that displays help and status information in a main window (DsCmwindow object). Each main window can include one DsCstatusBar object. The status bar is positioned at the bottom of the window. It occupies part of the client area of the window. When a status bar is added to a main window, the window size is adjusted so that the size of the client area is not affected.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsctabframe": {
    "name": "DsCtabFrame",
    "type": "function",
    "syntax": "function DsCtabFrame()",
    "description": "A DsCtabFrame object provides a window with one or more form tabs. The tabs can be arranged in a single line or in multiple lines. When tabs are arranged on a single line, scroll buttons are added automatically if the window is not large enough to accommodate all the tabs.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsctemplate": {
    "name": "DsCtemplate",
    "type": "function",
    "syntax": "function DsCtemplate()",
    "description": "A DsCtemplate object defines a set of attributes that can be applied to other objects.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsctoolbar": {
    "name": "DsCtoolBar",
    "type": "function",
    "syntax": "function DsCtoolBar()",
    "description": "A DsCtoolBar object defines a toolbar for a main window (DsCmwindow). An application creates the entire toolbar with a single create.object() call. Subsequently, it can use change.object() toadd, remove, change, enable, and disable toolbar buttons.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "dsctree": {
    "name": "DsCtree",
    "type": "function",
    "syntax": "function DsCtree()",
    "description": "A DsCtree object defines a tree view control. Like any tree view control, it displays a list of items as an indented outline that reflects the hierarchical relationship between the items.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "user interface objects: example": {
    "name": "User interface objects: example",
    "type": "function",
    "syntax": "function User interface objects: example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "get.object": {
    "name": "get.object",
    "type": "function",
    "syntax": "function long get.object (long object_id, long attribute, void value, long size)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The object ID, as returned by create.object() when the object was created."
      },
      {
        "type": "long",
        "name": "attribute",
        "description": "The attribute you want to retrieve (for example, DsNtitle or DsNbackground)."
      },
      {
        "type": "void",
        "name": "value",
        "description": "This returns the current value of the specified attribute."
      },
      {
        "type": "long",
        "name": "size",
        "description": "For attributes of type void data and long array, this returns the size of the data or array."
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "functions_user_interface_objects"
  },
  "get.pixmap.info": {
    "name": "get.pixmap.info",
    "type": "function",
    "syntax": "function long get.pixmap.info (ref string buffer, ref long num_colors, ref long width, ref long height)",
    "description": "This retrieves information about a picture, in .gif format, that has been read with the seq.read() function. It returns the number of colors in the picture and the picture's width and height. When a picture is used in an object, the width and height values are necessary for determining the amount of memory that must be allocated for the picture.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "The buffer containing the data retrieved by seq.read() ."
      },
      {
        "type": "ref long",
        "name": "num_colors",
        "description": "This returns the number of colors used in the picture."
      },
      {
        "type": "ref long",
        "name": "width",
        "description": "This returns the width of the picture, in pixels."
      },
      {
        "type": "ref long",
        "name": "height",
        "description": "This returns the height of the picture, in pixels."
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "functions_user_interface_objects"
  },
  "get.sub.object": {
    "name": "get.sub.object",
    "type": "function",
    "syntax": "function long get.sub.object (long object, long sub_object_id [, long attribute] [, ref void value] [, ref long size])",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object",
        "description": "The ID of the parent object, as returned by create.object() when the object was created."
      },
      {
        "type": "long",
        "name": "sub_object_id",
        "description": "The ID of the subobject of the specified parent object."
      },
      {
        "type": "[long",
        "name": "attribute ]",
        "description": "The attribute you want to retrieve (for example, DsNgcBackground or DsNgcForeground)."
      },
      {
        "type": "[ref void",
        "name": "value ]",
        "description": "This returns the current value of the specified attribute."
      },
      {
        "type": "[ref long",
        "name": "size ]",
        "description": "For attributes of type void data and long array, this returns the size of the data or array."
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "functions_user_interface_objects"
  },
  "inherit.object": {
    "name": "inherit.object",
    "type": "function",
    "syntax": "function void inherit.object (long process_nr, long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "process_nr",
        "description": "The process ID of the parent process."
      },
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object that must be inherited."
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "lower.object": {
    "name": "lower.object",
    "type": "function",
    "syntax": "function void lower.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "map.object": {
    "name": "map.object",
    "type": "function",
    "syntax": "function void map.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "objects and subobjects": {
    "name": "Objects and subobjects",
    "type": "function",
    "syntax": "function Objects and subobjects()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "user interface objects overview": {
    "name": "User interface objects overview",
    "type": "function",
    "syntax": "function User interface objects overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "query.object": {
    "name": "query.object",
    "type": "function",
    "syntax": "function long query.object (long object_id, long attribute_in, void value_in, long size_iin, long attribute_in, ref void value_out, ref long size_out)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object to be queried, as returned by create.object() when the object was created."
      },
      {
        "type": "long",
        "name": "attribute_in",
        "description": "You can use one or more sets of these arguments to specify the input attributes for the query. For each attribute you specify, you must include the attribute type (for example, DsNcolumns), and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "void",
        "name": "value_in",
        "description": ""
      },
      {
        "type": "long",
        "name": "size_iin",
        "description": ""
      },
      {
        "type": "long",
        "name": "attribute_in",
        "description": "You can use one or more sets of these arguments to specify the output of the query. For each attribute you specify, you must include the attribute type (for example, DsNcontrol). The function returns the current value of the attribute. For attributes of type void data or long array, it also returns the size of the data or array."
      },
      {
        "type": "ref void",
        "name": "value_out",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "size_out",
        "description": ""
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "functions_user_interface_objects"
  },
  "query.sub.object": {
    "name": "query.sub.object",
    "type": "function",
    "syntax": "function long query.sub.object (long object_id, long sub_object_id, long attribute_in, value_in, size_in, void value_in, long size_in, long attribute_in, ref void value_out, ref long size_out)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object to which the subobject belongs."
      },
      {
        "type": "long",
        "name": "sub_object_id",
        "description": "The ID of the subobject within the specified object."
      },
      {
        "type": "long",
        "name": "attribute_in, value_in, size_in",
        "description": "You can use one or more sets of these arguments to specify the input attributes for the query. For each attribute you specify, you must include the attribute type and the attribute value. For attributes of type void data or long array, you must also include the size of the data or array."
      },
      {
        "type": "void",
        "name": "value_in",
        "description": ""
      },
      {
        "type": "long",
        "name": "size_in",
        "description": ""
      },
      {
        "type": "long",
        "name": "attribute_in",
        "description": "You can use one or more sets of these arguments to specify the output of the query. For each attribute you specify, you must include the attribute type. The function returns the current value of the attribute. For attributes of type void data or long array, it also returns the size of the data or array."
      },
      {
        "type": "ref void",
        "name": "value_out",
        "description": ""
      },
      {
        "type": "ref long",
        "name": "size_out",
        "description": ""
      }
    ],
    "returnValue": "TRUE success FALSE error",
    "category": "functions_user_interface_objects"
  },
  "raise.object": {
    "name": "raise.object",
    "type": "function",
    "syntax": "function void raise.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "set.focus": {
    "name": "set.focus",
    "type": "function",
    "syntax": "function void set.focus (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "set.sensitive": {
    "name": "set.sensitive",
    "type": "function",
    "syntax": "function void set.sensitive (long object_id, long status)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": "The ID of the object."
      },
      {
        "type": "long",
        "name": "status",
        "description": "The status that must be set for the object. Possible values are: DSSETSENSITIVE DSSETINSENSITIVE When the status of an object is set to insensitive, the object and its children are disabled."
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "user interface objects synopsis": {
    "name": "User interface objects synopsis",
    "type": "function",
    "syntax": "function User interface objects synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "unmap.object": {
    "name": "unmap.object",
    "type": "function",
    "syntax": "function void unmap.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "unset.focus": {
    "name": "unset.focus",
    "type": "function",
    "syntax": "function void unset.focus (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "update.object": {
    "name": "update.object",
    "type": "function",
    "syntax": "function void update.object (long object_id)",
    "description": "Deprecated. This function is only supported for Baan Windows and its usage is therefore deprecated.",
    "arguments": [
      {
        "type": "long",
        "name": "object_id",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_user_interface_objects"
  },
  "uuid.format$": {
    "name": "uuid.format$",
    "type": "function",
    "syntax": "function string uuid.format$ (string uuid.compact)",
    "description": "Computes the standard string representation, e.g. \"17293b6c-4d4d-11d6-af08-080009da70ff\", of a UUID which is supplied in compact string representation, e.g. \"Fyk4JE1NEdaO4AgACdpw/w\".",
    "arguments": [
      {
        "type": "string",
        "name": "uuid.compact",
        "description": "Input string with the compact string representation of a UUID, e.g. \"Fyk4JE1NEdaO4AgACdpw/w\"."
      }
    ],
    "returnValue": "The standard string representation of the supplied UUID is returned, e.g. \"17293b6c-4d4d-11d6-af08-080009da70ff\". The size of the standard string representation of a UUID is given by the predefined constant UUID.SIZE.STRING. Its value is 36. When the supplied input is not a correct compact representation of a UUID (i.e. when it does not consist of exactly UUID.SIZE.COMPACT characters from the Base64 character set, padded at the end with spaces only), then an empty string \"\" is returned.",
    "category": "functions_uuid"
  },
  "uuid.generate$": {
    "name": "uuid.generate$",
    "type": "function",
    "syntax": "function string uuid.generate$ ()",
    "description": "Generates a UUID and returns its compact string representation, e.g. \"Fyk4JE1NEdaO4AgACdpw/w\".",
    "arguments": [],
    "returnValue": "The compact string representation of the generated UUID is returned, e.g. \"Fyk4JE1NEdaO4AgACdpw/w\". The size of the compact string representation of a UUID is given by the predefined constant UUID.SIZE.COMPACT. Its value is 22.",
    "category": "functions_uuid"
  },
  "uuid overview": {
    "name": "UUID overview",
    "type": "function",
    "syntax": "function UUID overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uuid"
  },
  "uuid synopsis": {
    "name": "UUID synopsis",
    "type": "function",
    "syntax": "function UUID synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_uuid"
  },
  "at.base": {
    "name": "at.base",
    "type": "function",
    "syntax": "function long at.base (long process_id, string basic_variable_name, void unused [, long position, ...], <ref|const> <type> based_variable [, long length, ...])",
    "description": "Use this function to base one variable (the based_variable ) on an external variable in another process (the basic_variable ). The two variables then use the same memory area.",
    "arguments": [
      {
        "type": "long",
        "name": "process_id",
        "description": "The ID of the process in which the basic_variable ) is declared. This process must be started before the current process and must be ended after the current process."
      },
      {
        "type": "string",
        "name": "basic_variable_name",
        "description": "The name of the external basic_variable on which the based_variable is to be based. The basic_variable must be declared as EXTERN. The basic_variable must have the same type as the based_variable . If the basic_variable is declared as CONST, then the based_variable must also be declared as CONST."
      },
      {
        "type": "void",
        "name": "unused",
        "description": "This argument is unused. The bic compiler generates a warning about this argument, but the warning is suppressed by default. Use compiler option -W8 to switch it on."
      },
      {
        "type": "[long",
        "name": "position, ... ]",
        "description": "Optional additional position arguments, which specify the start position of the based_variable in the corresponding dimension of the basic_variable . The default start position is 1."
      },
      {
        "type": "<ref|const> <type>",
        "name": "based_variable",
        "description": "The variable which will be based on the basic_variable . The based_variable must have the same type as the basic_variable . The based_variable must be declared as BASED. If the basic_variable is declared as CONST, then the based_variable must also be declared as CONST."
      },
      {
        "type": "[long",
        "name": "length, ... ]",
        "description": "Optional additional length arguments, which specify the length of the based_variable in the corresponding dimension. The length plus the start position must not exceed the length reserved for the basic_variable . If you pass value -1 for a specific length argument, the based_variable uses the memory space of the basic_variable from the specified start position to the end position. If you pass value 0 for a specific length argument, the based_variable uses the memory space of the basic_variable from the specified start position for the declared length of the based_variable ."
      }
    ],
    "returnValue": "0 Success. -1 Error.",
    "category": "functions_variables_based"
  },
  "variables (based) overview and synopsis": {
    "name": "Variables (based) overview and synopsis",
    "type": "function",
    "syntax": "function Variables (based) overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_variables_based"
  },
  "changed": {
    "name": "changed",
    "type": "function",
    "syntax": "function boolean changed (string variable [, long keep.flag.raised])",
    "description": "This compares the current value of the specified variable with its checkpoint value to determine whether or not the value has changed.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": "The variable that is monitored."
      },
      {
        "type": "[long",
        "name": "keep.flag.raised ]",
        "description": "If the parameter keep.flag.raised gets the value KEEP.CHANGED.FLAG.RAISED, the function changed() works as a 'peek' and won't touch the status of the traced variable. See also the NOTE."
      }
    ],
    "returnValue": "TRUE variable has changed FALSE variable has not changed",
    "category": "functions_variables_checking_changes"
  },
  "variables (checking changes): sample program": {
    "name": "Variables (checking changes): sample program",
    "type": "function",
    "syntax": "function Variables (checking changes): sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "not.curr": {
    "name": "not.curr",
    "type": "function",
    "syntax": "function void not.curr (string variable)",
    "description": "This switches the current and previous values of the specified variable. This is considered a value change by the checking mechanism. So if you subsequently call changed() , that function will return TRUE.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "off.change.check": {
    "name": "off.change.check",
    "type": "function",
    "syntax": "function void off.change.check (string variable)",
    "description": "This switches off the checking mechanism for the specified variable. Changes to the variable are no longer monitored by the checking mechanism.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "on.change.check": {
    "name": "on.change.check",
    "type": "function",
    "syntax": "function void on.change.check (string variable)",
    "description": "This starts the checking mechanism by setting a checkpoint for the specified variable. The current value of the variable becomes the checkpoint value.",
    "arguments": [
      {
        "type": "string",
        "name": "variable",
        "description": ""
      }
    ],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "variables (checking changes) overview": {
    "name": "Variables (checking changes) overview",
    "type": "function",
    "syntax": "function Variables (checking changes) overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "variables (checking changes) synopsis": {
    "name": "Variables (checking changes) synopsis",
    "type": "function",
    "syntax": "function Variables (checking changes) synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_variables_checking_changes"
  },
  "export": {
    "name": "export",
    "type": "function",
    "syntax": "function [long] export (string var_name, void value)",
    "description": "Export assigns the value of the specified variable of the parent process. This parent process is not always identified by the variable parent in case of dynamic index switching. When using dynamic index switching, the parent process is sometimes stopped and restarted. This causes a different parent process, whereas the variable parent is not updated.",
    "arguments": [
      {
        "type": "string",
        "name": "var_name",
        "description": "The name of the variable in the parent process export the value to"
      },
      {
        "type": "void",
        "name": "value",
        "description": "The value to export to the parent process"
      }
    ],
    "returnValue": "0 error; probably variable not found in the parent process 1 success",
    "category": "functions_variables_interprocess_transfer"
  },
  "get.indexed.var": {
    "name": "get.indexed.var",
    "type": "function",
    "syntax": "function [long] get.indexed.var (long processno, string variable_name, ref void destination, long dim1 [, dim2, dim3, dim4 ])",
    "description": "This retrieves the value of the specified variable. It is the same as get.var() except that it enables retrieval of individual array elements.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": "The process from which the variable is to be retrieved. You can specify the process ID, or you can use the predefined variables pid or parent ."
      },
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the variable to be retrieved (this must be a lower case string). The variable can be a single variable or an array and must be declared as external."
      },
      {
        "type": "ref void",
        "name": "destination",
        "description": "Reference argument to which the value of the retrieved variable must be assigned. Implicit conversion of the value of the retrieved variable from its original type to the type of the reference argument is performed."
      },
      {
        "type": "long",
        "name": "dim1 [, dim2, dim3, dim4 ]",
        "description": "Use these to specify a particular array element to be retrieved. To retrieve a single variable, set dim1 to 1 and omit the other dim arguments."
      }
    ],
    "returnValue": "0 success 1 general error 2 incorrect number of dimensions 3 variable not found 4 array element not available",
    "category": "functions_variables_interprocess_transfer"
  },
  "get.var": {
    "name": "get.var",
    "type": "function",
    "syntax": "function [long] get.var (long processno, string variable_name, ref void destination)",
    "description": "This retrieves the value of the specified variable. The variable can be a single variable of any type or an array.",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": "The process from which the variable is to be retrieved. You can specify the process ID, or you can use the predefined variables pid or parent ."
      },
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the variable to be retrieved (this must be a lower case string)."
      },
      {
        "type": "ref void",
        "name": "destination",
        "description": "Reference argument to which the value of the retrieved variable must be assigned. Implicit conversion of the value of the retrieved variable from its original type to the type of the reference argument is performed."
      }
    ],
    "returnValue": "0 error; probably variable not found 1 success",
    "category": "functions_variables_interprocess_transfer"
  },
  "import.4gl.var": {
    "name": "import.4gl.var",
    "type": "function",
    "syntax": "function void import.4gl.var (string variable_name, ref void value)",
    "description": "Imports a 'predefined' 4GL variable. Like number.of.marks which is actually a macro.",
    "arguments": [
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the variable to be retrieved (this must be a lower case string). Alternately, you can specify a variable in which the name is stored."
      },
      {
        "type": "ref void",
        "name": "value",
        "description": "This stores the value of the retrieved variable."
      }
    ],
    "returnValue": "",
    "category": "functions_variables_interprocess_transfer"
  },
  "import": {
    "name": "import",
    "type": "function",
    "syntax": "function [long] import (string variable_name, ref void value)",
    "description": "Import retrieves the value of the specified variable of the parent process. This parent process is not always identified by the variable parent in case of dynamic index switching. When using dynamic index switching, the parent process is sometimes killed and restarted. This causes a different parent process, whereas the variable parent is not updated.",
    "arguments": [
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the variable to be retrieved (this must be a lower case string). Alternately, you can specify a variable in which the name is stored."
      },
      {
        "type": "ref void",
        "name": "value",
        "description": "This stores the value of the retrieved variable."
      }
    ],
    "returnValue": "0 error; probably variable not found in the parent process 1 success",
    "category": "functions_variables_interprocess_transfer"
  },
  "variables (inter-process transfer) overview and synopsis": {
    "name": "Variables (inter-process transfer) overview and synopsis",
    "type": "function",
    "syntax": "function Variables (inter-process transfer) overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_variables_interprocess_transfer"
  },
  "put.indexed.var": {
    "name": "put.indexed.var",
    "type": "function",
    "syntax": "function [long] put.indexed.var (long processno, string variable_name, void value, long dim1 [, dim2, dim3, dim4 ])",
    "description": "",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": "The process to which the destination variable belongs. You can specify the process ID, or you can use the predefined variables pid or parent ."
      },
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the external variable in the other process (this must be a lower case string)."
      },
      {
        "type": "void",
        "name": "value",
        "description": "The value to be assigned to the variable. Implicit conversion of the supplied value from its original type to the type of the specified variable is performed."
      },
      {
        "type": "long",
        "name": "dim1 [, dim2, dim3, dim4 ]",
        "description": "Use these to specify a particular array element to which the new value is to be assigned. To assign a single variable value, set dim1 to 1 and omit the other dim arguments."
      }
    ],
    "returnValue": "0 success 1 general error 2 incorrect number of dimensions 3 variable not found 4 array element not available",
    "category": "functions_variables_interprocess_transfer"
  },
  "put.var": {
    "name": "put.var",
    "type": "function",
    "syntax": "function [long] put.var (long processno, string variable_name, void value)",
    "description": "",
    "arguments": [
      {
        "type": "long",
        "name": "processno",
        "description": "The process to which the destination variable belongs. You can specify the process ID, or you can use the predefined variables pid or parent ."
      },
      {
        "type": "string",
        "name": "variable_name",
        "description": "The name of the external variable in the other process (this must be a lower case string)."
      },
      {
        "type": "void",
        "name": "value",
        "description": "The value to be assigned to the variable. Implicit conversion of the supplied value from its original type to the type of the specified variable is performed."
      }
    ],
    "returnValue": "0 error; probably variable not found 1 success",
    "category": "functions_variables_interprocess_transfer"
  },
  "functions with variable number of arguments: sample program": {
    "name": "Functions with variable number of arguments: sample program",
    "type": "function",
    "syntax": "function Functions with variable number of arguments: sample program()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_varying_arguments"
  },
  "get.arg.type": {
    "name": "get.arg.type",
    "type": "function",
    "syntax": "function long get.arg.type (long arg_no)",
    "description": "This function returns the type of the specified argument.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which get.arg.type() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      }
    ],
    "returnValue": "The function can return any of the following values: VAR.TYPE.LONG The specified argument is of type long or boolean. VAR.TYPE.DOUBLE The specified argument is of type double. VAR.TYPE.STRING The specified argument is of type string. VAR.TYPE.MULTIBYTE The specified argument is of type multibyte string. VAR.TYPE.UNKNOWN arg_no is out of range, or the specified argument is not of one of the allowed types. For historic reasons, these values are defined in terms of other named constants. The definitions are available when the tiv level is at least 2010 or when USE_VAR_TYPE_DEFINES is defined to a non-zero value. #if ES_TIV_LEVEL >= 2010 or USE_VAR_TYPE_DEFINES #define VAR.TYPE.LONG DB.LONG #define VAR.TYPE.DOUBLE DB.DOUBLE #define VAR.TYPE.STRING DB.STRING #define VAR.TYPE.MULTIBYTE DB.MULTIBYTE #define VAR.TYPE.UNKNOWN (-1) #endif",
    "category": "functions_varying_arguments"
  },
  "get.argc": {
    "name": "get.argc",
    "type": "function",
    "syntax": "function long get.argc ()",
    "description": "This function returns the number of arguments supplied to the currently executing function (i.e. the function in which get.argc() is called). Once you know this number, you can read from and write to particular arguments using the other functions.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_varying_arguments"
  },
  "get.boolean.arg": {
    "name": "get.boolean.arg",
    "type": "function",
    "syntax": "function boolean get.boolean.arg (long arg_no)",
    "description": "The function get.boolean.arg() returns the value of the specified argument, converted to a boolean.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which get.boolean.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      }
    ],
    "returnValue": "The value of the specified argument, converted to a boolean. Implicit conversion of the value of the specified argument from its original type to type boolean is performed. If arg_no is out of range, the value false is returned.",
    "category": "functions_varying_arguments"
  },
  "get.double.arg": {
    "name": "get.double.arg",
    "type": "function",
    "syntax": "function double get.double.arg (long arg_no)",
    "description": "The function get.double.arg() returns the value of the specified argument, converted to a double.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which get.double.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      }
    ],
    "returnValue": "The value of the specified argument, converted to a double. Implicit conversion of the value of the specified argument from its original type to type double is performed. If arg_no is out of range, the value 0.0 is returned.",
    "category": "functions_varying_arguments"
  },
  "get.long.arg": {
    "name": "get.long.arg",
    "type": "function",
    "syntax": "function long get.long.arg (long arg_no)",
    "description": "The function get.long.arg() returns the value of the specified argument, converted to a long.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which get.long.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      }
    ],
    "returnValue": "The value of the specified argument, converted to a long. Implicit conversion of the value of the specified argument from its original type to type long is performed. If arg_no is out of range, the value 0 is returned.",
    "category": "functions_varying_arguments"
  },
  "get.string.arg": {
    "name": "get.string.arg",
    "type": "function",
    "syntax": "function string get.string.arg (long arg_no)",
    "description": "The function get.string.arg() returns the value of the specified argument, converted to a string.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which get.string.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      }
    ],
    "returnValue": "The value of the specified argument, converted to a string. Implicit conversion of the value of the specified argument from its original type to type string is performed. If arg_no is out of range, the empty string is returned.",
    "category": "functions_varying_arguments"
  },
  "functions with variable number of arguments: overview": {
    "name": "Functions with variable number of arguments: overview",
    "type": "function",
    "syntax": "function Functions with variable number of arguments: overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_varying_arguments"
  },
  "put.boolean.arg": {
    "name": "put.boolean.arg",
    "type": "function",
    "syntax": "function long put.boolean.arg (long arg_no, boolean value)",
    "description": "The function put.boolean.arg() assigns the supplied boolean value to the specified argument, after conversion to the type of the argument.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which put.boolean.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      },
      {
        "type": "boolean",
        "name": "value",
        "description": "The value to assign to the specified argument. Implicit conversion of the supplied boolean value to the type of the specified argument is performed."
      }
    ],
    "returnValue": "0 The function terminated successfully. -1 The function terminated with an error: arg_no is out of range or it is not possible to assign a value to the specified argument.",
    "category": "functions_varying_arguments"
  },
  "put.double.arg": {
    "name": "put.double.arg",
    "type": "function",
    "syntax": "function long put.double.arg (long arg_no, double value)",
    "description": "The function put.double.arg() assigns the supplied double value to the specified argument, after conversion to the type of the argument.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which put.double.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      },
      {
        "type": "double",
        "name": "value",
        "description": "The value to assign to the specified argument. Implicit conversion of the supplied double value to the type of the specified argument is performed."
      }
    ],
    "returnValue": "0 The function terminated successfully. -1 The function terminated with an error: arg_no is out of range or it is not possible to assign a value to the specified argument.",
    "category": "functions_varying_arguments"
  },
  "put.long.arg": {
    "name": "put.long.arg",
    "type": "function",
    "syntax": "function long put.long.arg (long arg_no, long value)",
    "description": "The function put.long.arg() assigns the supplied long value to the specified argument, after conversion to the type of the argument.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which put.long.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      },
      {
        "type": "long",
        "name": "value",
        "description": "The value to assign to the specified argument. Implicit conversion of the supplied long value to the type of the specified argument is performed."
      }
    ],
    "returnValue": "0 The function terminated successfully. -1 The function terminated with an error: arg_no is out of range or it is not possible to assign a value to the specified argument.",
    "category": "functions_varying_arguments"
  },
  "put.string.arg": {
    "name": "put.string.arg",
    "type": "function",
    "syntax": "function long put.string.arg (long arg_no, string value)",
    "description": "The function put.string.arg() assigns the supplied string value to the specified argument, after conversion to the type of the argument.",
    "arguments": [
      {
        "type": "long",
        "name": "arg_no",
        "description": "The sequence number of an argument supplied to the currently executing function (i.e. the function in which put.string.arg() is called). The allowed range for this sequence number is 1 ... get.argc() ."
      },
      {
        "type": "string",
        "name": "value",
        "description": "The value to assign to the specified argument. Implicit conversion of the supplied string value to the type of the specified argument is performed."
      }
    ],
    "returnValue": "0 The function terminated successfully. -1 The function terminated with an error: arg_no is out of range or it is not possible to assign a value to the specified argument.",
    "category": "functions_varying_arguments"
  },
  "functions with variable number of arguments: synopsis": {
    "name": "Functions with variable number of arguments: synopsis",
    "type": "function",
    "syntax": "function Functions with variable number of arguments: synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_varying_arguments"
  },
  "document viewer example": {
    "name": "Document Viewer example",
    "type": "function",
    "syntax": "function Document Viewer example()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_vwr"
  },
  "document viewer overview": {
    "name": "Document Viewer overview",
    "type": "function",
    "syntax": "function Document Viewer overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_vwr"
  },
  "document viewer synopsis": {
    "name": "Document Viewer synopsis",
    "type": "function",
    "syntax": "function Document Viewer synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_vwr"
  },
  "vwr.bms.received": {
    "name": "vwr.bms.received",
    "type": "function",
    "syntax": "function void vwr.bms.received (long sender.id, const string mask(), const string mss(), long length)",
    "description": "This is the callback function which must be defined in the 3GL script. This function will be called by the Document Viewer when a BMS message is received which is not internally known by the Document Viewer library. This can be used to receive PRCM messages. While in this callback function, the script can call functions like : prcm.bms.is.notification() and prcm.get.data().",
    "arguments": [
      {
        "type": "long",
        "name": "sender.id",
        "description": "The Baan process which has send this message."
      },
      {
        "type": "const string",
        "name": "mask()",
        "description": "The mask with which the message has been send"
      },
      {
        "type": "const string",
        "name": "mss()",
        "description": "The actual BMS message"
      },
      {
        "type": "long",
        "name": "length",
        "description": "The length of the message mss"
      }
    ],
    "returnValue": "",
    "category": "functions_vwr"
  },
  "vwr.init": {
    "name": "vwr.init",
    "type": "function",
    "syntax": "function long vwr.init ()",
    "description": "This function must be the first to be called, it initializes the Document Viewer. The Document Viewer is not supported in Worktop. When this session was started from a parent session in modeless mode, this function will reactive the parent session. So any imports which must be done by this session from the parent should be done before this function is called.",
    "arguments": [],
    "returnValue": "0 Success -1 Failure, not supported with this user interface",
    "category": "functions_vwr"
  },
  "vwr.start": {
    "name": "vwr.start",
    "type": "function",
    "syntax": "function void vwr.start ()",
    "description": "This function activates the Document Viewer. Control will be returned to the script after the Viewer has been closed. Function vwr.init must have been called before vwr.start can be called.",
    "arguments": [],
    "returnValue": "",
    "category": "functions_vwr"
  },
  "webui/ln ui support functions overview and synopsis": {
    "name": "WebUI/LN UI support functions overview and synopsis",
    "type": "function",
    "syntax": "function WebUI/LN UI support functions overview and synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_webtop"
  },
  "tc.ignore.process": {
    "name": "tc.ignore.process",
    "type": "function",
    "syntax": "function void tc.ignore.process (boolean flag [, long processno])",
    "description": "This function indicates if the WebUI or LN UI should ignore this session (process). By default, the WebUI/LN UI does not ignore a session. Therefore this function should only be called from a 3GL session which does not present a User Interface. When this function is not called from such 3GL session, the WebUI/LN UI will seriously delay when such a 3GL Session is started.",
    "arguments": [
      {
        "type": "boolean",
        "name": "flag",
        "description": "true when the WebUI/LN UI must ignore this session, otherwise false."
      },
      {
        "type": "[long",
        "name": "processno ]",
        "description": "The process number of the session to which this function applies. When omitted this function is applied to the current session"
      }
    ],
    "returnValue": "",
    "category": "functions_webtop"
  },
  "tc.is.html.ui": {
    "name": "tc.is.html.ui",
    "type": "function",
    "syntax": "function boolean tc.is.html.ui ()",
    "description": "This function returns if the running thin-client is supporting HTMLUI mode.",
    "arguments": [],
    "returnValue": "true support HTMLUI mode by running thin-client false NO support of HTMLUI mode in current configuration",
    "category": "functions_webtop"
  },
  "tc.is.thin.client": {
    "name": "tc.is.thin.client",
    "type": "function",
    "syntax": "function boolean tc.is.thin.client ()",
    "description": "This function returns whether you are running in thin-client mode.",
    "arguments": [],
    "returnValue": "true running in thin-client mode false NOT running in thin-client mode",
    "category": "functions_webtop"
  },
  "dsk.add.command": {
    "name": "dsk.add.command",
    "type": "function",
    "syntax": "function void dsk.add.command (string command)",
    "description": "Define a Workbench 3GL command. This method must be called before the call to start.ext.desk() is done.",
    "arguments": [
      {
        "type": "string",
        "name": "command",
        "description": "This parameter must contain the name of an external function which is defined in the 3GL script. This function will be called when the Workbench client application invokes this call. The signature of this 3GL function must be: function extern string command(long paramsNode) This call back function is called when the Workbench client application wants to execute this command. The return value of this function will be returned to the Workbench client application. The format of this string must be agreed between the Workbench 3GL Session and the Workbench client application. The parameter paramsNode can be used to pass additional parameters from the Workbench client to this command. When parameters are passed by the Workbench client application, paramsNode is an XML object node, which contains one or more attributes. These attributes correspond with the \"commandParameters\" passed to the ExecuteCommand() client method"
      }
    ],
    "returnValue": "",
    "category": "functions_workbench_sessions"
  },
  "workbench sessions overview": {
    "name": "Workbench Sessions overview",
    "type": "function",
    "syntax": "function Workbench Sessions overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_workbench_sessions"
  },
  "start.ext.desk": {
    "name": "start.ext.desk",
    "type": "function",
    "syntax": "function long start.ext.desk (string application [, long options] [, string title])",
    "description": "Start the Workbench (desk) application. This function will return when the Workbench application is closed by the user.",
    "arguments": [
      {
        "type": "string",
        "name": "application",
        "description": "This is the Web application name which implements the Workbench application. In case of a Silverlight based Workbench, this is the final part of the Web application on the Web server. For example: \"BuyerDesk.aspx\". In case of a HTML based Workbench, this is always fixed to the string: \"workbench\". This function will construct the complete URL to start the Workbench application as follows: <serverurl>/<sessioncode>_<version>_<release>[_<customer>]/<application> serverurl This is the URL configured in session \"Workbench Web Server (ttaad7530m000)\" sessioncode This is the code of the current (3GL) Workbench session\" version This is the version part of the VRC of the additional file related to the current (3GL) Workbench session\" customer This is the customer part of the VRC of the additional file related to the current (3GL) Workbench session (may be empty)\" So for example a complete URL might look like: https://nlbavwtech5.infor.com:8442/tdpur8350m000_B60_a_sy59/BuyerDesk.aspx"
      },
      {
        "type": "[long",
        "name": "options ]",
        "description": "Optional argument in which Workbench startup options can be specified. The options which can be specified here are: DSK.STATUSBAR This means that a standard status bar should be shown for this session. When this option is not passed, no status bar will be shown for this session. DSK.SINGLEINSTANCE This means that only one instance of this application can be started per user per Bshell. DSK.HTML This means that this is a HTML based Workbench which is based on the Workbench SDK. The default value (so when this option is not present) is: DSK.STATUSBAR + DSK.SINGLEINSTANCE"
      },
      {
        "type": "[string",
        "name": "title ]",
        "description": "Optional argument in which a non-standard title of the Workbench session can be specified. When this argument is not present, the session description is used as the Workbench title. This argument can be usefull when the same workbench application should have a different title which can only be determined at runtime."
      }
    ],
    "returnValue": "0 on success -1 when this function fails",
    "category": "functions_workbench_sessions"
  },
  "workbench sessions synopsis": {
    "name": "Workbench Sessions synopsis",
    "type": "function",
    "syntax": "function Workbench Sessions synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_workbench_sessions"
  },
  "xml object api": {
    "name": "XML object API",
    "type": "function",
    "syntax": "function XML object API()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "xml object constraints": {
    "name": "XML object constraints",
    "type": "function",
    "syntax": "function XML object constraints()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "verify the used characters": {
    "name": "Verify the used characters",
    "type": "function",
    "syntax": "function long xmlContainsValidCharactersOnly (string inputstring)",
    "description": "This function verifies whether the supplied string contains valid characters only.",
    "arguments": [
      {
        "type": "string",
        "name": "inputstring",
        "description": "inputstring is converted from TSS to UTF-8, and the resulting characters are checked for validity."
      }
    ],
    "returnValue": "1 Success; inputstring contains valid characters only. 0 Error; conversion of inputstring from TSS to UTF-8 failed or a forbidden character was encountered in the resulting UTF-8 string.",
    "category": "functions_xml"
  },
  "create an element node with data node": {
    "name": "Create an Element Node with Data Node",
    "type": "function",
    "syntax": "function long xmlNewDataElement (string name, string data [, long parentNode])",
    "description": "Create a new XML_ELEMENT node and new XML_DATA node. The XML_DATA node is the first child of the XML_ELEMENT node.",
    "arguments": [
      {
        "type": "string",
        "name": "name",
        "description": "name contains the name of the XML_ELEMENT node."
      },
      {
        "type": "string",
        "name": "data",
        "description": "data contains the data for the XML_DATA node."
      },
      {
        "type": "[long",
        "name": "parentNode ]",
        "description": "parentNode when specified this refers to the parent node of the new XML_ELEMENT node. This node is appended to the list of child nodes. When omitted, the new XML_ELEMENT node is not added to any parent node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the new XML_ELEMENT node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "create a new node": {
    "name": "Create a new Node",
    "type": "function",
    "syntax": "function long xmlNewNode (string name [, long type] [, long parentNode])",
    "description": "Create a new XML node.",
    "arguments": [
      {
        "type": "string",
        "name": "name",
        "description": "name contains the name of this node (in case type is XML_ELEMENT or XML_DTD) or the data for this node (in case type is XML_DATA or XML_PI)."
      },
      {
        "type": "[long",
        "name": "type ]",
        "description": "type must be one of: XML_ELEMENT, XML_DTD, XML_DATA or XML_PI. The default value is XML_ELEMENT."
      },
      {
        "type": "[long",
        "name": "parentNode ]",
        "description": "parentNode when specified this refers to the parent node. The new node is appended to the list of child nodes. When omitted, the new node is not added to any parent node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the new node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "delete attribute": {
    "name": "Delete attribute",
    "type": "function",
    "syntax": "function long xmlDeleteAttribute (long node, string attribute)",
    "description": "Delete an attribute of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the attribute is deleted."
      },
      {
        "type": "string",
        "name": "attribute",
        "description": "attribute is the name of the attribute to be deleted."
      }
    ],
    "returnValue": "<>0 Success; Value of parameter node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "delete nodes": {
    "name": "Delete Nodes",
    "type": "function",
    "syntax": "function long xmlDelete (long fromNode [, long toNode])",
    "description": "Delete a tree or a list of trees. When this tree is a sub-tree of a larger tree, it is unlinked from this larger tree.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "0 Success. <0 When an error occurred.",
    "category": "functions_xml"
  },
  "de-serialize xml object": {
    "name": "De-serialize XML Object",
    "type": "function",
    "syntax": "function long xmlRead (long fp, ref string error [, long whitespacehandling])",
    "description": "De-serialize an XML object by parsing an XML document and creating an in-memory object tree.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp must be a file pointer opened for read obtained from a call to seq.open(), pipe.open(), ims.openfba() or ims.openvba()."
      },
      {
        "type": "ref string",
        "name": "error",
        "description": "error contains a description of the error in case a parsing error occurs. This is an English text, which can be used for logging purposes. Maximum length of this error string is 512 characters."
      }
    ],
    "returnValue": "<>0 Success; A reference to the first in-memory node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "de-serialize xml object from string": {
    "name": "De-serialize XML Object from String",
    "type": "function",
    "syntax": "function long xmlReadFromString (string xmlString, ref string error [, long whitespacehandling])",
    "description": "De-serialize an XML object by parsing an XML document and creating an in-memory object tree.",
    "arguments": [
      {
        "type": "string",
        "name": "xmlString",
        "description": "xmlString must be a string buffer which contains an XML document."
      },
      {
        "type": "ref string",
        "name": "error",
        "description": "error contains a description of the error in case a parsing error occurs. This is an English text, which can be used for logging purposes. Maximum length of this error string is 512 characters."
      }
    ],
    "returnValue": "<>0 Success; A reference to the first in-memory node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "doctype element in relation to xml": {
    "name": "Doctype element in relation to XML",
    "type": "function",
    "syntax": "function Doctype element in relation to XML()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "duplicate and add nodes": {
    "name": "Duplicate and Add Nodes",
    "type": "function",
    "syntax": "function long xmlDuplicateAndAdd (long destinationNode, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees and add this list to an existing list after the node referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate and append nodes": {
    "name": "Duplicate and Append Nodes",
    "type": "function",
    "syntax": "function long xmlDuplicateAndAppend (long destinationNode, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees and append this list to the end of the list referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate and append nodes to children": {
    "name": "Duplicate and Append Nodes to Children",
    "type": "function",
    "syntax": "function long xmlDuplicateAndAppendToChilds (long parentNode, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees and append this list as the last child of the node referred to by parentNode .",
    "arguments": [
      {
        "type": "long",
        "name": "parentNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate and insert nodes": {
    "name": "Duplicate and Insert Nodes",
    "type": "function",
    "syntax": "function long xmlDuplicateAndInsert (long destinationNode, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees and insert this list in an existing list before the node referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate and insert nodes in children": {
    "name": "Duplicate and Insert Nodes in Children",
    "type": "function",
    "syntax": "function long xmlDuplicateAndInsertInChilds (long parentNode, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees and insert this list as the first child of the node referred to by parentNode .",
    "arguments": [
      {
        "type": "long",
        "name": "parentNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate nodes": {
    "name": "Duplicate Nodes",
    "type": "function",
    "syntax": "function long xmlDuplicate (long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "example xml generation": {
    "name": "Example XML generation",
    "type": "function",
    "syntax": "function Example XML generation()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "example xml parsing": {
    "name": "Example XML parsing",
    "type": "function",
    "syntax": "function Example XML parsing()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "find first node": {
    "name": "Find first Node",
    "type": "function",
    "syntax": "function long xmlFindFirst (string tagName, long fromNode [, long toNode])",
    "description": "Search in a tree or a list of trees and return the first XML_ELEMENT or XML_DTD, which name is equal to the string tagName .",
    "arguments": [
      {
        "type": "string",
        "name": "tagName",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first matching Node. 0 Error or no match found.",
    "category": "functions_xml"
  },
  "find first node using a match pattern": {
    "name": "Find first Node using a Match Pattern",
    "type": "function",
    "syntax": "function long xmlFindFirstMatch (string pattern, long fromNode [, long toNode])",
    "description": "Search in a tree or a list of trees and return the first XML_ELEMENT or XML_DTD, which matches with the string pattern. The string pattern contains a search path relative to the starting node. The starting node is the list of nodes indicated by fromNode to toNode .",
    "arguments": [
      {
        "type": "string",
        "name": "pattern",
        "description": "The parameter pattern is a string which should conform to the following syntax: Pattern ::= Part [ '.' Part ]* Part ::= DepthSearch | BreadthSearch | ParentSearch | Tag | RightSibling | LeftSibling | FirstChild | LastChild | Parent DepthSearch ::= '?' Tag BreadthSearch ::= '-' Tag ParentSearch ::= '^' Tag Tag ::= '<' [Name] [Attribute]* '>' Name ::= Element name, see for a definition: [XMLSTD]. Attribute ::= attname'='attvalue | attname | attname'=' | '='attvalue RightSibling ::= \"right\" LeftSibling ::= \"left\" FirstChild ::= \"fChild\" LastChild ::= \"lChild\" Parent ::= \"parent\" Attribute values should be surrounded by double quotes. When the text inside a tag starts with a stand alone identifier (not followed by an equals sign '='), then, according to the above syntax, it is ambiguous whether it is an element name or an attribute name. In fact, it is interpreted as an element name. When an attribute name is meant, it should in this case be followed by an equals sign '='. This is not necessary for further attributes. For an example see Example XML parsing . See also XML object API ."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": ""
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": ""
      }
    ],
    "returnValue": "<>0 Success; The new tree containing references to the found nodes. In case no match is found the tree consists of a single node. 0 Error.",
    "category": "functions_xml"
  },
  "find nodes": {
    "name": "Find Nodes",
    "type": "function",
    "syntax": "function long xmlFindNodes (long node, string criteria, long maxFound [, ref long numFound])",
    "description": "Search in a tree starting at node and create a new tree containing references to all occurrences of XML_ELEMENT or XML_DTD nodes, which name matches with the string criteria . Searching stops when maxFound number of Nodes is found. When maxFound has value 0, searching stops when the complete tree has been traversed. The tree is traversed in the order as shown in Figure 2 - Depth first Tree traversal order .",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "The tree starting at node that will be searched."
      },
      {
        "type": "string",
        "name": "criteria",
        "description": "The string that must match the nodes in the specified tree."
      },
      {
        "type": "long",
        "name": "maxFound",
        "description": "The maximum number of occurrences to be included in the resulting tree. If this value is 0, all occurrences are included."
      },
      {
        "type": "[ref long",
        "name": "numFound ]",
        "description": "The number of occurrences that has been found."
      }
    ],
    "returnValue": "The return value refers to a new tree, which contains the NodeId's of the nodes which match the name criteria . This new tree corresponds to an XML document as shown below: <Enumeration TYPE=\"InMemory XmlNodes\"> <e0>id0</e0> <e1>id1</e1> ... <en>idn</en> </Enumeration> In this example idn is the decimal string representation of a nodeId of a node, which matches criteria . Like any other tree of Nodes, the returned tree must be freed from memory by using xmlDelete(). <>0 Success; The new tree containing references to the found nodes. In case no match is found the tree consists of a single node. 0 Error.",
    "category": "functions_xml"
  },
  "find nodes using a match pattern": {
    "name": "Find Nodes using a Match Pattern",
    "type": "function",
    "syntax": "function long xmlFindMatch (string pattern, long fromNode [, long toNode])",
    "description": "Search in a tree or a list of trees and create a new tree containing references to all occurrences of XML_ELEMENT or XML_DTD nodes, which match with the pattern . The pattern contains a search path relative to the starting node. The starting node is the list of nodes indicated by fromNode to toNode .",
    "arguments": [
      {
        "type": "string",
        "name": "pattern",
        "description": "See Find first Node using a Match Pattern"
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "The return value refers to a new tree, which contains the NodeId's of the nodes which match the pattern . This new tree corresponds to an XML document as shown below: <Enumeration TYPE=\"InMemory XmlNodes\"> <e0>id0</e0> <e1>id1</e1> ... <en>idn</en> </Enumeration> In this example idn is the decimal string representation of a nodeId of a node, which matches the pattern . Like any other tree of Nodes, the returned tree must be freed from memory by using xmlDelete(). <>0 Success; The new tree containing references to the found nodes. In case no match is found the tree consists of a single node. 0 Error.",
    "category": "functions_xml"
  },
  "find set of sibling nodes": {
    "name": "Find set of Sibling Nodes",
    "type": "function",
    "syntax": "function long xmlFindSetOfSiblingNodes (long node, string criteria, long maxFound [, ref long numFound])",
    "description": "Traverse the tree starting at node and return all occurrences of XML_ELEMENT or XML_DTD nodes which name matches with the string criteria . Searching will stop when maxFound number of Nodes have been found. When maxFound has value 0, searching will stop when the complete tree has been traversed. The tree is traversed in the breadth first order as shown in the Figure 3 - Breadth first Tree traversal order .",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "string",
        "name": "criteria",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "long",
        "name": "maxFound",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[ref long",
        "name": "numFound ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "The return value refers to a new tree, which contains the NodeId's of the nodes which match the name criteria . This new tree corresponds to an XML document as shown below: <Enumeration TYPE=\"Enumeration\" > <e0> <Enumeration TYPE=\"InMemory XmlNodeId\"> <e0>id0</e0> <e1>id1</e1> ... <en>idn</en> </Enumeration> </e0> <e1> <Enumeration TYPE=\"InMemory XmlNodeId\"> <e0>id0</e0> <e1>id1</e1> ... <em>idm</em> </Enumeration> </e1> ... <ek> ... </ek> </Enumeration> In this example idn is the decimal string representation of a nodeId of a node, which matches criteria . All matching nodes found on the same level (sibling nodes) will be grouped together in one <Enumeration TYPE=\"InMemory XmlNodeId\"> element. Like any other tree of Nodes, the returned tree must be freed from memory by using xmlDelete(). <>0 Success; The new tree containing references to the found nodes. In case no match is found the tree consists of a single node. 0 Error.",
    "category": "functions_xml"
  },
  "get attribute length": {
    "name": "Get attribute length",
    "type": "function",
    "syntax": "function long xmlGetAttributeLength (long node, string attributeName)",
    "description": "Get the length of an attribute.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the length of an attribute is obtained."
      },
      {
        "type": "string",
        "name": "attributeName",
        "description": "attributeName is the name of the attribute."
      }
    ],
    "returnValue": ">=0 Success; Length of the attribute. -1 Error, or the indicated attribute does not exist.",
    "category": "functions_xml"
  },
  "get attribute name": {
    "name": "Get attribute name",
    "type": "function",
    "syntax": "function string xmlAttributeName$ (long node, long attributeNr [, string default.value])",
    "description": "Get an attribute name of an XML_ELEMENT or XML_DTD node by specifying its position.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the attribute name is obtained."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr is the 1 based index in the list of attributes for this node."
      },
      {
        "type": "[string",
        "name": "default.value ]",
        "description": "default.value is the value that will be returned by xmlAttributeName$ or will be stored in basedString when the node or the attributeNr is invalid. When default.value is not specified, an empty string is used."
      }
    ],
    "returnValue": "A temporary multibyte string with the name of the specified attribute.",
    "category": "functions_xml"
  },
  "get attribute name length": {
    "name": "Get attribute name length",
    "type": "function",
    "syntax": "function long xmlGetAttributeNameLength (long node, int attributeNr)",
    "description": "Get the length of an attribute name.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the length of an attribute name is obtained."
      },
      {
        "type": "int",
        "name": "attributeNr",
        "description": "attributeNr is the 1 based index in the list of attributes for this node."
      }
    ],
    "returnValue": ">=0 Success; Length of the attribute name -1 Error, or the indicated attribute does not exist.",
    "category": "functions_xml"
  },
  "get attribute value": {
    "name": "Get attribute value",
    "type": "function",
    "syntax": "function string xmlAttribute$ (long node, string attributeName [, ref string default.value])",
    "description": "Get an attribute of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the attribute is obtained."
      },
      {
        "type": "string",
        "name": "attributeName",
        "description": "attributeName is the name of the attribute."
      },
      {
        "type": "[ref string",
        "name": "default.value ]",
        "description": "default.value is the value that will be returned by xmlAttribute$ when the node is invalid or does not have an attribute with the specified name. When default.value is not specified, an empty string is used."
      }
    ],
    "returnValue": "A temporary multibyte string with the value of the specified attribute.",
    "category": "functions_xml"
  },
  "get first child of a node": {
    "name": "Get first child of a Node",
    "type": "function",
    "syntax": "function long xmlGetFirstChild (long node)",
    "description": "Get the first (most left) child node of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the first child is obtained."
      }
    ],
    "returnValue": "<>0 Success; Reference to the found child node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "get data length of all elements": {
    "name": "Get data length of all Elements",
    "type": "function",
    "syntax": "function long xmlGetDataElementLength (long node, string name)",
    "description": "Get the data length of a node. For each child XML_ELEMENT node that has a name equal to name , the length of the data contained in XML_DATA child nodes is counted.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the parent node for which all matching XML_ELEMENT child nodes are searched."
      },
      {
        "type": "string",
        "name": "name",
        "description": "name contains the name of the XML_ELEMENT node to be found."
      }
    ],
    "returnValue": ">=0 Success; Length of the concatenated data for all found nodes. -1 Error, the specified node is incorrect.",
    "category": "functions_xml"
  },
  "get data length of a node": {
    "name": "Get data length of a Node",
    "type": "function",
    "syntax": "function long xmlGetDataLength (long node)",
    "description": "Get the data length of a node. When node is of type XML_DATA or XML_PI, only the length of the data from this node is obtained. When node is of type XML_ELEMENT or XML_DTD, the length of the data from all child XML_DATA and XML_PI nodes is counted.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the data length is obtained."
      }
    ],
    "returnValue": ">=0 Success; Length of the data in the node . -1 Error, the specified node is incorrect.",
    "category": "functions_xml"
  },
  "get data of all elements": {
    "name": "Get data of all Elements",
    "type": "function",
    "syntax": "function string xmlDataElement$ (long node, string name [, string default.value])",
    "description": "For each child XML_ELEMENT node that has a name equal to name , get the data contained in XML_DATA child nodes. The data from all matching nodes is concatenated.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the parent node for which all matching XML_ELEMENT child nodes are searched."
      },
      {
        "type": "string",
        "name": "name",
        "description": "name contains the name of the XML_ELEMENT node to be found."
      },
      {
        "type": "[string",
        "name": "default.value ]",
        "description": "default.value is the value that will be returned by xmlDataElement$ or will be stored in basedString when the node is invalid. When default.value is not specified, an empty string is used."
      }
    ],
    "returnValue": "A temporary multibyte string with the concatenated data for all found nodes.",
    "category": "functions_xml"
  },
  "get data of a node": {
    "name": "Get data of a Node",
    "type": "function",
    "syntax": "function string xmlData$ (long node [, ref string default.value])",
    "description": "Get the data of a node. When node is of type XML_DATA or XML_PI, only the data from this node is obtained. When node is of type XML_ELEMENT or XML_DTD, the data from all child XML_DATA and XML_PI nodes is concatenated.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the data is obtained."
      },
      {
        "type": "[ref string",
        "name": "default.value ]",
        "description": "default.value is the value that will be returned by xmlData$ or will be stored in basedString when the node is invalid. When default.value is not specified, an empty string is used."
      }
    ],
    "returnValue": "A temporary multibyte string with the data of the specified node.",
    "category": "functions_xml"
  },
  "get last child of a node": {
    "name": "Get last child of a Node",
    "type": "function",
    "syntax": "function long xmlGetLastChild (long node)",
    "description": "Get the last (most right) child node of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the last child is obtained."
      }
    ],
    "returnValue": "<>0 Success; Reference to the found child node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "get name length of a node": {
    "name": "Get name length of a node",
    "type": "function",
    "syntax": "function long xmlGetNameLength (long node)",
    "description": "Get the length of a node name.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the length of its name is obtained."
      }
    ],
    "returnValue": ">=0 Success; Length of the node name -1 Error.",
    "category": "functions_xml"
  },
  "get name of a node": {
    "name": "Get name of a Node",
    "type": "function",
    "syntax": "function string xmlName$ (long node [, string default.value])",
    "description": "Get the name of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the name is obtained."
      },
      {
        "type": "[string",
        "name": "default.value ]",
        "description": "default.value is the value that will be returned by xmlName$ or will be stored in basedString when the node is invalid. When default.value is not specified, an empty string is used."
      }
    ],
    "returnValue": "A temporary multibyte string with the name of the specified node.",
    "category": "functions_xml"
  },
  "get node type": {
    "name": "Get Node type",
    "type": "function",
    "syntax": "function long xmlGetType (long node)",
    "description": "Get the type of a node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the type is obtained."
      }
    ],
    "returnValue": "Success; Node type being one of XML_ELEMENT, XML_DTD, XML_DATA or XML_PI. -1 Error.",
    "category": "functions_xml"
  },
  "get number of attributes": {
    "name": "Get number of attributes",
    "type": "function",
    "syntax": "function long xmlGetNumAttributes (long node)",
    "description": "Get the number of attributes of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the number of attributes is returned."
      }
    ],
    "returnValue": "<>0 Success; Number of attributes for this node . 0 Error or no attributes are present for this node.",
    "category": "functions_xml"
  },
  "get number of child nodes": {
    "name": "Get number of child Nodes",
    "type": "function",
    "syntax": "function long xmlGetNumChilds (long node)",
    "description": "Get the number of child nodes of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the number of child nodes is obtained."
      }
    ],
    "returnValue": "<>0 Success; The number of child nodes. 0 Error or no child nodes present.",
    "category": "functions_xml"
  },
  "get number of left sibling nodes": {
    "name": "Get number of left sibling Nodes",
    "type": "function",
    "syntax": "function long xmlGetNumLeftSiblings (long node)",
    "description": "Get the number of left sibling nodes.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the number of left siblings is returned."
      }
    ],
    "returnValue": "<>0 Success; Number of left sibling nodes found. 0 When an error occurred or when node does not have any left siblings.",
    "category": "functions_xml"
  },
  "get number of right sibling nodes": {
    "name": "Get number of right sibling Nodes",
    "type": "function",
    "syntax": "function long xmlGetNumRightSiblings (long node)",
    "description": "Get the number of right sibling nodes.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the number of right siblings is returned."
      }
    ],
    "returnValue": "<>0 Success; Number of right sibling nodes found. 0 When an error occurred or when node does not have any right siblings.",
    "category": "functions_xml"
  },
  "get number of sibling nodes": {
    "name": "Get number of sibling Nodes",
    "type": "function",
    "syntax": "function long xmlGetNumSiblings (long node)",
    "description": "Get the total number of sibling nodes.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the number of siblings is returned."
      }
    ],
    "returnValue": "<>0 Success; Number of sibling nodes found. 0 When an error occurred or when node does not have any of the requested siblings.",
    "category": "functions_xml"
  },
  "get parent of a node": {
    "name": "Get parent of a Node",
    "type": "function",
    "syntax": "function long xmlGetParent (long node)",
    "description": "Get the parent of a node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the parent is obtained."
      }
    ],
    "returnValue": "<>0 Success; Reference to the parent node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "get right sibling of a node": {
    "name": "Get right sibling of a Node",
    "type": "function",
    "syntax": "function long xmlGetRightSibling (long node)",
    "description": "Get the right sibling node of a node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the right sibling node is obtained."
      }
    ],
    "returnValue": "<>0 Success; Reference to the found sibling node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "get length of a serialized xml object": {
    "name": "Get length of a serialized XML Object",
    "type": "function",
    "syntax": "function long xmlGetStringLength (long fromNode [, long toNode])",
    "description": "Get the length of the serialized form of an XML Object.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Length of the generated XML document. < 0 Error. Some specific values: -1 Incorrect argument. FromNode or toNode is not a valid xml node. -3 A TSS conversion error occured. -4 An invalid character was encountered. See Verify the used characters .",
    "category": "functions_xml"
  },
  "get length of a formatted serialized xml object": {
    "name": "Get length of a formatted serialized XML Object",
    "type": "function",
    "syntax": "function long xmlGetPrettyStringLength (long fromNode [, long toNode])",
    "description": "Get the length of the serialized form of an XML Object. The additional new-lines and tabs for human-readable formatting are taken into account.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Length of the generated XML document. < 0 Error. Some specific values: -1 Incorrect argument. FromNode or toNode is not a valid xml node. -3 A TSS conversion error occured. -4 An invalid character was encountered. See Verify the used characters .",
    "category": "functions_xml"
  },
  "get left sibling of a node": {
    "name": "Get left sibling of a Node",
    "type": "function",
    "syntax": "function long xmlGetLeftSibling (long node)",
    "description": "Get the left sibling node of a node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the sibling node is obtained."
      }
    ],
    "returnValue": "<>0 Success; Reference to the found sibling node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xml object glossary": {
    "name": "XML object glossary",
    "type": "function",
    "syntax": "function XML object glossary()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "check a long is a valid xml node": {
    "name": "Check a long is a valid XML node",
    "type": "function",
    "syntax": "function boolean xmlIsNode (long node)",
    "description": "Check whether the value supplied is a valid XML node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node to be checked whether it is (still) a valid XML node."
      }
    ],
    "returnValue": "true node is a valid XML node false node is not a valid XML node",
    "category": "functions_xml"
  },
  "xml object overview": {
    "name": "XML object overview",
    "type": "function",
    "syntax": "function XML object overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "xml object overview (namespace support)": {
    "name": "XML object overview (namespace support)",
    "type": "function",
    "syntax": "function XML object overview (namespace support)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "replace the invalid characters": {
    "name": "Replace the invalid characters",
    "type": "function",
    "syntax": "function long xmlReplaceInvalidCharacters (ref string inputstring, string replacementCharacter(1))",
    "description": "This function replaces any character that is invalid in an XML document by the specified replacement character. The replacement character must be a single-byte ASCII character in the range from #20 (ASCII space) to #7e (ASCII tilde).",
    "arguments": [
      {
        "type": "ref string",
        "name": "inputstring",
        "description": "inputstring is converted from TSS to UTF-8, and in the resulting string all invalid characters are replaced with the replacement character. The resulting string is converted back to TSS, and returned in the inputstring argument."
      },
      {
        "type": "string",
        "name": "replacementCharacter(1)",
        "description": "The replacement character to be used to replace the invalid characters in inputstring ."
      }
    ],
    "returnValue": ">=0 Success; The number of invalid characters that was replaced. -1 Error; conversion of inputstring from TSS to UTF-8 failed. -2 Error; An invalid replacement character is specified.",
    "category": "functions_xml"
  },
  "rewrite data element": {
    "name": "Rewrite Data Element",
    "type": "function",
    "syntax": "function long xmlRewriteDataElement (long node, string name, string data)",
    "description": "Find first child XML_ELEMENT node that has a name equal to name. If a matching node is found and this node does not have any child node, a new XML_DATA node with value data is added as a child node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the parent node for which a matching XML_ELEMENT child node is searched."
      },
      {
        "type": "string",
        "name": "name",
        "description": "name contains the name of the XML_ELEMENT node to be found."
      },
      {
        "type": "string",
        "name": "data",
        "description": "data contains the data for the new XML_DATA node."
      }
    ],
    "returnValue": "<>0 Success; Value of parameter node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "serialize xml object (xmlwrite)": {
    "name": "Serialize XML Object (xmlWrite)",
    "type": "function",
    "syntax": "function long xmlWrite (long fp, long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an open stream. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp must be a file pointer opened for write obtained from a call to seq.open(), pipe.open(), ims.openfba() or ims.openvba()."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Number of bytes written to output when successful < 0 Error. As many bytes as possible are written to fp . The place where the output of bytes stops, corresponds to the place in the XML tree where the first serialization error occurred. Some specific values: -1 Incorrect argument. For example, file pointer fp is closed, or fromNode or toNode is not a valid xml node. -3 Cannot write to fp (e.g. it is open for reading instead of writing), or a TSS conversion error occured. If TSS conversion of a certain text element (e.g. an attribute name or value) fails, then the output of bytes stops before that text element. -4 An invalid character was encountered. The output of bytes stops just before that character. See the xmlContainsValidCharactersOnly() function. -5 Invalid use of namespaces. Using the xmlNewNodeNs() and xmlSetAttributeNs() functions it is possible to create an XML node that uses two namespaces with the same prefix but different URIs. Serialization of such an XML node fails.",
    "category": "functions_xml"
  },
  "serialize xml object to string buffer": {
    "name": "Serialize XML Object to String Buffer",
    "type": "function",
    "syntax": "function long xmlAllocString (ref string basedString(), long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string buffer. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString()",
        "description": "basedString is a based string buffer which will implicitly be allocated to the correct size (see alloc.mem() ) and will be filled with the generated XML document."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "0 Success. Even if the serialization fails, this value is returned. In that case basedString will be an empty string. 1 Error: the supplied basedString argument is not based string.",
    "category": "functions_xml"
  },
  "serialize xml object to formatted string buffer": {
    "name": "Serialize XML Object to Formatted String Buffer",
    "type": "function",
    "syntax": "function long xmlAllocPrettyString (ref string basedString(), long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string buffer. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString()",
        "description": "basedString is a based string buffer which will implicitly be allocated to the correct size (see alloc.mem() ) and will be filled with the generated XML document."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "0 Success. Even if the serialization fails, this value is returned. In that case basedString will be an empty string. 1 Error: the supplied basedString argument is not based string.",
    "category": "functions_xml"
  },
  "serialize xml object formatted": {
    "name": "Serialize XML Object Formatted",
    "type": "function",
    "syntax": "function long xmlWritePretty (long fp, long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an open stream. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp must be a file pointer opened for write obtained from a call to seq.open(), pipe.open(), ims.openfba() or ims.openvba()."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Number of bytes written to output when successful < 0 Error. As many bytes as possible are written to fp . The place where the output of bytes stops, corresponds to the place in the XML tree where the first serialization error occurred. Some specific values: -1 Incorrect argument. For example, file pointer fp is closed, or fromNode or toNode is not a valid xml node. -3 Cannot write to fp (e.g. it is open for reading instead of writing), or a TSS conversion error occured. If TSS conversion of a certain text element (e.g. an attribute name or value) fails, then the output of bytes stops before that text element. -4 An invalid character was encountered. The output of bytes stops just before that character. See the xmlContainsValidCharactersOnly() function.",
    "category": "functions_xml"
  },
  "serialize xml object to returned string": {
    "name": "Serialize XML Object to Returned String",
    "type": "function",
    "syntax": "function string xmlString$ (long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "A temporary string with the generated XML document. If there is not enough temporary memory available for the result, or if the serialization fails, then an empty string is returned.",
    "category": "functions_xml"
  },
  "serialize xml object to returned formatted string": {
    "name": "Serialize XML Object to Returned Formatted String",
    "type": "function",
    "syntax": "function string xmlPrettyString$ (long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "A temporary string with the generated XML document. If there is not enough temporary memory available for the result, or if the serialization fails, then an empty string is returned.",
    "category": "functions_xml"
  },
  "serialize xml object to string": {
    "name": "Serialize XML Object to String",
    "type": "function",
    "syntax": "function long xmlWriteToString (ref string buffer, long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "buffer must be a reference to a string buffer which contains the generated XML document on return of the function. The function xmlGetStringLength() may be used to determine the required size of the buffer."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Number of bytes written to output when successful < 0 Error. As many bytes as possible are written to the buffer . If the cause of the error is not that the buffer is too small, then the exact place where the output of bytes stops, corresponds to the place in the XML tree where the first serialization error occurred. Some specific values: -1 Incorrect argument. For example, fromNode or toNode is not a valid xml node. -3 The buffer is too small, or a TSS conversion error occured. If TSS conversion of a certain text element (e.g. an attribute name or value) fails, then the output of bytes stops before that text element. -4 An invalid character was encountered. The output of bytes stops just before that character. See the xmlContainsValidCharactersOnly() function.",
    "category": "functions_xml"
  },
  "serialize xml object to formatted string": {
    "name": "Serialize XML Object to Formatted String",
    "type": "function",
    "syntax": "function long xmlWritePrettyToString (ref string buffer, long fromNode [, long toNode])",
    "description": "Serialize an XML object to XML and write resulting XML document to an in-memory string. Any string information in the XML document is converted to UTF-8 format.",
    "arguments": [
      {
        "type": "ref string",
        "name": "buffer",
        "description": "buffer must be a reference to a string buffer which contains the generated XML document on return of the function. The function xmlGetPrettyStringLength() may be used to determine the required size of the buffer."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": ">= 0 Success; Number of bytes written to output when successful < 0 Error. As many bytes as possible are written to the buffer . If the cause of the error is not that the buffer is too small, then the exact place where the output of bytes stops, corresponds to the place in the XML tree where the first serialization error occurred. Some specific values: -1 Incorrect argument. For example, fromNode or toNode is not a valid xml node. -3 The buffer is too small, or a TSS conversion error occured. If TSS conversion of a certain text element (e.g. an attribute name or value) fails, then the output of bytes stops before that text element. -4 An invalid character was encountered. The output of bytes stops just before that character. See the xmlContainsValidCharactersOnly() function.",
    "category": "functions_xml"
  },
  "set attribute": {
    "name": "Set attribute",
    "type": "function",
    "syntax": "function long xmlSetAttribute (long node, string attributeName, void data)",
    "description": "Set an attribute of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the attribute is set."
      },
      {
        "type": "string",
        "name": "attributeName",
        "description": "attributeName is the name of the attribute. When this attribute does already exist for this node, it gets a new value, else a new attribute is added to this node. This guarantees that attribute names are always unique for a given node."
      },
      {
        "type": "void",
        "name": "data",
        "description": "data contains the new attribute value."
      }
    ],
    "returnValue": "<>0 Success; Value of parameter node when successful 0 Error.",
    "category": "functions_xml"
  },
  "set data of a node": {
    "name": "Set data of a Node",
    "type": "function",
    "syntax": "function long xmlSetData (long node, string data)",
    "description": "Set the data of an XML_DATA or XML_PI node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the data is set."
      },
      {
        "type": "string",
        "name": "data",
        "description": "data contains the new data value."
      }
    ],
    "returnValue": "<>0 Success; Value of parameter node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "set name of a node": {
    "name": "Set name of a Node",
    "type": "function",
    "syntax": "function long xmlSetName (long node, string name)",
    "description": "Set the name of an XML_ELEMENT or XML_DTD node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is the node for which the name is set."
      },
      {
        "type": "string",
        "name": "name",
        "description": "name contains the new name."
      }
    ],
    "returnValue": "<>0 Success; Value of parameter node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xml object synopsis": {
    "name": "XML object synopsis",
    "type": "function",
    "syntax": "function XML object synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "xml object synopsis (namespace support)": {
    "name": "XML object synopsis (namespace support)",
    "type": "function",
    "syntax": "function XML object synopsis (namespace support)()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "functions_xml"
  },
  "unlink and add nodes": {
    "name": "Unlink and Add Nodes",
    "type": "function",
    "syntax": "function long xmlAdd (long destinationNode [, long fromNode], long toNode)",
    "description": "Unlink a tree or a list of trees and add this list to a new list after the node referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "[long",
        "name": "fromNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "long",
        "name": "toNode",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been moved. . 0 Error.",
    "category": "functions_xml"
  },
  "unlink and append nodes": {
    "name": "Unlink and Append Nodes",
    "type": "function",
    "syntax": "function long xmlAppend (long destinationNode, long fromNode [, long toNode])",
    "description": "Unlink a tree or a list of trees and append this list to the end of the list referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been moved.. 0 Error.",
    "category": "functions_xml"
  },
  "unlink and append nodes to children": {
    "name": "Unlink and Append Nodes to Children",
    "type": "function",
    "syntax": "function long xmlAppendToChilds (long parentNode, long fromNode [, long toNode])",
    "description": "Unlink a tree or a list of trees and append this list as the last child of the node referred to by parentNode .",
    "arguments": [
      {
        "type": "long",
        "name": "parentNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been moved. . 0 Error.",
    "category": "functions_xml"
  },
  "unlink and insert nodes": {
    "name": "Unlink and Insert Nodes",
    "type": "function",
    "syntax": "function long xmlInsert (long destinationNode, long fromNode [, long toNode])",
    "description": "Unlink a tree or a list of trees and insert this list in a new list before the node referred to by destinationNode .",
    "arguments": [
      {
        "type": "long",
        "name": "destinationNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees which has been moved. 0 Error.",
    "category": "functions_xml"
  },
  "unlink and insert nodes in children": {
    "name": "Unlink and Insert Nodes in Children",
    "type": "function",
    "syntax": "function long xmlInsertInChilds (long parentNode, long fromNode [, long toNode])",
    "description": "Unlink a tree or a list of trees and insert this list as the first child of the node referred to by parentNode .",
    "arguments": [
      {
        "type": "long",
        "name": "parentNode",
        "description": ""
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been moved. 0 Error.",
    "category": "functions_xml"
  },
  "unlink nodes": {
    "name": "Unlink Nodes",
    "type": "function",
    "syntax": "function long xmlUnlink (long fromNode [, long toNode])",
    "description": "Unlink a tree or a list of trees.",
    "arguments": [
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been unlinked. 0 Error.",
    "category": "functions_xml"
  },
  "xmlallocattributens": {
    "name": "xmlAllocAttributeNs",
    "type": "function",
    "syntax": "function long xmlAllocAttributeNs (ref string basedString, long node, void namespaceOrURI, const string attributeName [, const string default.value])",
    "description": "Get the value of an attribute of the specified node. If an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI exists, then its value is returned. The function fails if the node is invalid or the namespaceOrURI is invalid.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the value. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "attributeName",
        "description": "attributeName is the local name of the attribute of the node ."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the value if the node is valid, and the node has an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI . It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocattributeprefix": {
    "name": "xmlAllocAttributePrefix",
    "type": "function",
    "syntax": "function long xmlAllocAttributePrefix (ref string basedString, long node, long attributeNr [, const string default.value])",
    "description": "Get the prefix of an attribute of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the prefix. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the prefix if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocattributequalifiedname": {
    "name": "xmlAllocAttributeQualifiedName",
    "type": "function",
    "syntax": "function long xmlAllocAttributeQualifiedName (ref string basedString, long node, long attributeNr [, const string default.value])",
    "description": "Get the qualified name of an attribute of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the qualified name. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the qualified name if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocattributeuri": {
    "name": "xmlAllocAttributeURI",
    "type": "function",
    "syntax": "function long xmlAllocAttributeURI (ref string basedString, long node, long attributeNr [, const string default.value])",
    "description": "Get the URI of an attribute of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the URI. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the URI if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocdataelementns": {
    "name": "xmlAllocDataElementNs",
    "type": "function",
    "syntax": "function long xmlAllocDataElementNs (ref string basedString, long node, void namespaceOrURI, const string name [, const string default.value])",
    "description": "Get the data of all child nodes of type XML_DATA of those child nodes of type XML_ELEMENT of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . All data of the XML_DATA nodes is concatenated into a single string. If an XML_ELEMENT node has multiple XML_DATA nodes, then a single space is used as seperator.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the value. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the child node(s) of type XML_ELEMENT."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the data if the node is valid, the namespaceOrURI is valid, and there is a child XML_ELEMENT node of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI with an XML_DATA node as child. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocprefix": {
    "name": "xmlAllocPrefix",
    "type": "function",
    "syntax": "function long xmlAllocPrefix (ref string basedString, long node [, const string default.value])",
    "description": "Get the prefix of the namespace of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the prefix. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the prefix if the node is valid and is in a namespace. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocqualifiedname": {
    "name": "xmlAllocQualifiedName",
    "type": "function",
    "syntax": "function long xmlAllocQualifiedName (ref string basedString, long node [, const string default.value])",
    "description": "Get the qualified name of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the qualified name. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the qualified name if the node is valid. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlallocuri": {
    "name": "xmlAllocURI",
    "type": "function",
    "syntax": "function long xmlAllocURI (ref string basedString, long node [, const string default.value])",
    "description": "Get the URI of the namespace of the specified node.",
    "arguments": [
      {
        "type": "ref string",
        "name": "basedString",
        "description": "basedString is the return argument to receive the URI. It must be declared based ."
      },
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "0 Success; The basedString contains the URI if the node is valid and is in a namespace. It contains the default.value , or when this is omitted, the empty string otherwise. -1 The basedString is not declared based .",
    "category": "functions_xml"
  },
  "xmlattributens$": {
    "name": "xmlAttributeNs$",
    "type": "function",
    "syntax": "function string xmlAttributeNs$ (long node, void namespaceOrURI, const string attributeName [, const string default.value])",
    "description": "Get the value of an attribute of the specified node. If an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI exists, then its value is returned. The function fails if the node is invalid or the namespaceOrURI is invalid.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "attributeName",
        "description": "attributeName is the local name of the attribute of the node ."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, and the node has an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI then a temporary string containing the value of the attribute is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlattributeprefix$": {
    "name": "xmlAttributePrefix$",
    "type": "function",
    "syntax": "function string xmlAttributePrefix$ (long node, long attributeNr [, const string default.value])",
    "description": "Get the prefix of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, the attributeNr is valid and the attribute is in a namespace, then a temporary string containing the prefix of the namespace is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlattributequalifiedname$": {
    "name": "xmlAttributeQualifiedName$",
    "type": "function",
    "syntax": "function string xmlAttributeQualifiedName$ (long node, long attributeNr [, const string default.value])",
    "description": "Get the qualified name of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, the attributeNr is valid and the attribute is in a namespace, then a temporary string containing the qualified name of the namespace is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlattributeuri$": {
    "name": "xmlAttributeURI$",
    "type": "function",
    "syntax": "function string xmlAttributeURI$ (long node, long attributeNr [, const string default.value])",
    "description": "Get the URI of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, the attributeNr is valid and the attribute is in a namespace, then a temporary string containing the URI of the namespace is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlbuildnamespacelist$": {
    "name": "xmlBuildNamespaceList$",
    "type": "function",
    "syntax": "function string xmlBuildNamespaceList$ (const string prefix, const string URI [, ... ])",
    "description": "This is a utility function that creates a string of namespace bindings, to be used for the xmlFindFirstMatchNs() and xmlFindMatchNs() functions.",
    "arguments": [
      {
        "type": "const string",
        "name": "prefix",
        "description": "prefix is the prefix of a namespace."
      },
      {
        "type": "const string",
        "name": "URI",
        "description": "URI is the URI of a namespace."
      },
      {
        "type": "[...",
        "name": "]",
        "description": "Use optional parameters to supply more pairs of prefix and URI ."
      }
    ],
    "returnValue": "non-empty string Success; A string of the form <prefix>=\"<URI>\"[,<prefix>=\"<URI>\"...]. empty string Error; One of the optional parameters is not of type string.",
    "category": "functions_xml"
  },
  "xmldataelementns$": {
    "name": "xmlDataElementNs$",
    "type": "function",
    "syntax": "function string xmlDataElementNs$ (long node, void namespaceOrURI, const string name [, const string default.value])",
    "description": "Get the data of all child nodes of type XML_DATA of those child nodes of type XML_ELEMENT of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . All data of the XML_DATA nodes is concatenated into a single string. If an XML_ELEMENT node has multiple XML_DATA nodes, then a single space is used as seperator.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the child node(s) of type XML_ELEMENT."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, the namespaceOrURI is valid, and there is a child XML_ELEMENT node of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI with an XML_DATA node as child, then a temporary string containing the data is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmldeleteattributens": {
    "name": "xmlDeleteAttributeNs",
    "type": "function",
    "syntax": "function long xmlDeleteAttributeNs (long node, void namespaceOrURI, const string name)",
    "description": "Delete an attribute with a namespace. If an attribute with the specified name and with a namespace whose URI matches the URI specified by namespaceOrURI exists, then this attribute is deleted. The function fails if the node is invalid or the namespaceOrURI is invalid.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node. If node is invalid then the function fails."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the attribute."
      }
    ],
    "returnValue": "<>0 Success; A reference to the node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "duplicate nodes to process": {
    "name": "Duplicate Nodes to Process",
    "type": "function",
    "syntax": "function long xmlDuplicateToProcess (long processId, long fromNode [, long toNode])",
    "description": "Duplicate a tree or a list of trees into another 3GL-process space.",
    "arguments": [
      {
        "type": "long",
        "name": "processId",
        "description": "processId must be a valid 3GL process identifier. This process becomes the owner of the newly created tree or list of trees."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first node in tree or list of trees, which has been created. 0 Error.",
    "category": "functions_xml"
  },
  "xmlfindfirstmatchns": {
    "name": "xmlFindFirstMatchNs",
    "type": "function",
    "syntax": "function long xmlFindFirstMatchNs (string pattern, const string namespaceList, long fromNode [, long toNode])",
    "description": "Search in a tree or a list of trees and return the first XML_ELEMENT or XML_DTD, which matches with the string pattern. The string pattern contains a search path relative to the starting node. The starting node is the list of nodes indicated by fromNode to toNode .",
    "arguments": [
      {
        "type": "string",
        "name": "pattern",
        "description": "The parameter pattern is a string which should conform to the following syntax: Pattern ::= Part [ '.' Part ]* Part ::= DepthSearch | BreadthSearch | ParentSearch | Tag | RightSibling | LeftSibling | FirstChild | LastChild | Parent DepthSearch ::= '?' Tag BreadthSearch ::= '-' Tag ParentSearch ::= '^' Tag Tag ::= '<' [Name] [Attribute]* '>' Name ::= Element name, see for a definition: [XMLSTD]. Attribute ::= attname'='attvalue | attname | attname'=' | '='attvalue RightSibling ::= \"right\" LeftSibling ::= \"left\" FirstChild ::= \"fChild\" LastChild ::= \"lChild\" Parent ::= \"parent\" Both an element name and an attribute name can be qualified . The namespaceList is then used to bind the prefix to the corresponding namespace name (URI). The URI of the element or attribute must match the specified URI in the namespaceList for a successful match. Attribute values should be surrounded by double quotes. When the text inside a tag starts with a stand alone identifier (not followed by an equals sign '='), then, according to the above syntax, it is ambiguous whether it is an element name or an attribute name. In fact, it is interpreted as an element name. When an attribute name is meant, it should in this case be followed by an equals sign '='. This is not necessary for further attributes."
      },
      {
        "type": "const string",
        "name": "namespaceList",
        "description": "namespaceList is a string containing a list of prefix-URI bindings. The string must have the form <prefix>=\"<URI>\"[,<prefix>=\"<URI>\"...], and may be empty. The function xmlBuildNamespaceList$() can be used to build this list."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "fromNode is a reference to an XML node. See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "toNode is a reference to an XML node. See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "<>0 Success; Reference to first matching Node. 0 Error or no match found.",
    "category": "functions_xml"
  },
  "xmlfindfirstns": {
    "name": "xmlFindFirstNs",
    "type": "function",
    "syntax": "function long xmlFindFirstNs (void namespaceOrURI, const string name, long fromNode [, long toNode])",
    "description": "In an XML tree, or a list of XML trees, find the first XML node of type XML_ELEMENT or XML_DTD, whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . This is a depth first search.",
    "arguments": [
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the node(s) of type XML_ELEMENT or XML_DTD."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "fromNode is a reference to an XML node. See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "toNode is a reference to an XML node. See Handling of fromNode and toNode arguments ."
      }
    ],
    "returnValue": "<>0 Success; the XML node that matches the criteria. 0 Error; either the namespaceOrURI is invalid, or the fromNode is invalid, or the toNode is invalid, or no XML node that matches the criteria could be found.",
    "category": "functions_xml"
  },
  "xmlfindmatchns": {
    "name": "xmlFindMatchNs",
    "type": "function",
    "syntax": "function long xmlFindMatchNs (string pattern, const string namespaceList, long fromNode [, long toNode])",
    "description": "Search in a tree or a list of trees and create a new tree containing references to all occurrences of XML_ELEMENT or XML_DTD nodes, which match with the pattern . The pattern contains a search path relative to the starting node. The starting node is the list of nodes indicated by fromNode to toNode .",
    "arguments": [
      {
        "type": "string",
        "name": "pattern",
        "description": "The parameter pattern is a string which should conform to the following syntax: Pattern ::= Part [ '.' Part ]* Part ::= DepthSearch | BreadthSearch | ParentSearch | Tag | RightSibling | LeftSibling | FirstChild | LastChild | Parent DepthSearch ::= '?' Tag BreadthSearch ::= '-' Tag ParentSearch ::= '^' Tag Tag ::= '<' [Name] [Attribute]* '>' Name ::= Element name, see for a definition: [XMLSTD]. Attribute ::= attname'='attvalue | attname | attname'=' | '='attvalue RightSibling ::= \"right\" LeftSibling ::= \"left\" FirstChild ::= \"fChild\" LastChild ::= \"lChild\" Parent ::= \"parent\" Both an element name and an attribute name can be qualified . The namespaceList is then used to bind the prefix to the corresponding namespace name (URI). The URI of the element or attribute must match the specified URI in the namespaceList for a successful match. Attribute values should be surrounded by double quotes. When the text inside a tag starts with a stand alone identifier (not followed by an equals sign '='), then, according to the above syntax, it is ambiguous whether it is an element name or an attribute name. In fact, it is interpreted as an element name. When an attribute name is meant, it should in this case be followed by an equals sign '='. This is not necessary for further attributes."
      },
      {
        "type": "const string",
        "name": "namespaceList",
        "description": "namespaceList is a string containing a list of prefix-URI bindings. The string must have the form <prefix>=\"<URI>\"[,<prefix>=\"<URI>\"...], and may be empty. The function xmlBuildNamespaceList$() can be used to build this list."
      },
      {
        "type": "long",
        "name": "fromNode",
        "description": "fromNode is a reference to an XML node. See Handling of fromNode and toNode arguments"
      },
      {
        "type": "[long",
        "name": "toNode ]",
        "description": "toNode is a reference to an XML node. See Handling of fromNode and toNode arguments"
      }
    ],
    "returnValue": "The return value refers to a new tree, which contains the NodeId's of the nodes which match the pattern . This new tree corresponds to an XML document as shown below: <Enumeration TYPE=\"InMemory XmlNodes\"> <e0>id0</e0> <e1>id1</e1> ... <en>idn</en> </Enumeration> In this example idn is the decimal string representation of a nodeId of a node, which matches the pattern . Like any other tree of Nodes, the returned tree must be freed from memory by using xmlDelete(). <>0 Success; The new tree containing references to the found nodes. In case no match is found the tree consists of a single node. 0 Error.",
    "category": "functions_xml"
  },
  "xmlfindnamespace": {
    "name": "xmlFindNamespace",
    "type": "function",
    "syntax": "function long xmlFindNamespace (long node, const string URI)",
    "description": "Find the namespace with the specified URI. This function searches the specified XML node and all parent nodes. If successful, this function returns a handle to the namespace as created by the xmlNewNamespace() function. The handle can be used in for example the xmlNewNodeNs() function.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "const string",
        "name": "URI",
        "description": "URI is the URI used to find the namespace that matches this URI."
      }
    ],
    "returnValue": "<>0 Success; A reference to the namespace when successful. 0 Error. The node may be invalid or a namespace with the specified URI could not be found.",
    "category": "functions_xml"
  },
  "xmlfindnodesns": {
    "name": "xmlFindNodesNs",
    "type": "function",
    "syntax": "function long xmlFindNodesNs (long node, void namespaceOrURI, const string name, long maxFound [, ref long numFound])",
    "description": "In an XML tree, find all XML nodes of type XML_ELEMENT or XML_DTD, whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . This is a depth first search.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the node(s) of type XML_ELEMENT or XML_DTD."
      },
      {
        "type": "long",
        "name": "maxFound",
        "description": "maxFound is the maximum number of matches to be returned. When its value is 0 then all matches will be returned."
      },
      {
        "type": "[ref long",
        "name": "numFound ]",
        "description": "numFound is a reference variable, and contains the number of matches found."
      }
    ],
    "returnValue": "The return value refers to a new tree, which contains the NodeId's of the nodes which match the pattern . This new tree corresponds to an XML document as shown below: <Enumeration TYPE=\"InMemory XmlNodes\"> <e0>id0</e0> <e1>id1</e1> ... <en>idn</en> </Enumeration> In this example idn is the decimal string representation of a nodeId of a node, which matches the pattern . Like any other tree of Nodes, the returned tree must be freed from memory by using xmlDelete(). <>0 Success; The new tree containing the references to the matching nodes. In case no match is found the tree consists of a single node. 0 Error; either the namespaceOrURI is invalid, or the node is invalid.",
    "category": "functions_xml"
  },
  "xmlfirstnamespacedecl": {
    "name": "xmlFirstNamespaceDecl",
    "type": "function",
    "syntax": "function long xmlFirstNamespaceDecl (long node)",
    "description": "Get the first namespace declaration from an XML node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is an XML node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the first namespace declaration of the node . 0 Error. The node does not carry any namespace declaration.",
    "category": "functions_xml"
  },
  "xmlgetattributelengthns": {
    "name": "xmlGetAttributeLengthNs",
    "type": "function",
    "syntax": "function long xmlGetAttributeLengthNs (long node, void namespaceOrURI, const string attributeName)",
    "description": "Get the length of the value of an attribute of the specified node. If an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI exists, then the length of its value is returned. The function fails if the node is invalid or the namespaceOrURI is invalid.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "attributeName",
        "description": "attributeName is the local name of the attribute of the node ."
      }
    ],
    "returnValue": ">=0 Success; The length of the value. -1 The node is invalid, or the node has no attribute with the specified attributeName or with a namespace whose URI does not match the URI specified by namespaceOrURI .",
    "category": "functions_xml"
  },
  "xmlgetattributens": {
    "name": "xmlGetAttributeNs",
    "type": "function",
    "syntax": "function long xmlGetAttributeNs (long node, void namespaceOrURI, const string attributeName, ref void value)",
    "description": "Get the value of an attribute of the specified node. If an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI exists, then its value is returned. The function fails if the node is invalid or the namespaceOrURI is invalid.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "attributeName",
        "description": "attributeName is the local name of the attribute of the node ."
      },
      {
        "type": "ref void",
        "name": "value",
        "description": "value is the return argument to receive the value."
      }
    ],
    "returnValue": "<>0 Success; The value of node . The value contains the value if the node is valid, and the node has an attribute with the specified attributeName and with a namespace whose URI matches the URI specified by namespaceOrURI . It contains the default.value , or when this is omitted, the empty string otherwise. 0 The node is invalid, or the node has no attribute with the specified attributeName or with a namespace whose URI does not match the URI specified by namespaceOrURI .",
    "category": "functions_xml"
  },
  "xmlgetattributeprefix": {
    "name": "xmlGetAttributePrefix",
    "type": "function",
    "syntax": "function long xmlGetAttributePrefix (long node, long attributeNr, ref string prefix)",
    "description": "Get the prefix of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "ref string",
        "name": "prefix",
        "description": "prefix is the return argument to receive the prefix."
      }
    ],
    "returnValue": "<>0 Success; The value of node . The prefix contains the prefix if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the empty string otherwise. 0 The node is invalid, the attributeNr is invalid or the namespace of the namespace is invalid or the default namespace.",
    "category": "functions_xml"
  },
  "xmlgetattributeprefixlength": {
    "name": "xmlGetAttributePrefixLength",
    "type": "function",
    "syntax": "function long xmlGetAttributePrefixLength (long node, long attributeNr)",
    "description": "Get the length of the prefix of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      }
    ],
    "returnValue": ">=0 Success; The length of the prefix. -1 The node is invalid or attributeNr is invalid or the attribute is not in a namespace.",
    "category": "functions_xml"
  },
  "xmlgetattributequalifiedname": {
    "name": "xmlGetAttributeQualifiedName",
    "type": "function",
    "syntax": "function long xmlGetAttributeQualifiedName (long node, long attributeNr, ref string name)",
    "description": "Get the qualified name of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "ref string",
        "name": "name",
        "description": "name is the return argument to receive the qualified name."
      }
    ],
    "returnValue": "<>0 Success; The value of node . The name contains the qualified name if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the empty string otherwise. 0 The node is invalid, the attributeNr is invalid or the namespace of the namespace is invalid or the default namespace.",
    "category": "functions_xml"
  },
  "xmlgetattributequalifiednamelength": {
    "name": "xmlGetAttributeQualifiedNameLength",
    "type": "function",
    "syntax": "function long xmlGetAttributeQualifiedNameLength (long node, long attributeNr)",
    "description": "Get the length of the qualified name of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      }
    ],
    "returnValue": ">=0 Success; The length of the qualified name. -1 The node is invalid or attributeNr is invalid or the attribute is not in a namespace.",
    "category": "functions_xml"
  },
  "xmlgetattributeuri": {
    "name": "xmlGetAttributeURI",
    "type": "function",
    "syntax": "function long xmlGetAttributeURI (long node, long attributeNr, ref string URI)",
    "description": "Get the URI of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      },
      {
        "type": "ref string",
        "name": "URI",
        "description": "URI is the return argument to receive the URI."
      }
    ],
    "returnValue": "<>0 Success; The value of node . The URI contains the URI if the node is valid, the attributeNr is valid and the attribute is in a namespace. It contains the empty string otherwise. 0 The node is invalid, the attributeNr is invalid or the namespace of the namespace is invalid or the default namespace.",
    "category": "functions_xml"
  },
  "xmlgetattributeurilength": {
    "name": "xmlGetAttributeURILength",
    "type": "function",
    "syntax": "function long xmlGetAttributeURILength (long node, long attributeNr)",
    "description": "Get the length of the URI of an attribute of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "long",
        "name": "attributeNr",
        "description": "attributeNr identifies the attribute of the node . The value 1 identifies the first attribute."
      }
    ],
    "returnValue": ">=0 Success; The length of the URI. -1 The node is invalid or attributeNr is invalid or the attribute is not in a namespace.",
    "category": "functions_xml"
  },
  "xmlgetdataelementlengthns": {
    "name": "xmlGetDataElementLengthNs",
    "type": "function",
    "syntax": "function long xmlGetDataElementLengthNs (long node, void namespaceOrURI, const string name)",
    "description": "Get the length of the data of all child nodes of type XML_DATA of those child nodes of type XML_ELEMENT of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . All data of the XML_DATA nodes is concatenated into a single string. If an XML_ELEMENT node has multiple XML_DATA nodes, then a single space is used as seperator.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the child node(s) of type XML_ELEMENT."
      }
    ],
    "returnValue": ">=0 Success; The length of the value. -1 The node is invalid, or the namespaceOrURI is invalid, or there is no child XML_ELEMENT node of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI with an XML_DATA node as child,",
    "category": "functions_xml"
  },
  "xmlgetdataelementns": {
    "name": "xmlGetDataElementNs",
    "type": "function",
    "syntax": "function long xmlGetDataElementNs (long node, void namespaceOrURI, const string name, ref string data)",
    "description": "Get the data of all child nodes of type XML_DATA of those child nodes of type XML_ELEMENT of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI . All data of the XML_DATA nodes is concatenated into a single string. If an XML_ELEMENT node has multiple XML_DATA nodes, then a single space is used as seperator.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the child node(s) of type XML_ELEMENT."
      },
      {
        "type": "ref string",
        "name": "data",
        "description": "data is the return argument to receive the data."
      }
    ],
    "returnValue": "<>0 Success; The value of node . The data contains the data if the node is valid, the namespaceOrURI is valid, and there is a child XML_ELEMENT node of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI with an XML_DATA node as child. It contains the empty string otherwise. 0 The node is invalid, or the namespaceOrURI is invalid, or there is no child XML_ELEMENT node of the node whose local name matches the specified name and whose URI matches the URI specified by namespaceOrURI with an XML_DATA node as child,",
    "category": "functions_xml"
  },
  "xmlgetnamespace": {
    "name": "xmlGetNamespace",
    "type": "function",
    "syntax": "function long xmlGetNamespace (long node)",
    "description": "Get the namespace of an XML node. This function returns a reference to the namespace as created by the xmlNewNamespace() function. The reference can be used in for example the xmlNewNodeNs() function.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the namespace when successful. 0 Error. The node may be invalid or it may not be in a namespace.",
    "category": "functions_xml"
  },
  "xmlgetprefix": {
    "name": "xmlGetPrefix",
    "type": "function",
    "syntax": "function long xmlGetPrefix (long node, ref string prefix)",
    "description": "Get the prefix of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "ref string",
        "name": "prefix",
        "description": "prefix is the return argument to receive the prefix."
      }
    ],
    "returnValue": "<>0 Success; The value of node . 0 The node is invalid or the namespace of the node is invalid or the default namespace.",
    "category": "functions_xml"
  },
  "xmlgetprefixlength": {
    "name": "xmlGetPrefixLength",
    "type": "function",
    "syntax": "function long xmlGetPrefixLength (long node)",
    "description": "Get the length of the prefix of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      }
    ],
    "returnValue": ">=0 Success; The length of the prefix. -1 The node is invalid or the node node is not in a namespace.",
    "category": "functions_xml"
  },
  "xmlgetqualifiedname": {
    "name": "xmlGetQualifiedName",
    "type": "function",
    "syntax": "function long xmlGetQualifiedName (long node, ref string name)",
    "description": "Get the qualified name of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "ref string",
        "name": "name",
        "description": "name is the return argument to receive the qualified name."
      }
    ],
    "returnValue": "<>0 Success; The value of node . 0 The node is invalid.",
    "category": "functions_xml"
  },
  "xmlgetqualifiednamelength": {
    "name": "xmlGetQualifiedNameLength",
    "type": "function",
    "syntax": "function long xmlGetQualifiedNameLength (long node)",
    "description": "Get the length of the qualified name of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      }
    ],
    "returnValue": ">=0 Success; The length of the qualified name. -1 The node is invalid.",
    "category": "functions_xml"
  },
  "get saml (security data) node": {
    "name": "Get SAML (security data) node",
    "type": "function",
    "syntax": "function long xmlGetSAMLnode ()",
    "description": "Get the root-node of the XML document that contains the SAML (Security Assertion Markup Language) data that has been passed by the security and authentication system. This will contain details about the user, authentication and authorisation data.",
    "arguments": [],
    "returnValue": "0 Failure. There is no SAML data avaliable. <>0 The root-node of the XML document that contains the SAML data.",
    "category": "functions_xml"
  },
  "xmlgeturi": {
    "name": "xmlGetURI",
    "type": "function",
    "syntax": "function long xmlGetURI (long node, ref string URI)",
    "description": "Get the URI of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "ref string",
        "name": "URI",
        "description": "URI is the return argument to receive the URI."
      }
    ],
    "returnValue": "<>0 Success; The value of node . 0 The node is invalid or the namespace of the node is the default namespace.",
    "category": "functions_xml"
  },
  "xmlgeturilength": {
    "name": "xmlGetURILength",
    "type": "function",
    "syntax": "function long xmlGetURILength (long node)",
    "description": "Get the length of the URI of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      }
    ],
    "returnValue": ">=0 Success; The length of the URI. -1 The node is invalid or the node node is not in a namespace.",
    "category": "functions_xml"
  },
  "xmlnamespaceprefix$": {
    "name": "xmlNamespacePrefix$",
    "type": "function",
    "syntax": "function string xmlNamespacePrefix$ (long namespace)",
    "description": "Get the prefix of the specified namespace.",
    "arguments": [
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace is a reference to an XML namespace."
      }
    ],
    "returnValue": "string Success; A temporary string containing the prefix of the namespace. \"\" The namespace is invalid or the namespace is the default namespace.",
    "category": "functions_xml"
  },
  "xmlnamespaceuri$": {
    "name": "xmlNamespaceURI$",
    "type": "function",
    "syntax": "function string xmlNamespaceURI$ (long namespace)",
    "description": "Get the URI of the specified namespace.",
    "arguments": [
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace is a reference to an XML namespace."
      }
    ],
    "returnValue": "string Success; A temporary string containing the URI of the namespace. \"\" The namespace is invalid or the namespace is an \"undeclaration\" of the default namespace.",
    "category": "functions_xml"
  },
  "xmlnewdataelementns": {
    "name": "xmlNewDataElementNs",
    "type": "function",
    "syntax": "function long xmlNewDataElementNs (long namespace, const string name, void data [, long parentNode])",
    "description": "Create a new XML node of type XML_ELEMENT with local name as specified by name and in the namespace as specified by namespace . A new XML node of type XML_DATA is created as the first child of the newly created XML_ELEMENT node, with data as specified by data . The function fails if namespace is invalid or parentNode is invalid.",
    "arguments": [
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace contains a reference to the namespace as returned by the xmlNewNamespace() or xmlGetNamespace() function. If the namespace is invalid then the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the new node of type XML_ELEMENT."
      },
      {
        "type": "void",
        "name": "data",
        "description": "data is the data of the new node of type XML_DATA."
      },
      {
        "type": "[long",
        "name": "parentNode ]",
        "description": "parentNode when specified this refers to the parent node. The new node is appended to the list of child nodes. When omitted, the new node is not added to any parent node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the newly created XML_ELEMENT node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmlnewnamespace": {
    "name": "xmlNewNamespace",
    "type": "function",
    "syntax": "function long xmlNewNamespace (long node, const string prefix, const string URI)",
    "description": "Create a new namespace with the specified prefix and URI. The specified node becomes the carrier of the namespace, but the node itself is not yet in the namespace.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "The XML node identified by node becomes the carrier of the newly created namespace. If the XML node is not of type XML_ELEMENT then the function fails."
      },
      {
        "type": "const string",
        "name": "prefix",
        "description": "prefix contains the prefix, for example \"soap\"."
      },
      {
        "type": "const string",
        "name": "URI",
        "description": "URI contains the URI, for example \"http://www.w3.org/2001/12/soap-envelope\"."
      }
    ],
    "returnValue": "<>0 Success; A reference to the new namespace when successful. This value can be used in many functions with a namespace argument, such as xmlNewNodeNs() . 0 Error.",
    "category": "functions_xml"
  },
  "xmlnewnodens": {
    "name": "xmlNewNodeNs",
    "type": "function",
    "syntax": "function long xmlNewNodeNs (long namespace, const string name [, long type] [, long parentNode])",
    "description": "Create a new XML node in the specified namespace.",
    "arguments": [
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace contains a handle to the namespace as returned by the xmlNewNamespace() or xmlGetNamespace() function. It is ignored if type does not equal XML_ELEMENT."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name contains the name of this node (in case type is XML_ELEMENT or XML_DTD) or the data for this node (in case type is XML_DATA or XML_PI)."
      },
      {
        "type": "[long",
        "name": "type ]",
        "description": "type must be one of: XML_ELEMENT, XML_DTD, XML_DATA or XML_PI. The default value is XML_ELEMENT."
      },
      {
        "type": "[long",
        "name": "parentNode ]",
        "description": "parentNode when specified this refers to the parent node. The new node is appended to the list of child nodes. When omitted, the new node is not added to any parent node."
      }
    ],
    "returnValue": "<>0 Success; A reference to the new node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmlnextnamespacedecl": {
    "name": "xmlNextNamespaceDecl",
    "type": "function",
    "syntax": "function long xmlNextNamespaceDecl (long namespace)",
    "description": "Get the next namespace declaration of an XML node.",
    "arguments": [
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace is a reference to an XML namespace."
      }
    ],
    "returnValue": "<>0 Success; A reference to the next namespace declaration of an XML node that carries the specified namespace . 0 Error. The namespace is invalid or it does not have a next namespace declaration, within the context of the same XML node.",
    "category": "functions_xml"
  },
  "xmlprefix$": {
    "name": "xmlPrefix$",
    "type": "function",
    "syntax": "function string xmlPrefix$ (long node [, const string default.value])",
    "description": "Get the prefix of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid and is in a namespace, then a temporary string containing the prefix of the namespace is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlqualifiedname$": {
    "name": "xmlQualifiedName$",
    "type": "function",
    "syntax": "function string xmlQualifiedName$ (long node [, const string default.value])",
    "description": "Get the qualified name of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid, then a temporary string containing the qualified name of the node is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "xmlreadfromstringns": {
    "name": "xmlReadFromStringNs",
    "type": "function",
    "syntax": "function long xmlReadFromStringNs (string xmlString, ref string error [, long whitespacehandling])",
    "description": "De-serialize an XML object by parsing an XML document and creating an in-memory object tree. This function supports XML namespaces, and will create namespace declarations carried by the respective XML nodes, and put XML nodes in their appropriate namespace.",
    "arguments": [
      {
        "type": "string",
        "name": "xmlString",
        "description": ""
      },
      {
        "type": "ref string",
        "name": "error",
        "description": ""
      }
    ],
    "returnValue": "<>0 Success; A reference to the first in-memory node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmlreadns": {
    "name": "xmlReadNs",
    "type": "function",
    "syntax": "function long xmlReadNs (long fp, ref string error [, long whitespacehandling])",
    "description": "De-serialize an XML object by parsing an XML document and creating an in-memory object tree. This function supports XML namespaces, and will create namespace declarations carried by the respective XML nodes, and put XML nodes in their appropriate namespace.",
    "arguments": [
      {
        "type": "long",
        "name": "fp",
        "description": "fp must be a file pointer opened for read obtained from a call to seq.open(), pipe.open(), ims.openfba() or ims.openvba()."
      },
      {
        "type": "ref string",
        "name": "error",
        "description": "error contains a description of the error in case a parsing error occurs. This is an English text, which can be used for logging purposes. Maximum length of this error string is 120 characters."
      }
    ],
    "returnValue": "<>0 Success; A reference to the first in-memory node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmlrewritedataelementns": {
    "name": "xmlRewriteDataElementNs",
    "type": "function",
    "syntax": "function long xmlRewriteDataElementNs (long node, void namespaceOrURI, const string name, void data)",
    "description": "If node has no child node of type XML_ELEMENT whose local name equals name and whose URI equals the URI specified by namespaceOrURI , then a new XML node of type XML_ELEMENT is created, with an XML node of type XML_DATA with the specified data .",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "void",
        "name": "namespaceOrURI",
        "description": "namespaceOrURI is either a reference to an XML namespace, or it is a URI. If the namespaceOrURI parameter is of type long then it is a reference to an XML namespace; if it is of type string then it is a URI; otherwise the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the child node(s) of type XML_ELEMENT."
      },
      {
        "type": "void",
        "name": "data",
        "description": "data is the new data of the node(s) of type XML_DATA."
      }
    ],
    "returnValue": "<>0 Success; The value of node . 0 Error.",
    "category": "functions_xml"
  },
  "xmlsetattributens": {
    "name": "xmlSetAttributeNs",
    "type": "function",
    "syntax": "function long xmlSetAttributeNs (long node, long namespace, const string name, void value)",
    "description": "Set the value of an attribute with a namespace. If no attribute with the specified name and with a namespace whose URI matches the URI of the specified namespace exists, then a new attribute with the specified name , namespace and value is created. If the XML node is not of type XML_ELEMENT then the function fails.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node. If node is invalid or not of type XML_ELEMENT then the function fails."
      },
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace contains a reference to the namespace as returned by the xmlNewNamespace() or xmlGetNamespace() function. If the namespace is invalid then the function fails."
      },
      {
        "type": "const string",
        "name": "name",
        "description": "name is the local name of the attribute."
      },
      {
        "type": "void",
        "name": "value",
        "description": "value is the (new) value of the attribute."
      }
    ],
    "returnValue": "<>0 Success; A reference to the node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmlsetnamespace": {
    "name": "xmlSetNamespace",
    "type": "function",
    "syntax": "function long xmlSetNamespace (long node, long namespace)",
    "description": "Set the namespace of an XML node to the specified namespace. The specified node does not become the carrier of the namespace. In other words, the node does not declare the namespace, but it is put in the namespace. If the XML node is not of type XML_ELEMENT then the function fails.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node. If node is invalid or not of type XML_ELEMENT then the function fails."
      },
      {
        "type": "long",
        "name": "namespace",
        "description": "namespace contains a reference to the namespace as returned by the xmlNewNamespace() or xmlGetNamespace() function. If the namespace is invalid then the function fails."
      }
    ],
    "returnValue": "<>0 Success; A reference to the node when successful. 0 Error.",
    "category": "functions_xml"
  },
  "xmluri$": {
    "name": "xmlURI$",
    "type": "function",
    "syntax": "function string xmlURI$ (long node [, const string default.value])",
    "description": "Get the URI of the namespace of the specified node.",
    "arguments": [
      {
        "type": "long",
        "name": "node",
        "description": "node is a reference to an XML node."
      },
      {
        "type": "[const string",
        "name": "default.value ]",
        "description": "default.value is a string that is used as return value when the function fails."
      }
    ],
    "returnValue": "string If the node is valid and is in a namespace, then a temporary string containing the URI of the namespace is returned. Otherwise, the default.value , or when this is omitted, the empty string is returned.",
    "category": "functions_xml"
  },
  "multi table overview": {
    "name": "Multi Table Overview",
    "type": "function",
    "syntax": "function Multi Table Overview()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "multitable"
  },
  "sec.add.set.by.name": {
    "name": "sec.add.set.by.name",
    "type": "function",
    "syntax": "function void sec.add.set.by.name (const string tablename())",
    "description": "Perform an add.set on a secondary table.",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename()",
        "description": "The name of the secondary table. This must be the name of a table for which sec.add.table() has been called and a valid id has been returned."
      }
    ],
    "returnValue": "",
    "category": "multitable"
  },
  "sec.add.set": {
    "name": "sec.add.set",
    "type": "function",
    "syntax": "function void sec.add.set (long id)",
    "description": "Perform an add.set on a secondary table.",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "The ID of the secondary table.This ID was obtained via a call to sec.add.table() ."
      }
    ],
    "returnValue": "",
    "category": "multitable"
  },
  "sec.add.table": {
    "name": "sec.add.table",
    "type": "function",
    "syntax": "function long sec.add.table (const string tablename(), ...)",
    "description": "Add the passed table as a secondary table to the current session. This function call is only allowed from the before.program section.",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename()",
        "description": "The table name to be added."
      },
      {
        "type": "",
        "name": "...",
        "description": "(optional) pairs of parameters of type string which defines the mapping of maintable fields on secondary table keyfields. First string of pair: maintable field Second string of pair: secondary table field"
      }
    ],
    "returnValue": "The id of the secondary table. This id must be used in subsequent calls to the functions sec.add.set() , sec.get.update.status() , sec.mark.delete() and sec.record.exists() .",
    "category": "multitable"
  },
  "sec.get.update.status.by.name": {
    "name": "sec.get.update.status.by.name",
    "type": "function",
    "syntax": "function long sec.get.update.status.by.name (const string tablename(), long occ)",
    "description": "Retrieve the update status of occurrence occ of a secondary table id .",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename()",
        "description": "The name of the secondary table. This must be the name of a table for which sec.add.table() has been called and a valid id has been returned."
      },
      {
        "type": "long",
        "name": "occ",
        "description": "The occurence number that must be checked. (Like actual.occ ). For single occurrence sessions this number will always be 1. For multi occurrence sessions it is a number between 1 and the number of rows."
      }
    ],
    "returnValue": "The result uses the same defines as the value of the update.status variable for the main table. 0 No update ADD.SET during add MODIFY.SET during modify MARK.DELETE during delete",
    "category": "multitable"
  },
  "sec.get.update.status": {
    "name": "sec.get.update.status",
    "type": "function",
    "syntax": "function long sec.get.update.status (long id, long occ)",
    "description": "Retrieve the update status of occurrence occ of secondary table id .",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "The ID of the secondary table. This ID was obtained via a call to sec.add.table() ."
      },
      {
        "type": "long",
        "name": "occ",
        "description": "The occurence number that must be checked. (Like actual.occ ). For single occurrence sessions this number will always be 1. For multi occurrence sessions it is a number between 1 and the number of rows."
      }
    ],
    "returnValue": "The result uses the same defines as the value of the update.status variable for the main table. 0 No update ADD.SET during add MODIFY.SET during modify MARK.DELETE during delete",
    "category": "multitable"
  },
  "sec.mark.delete.by.name": {
    "name": "sec.mark.delete.by.name",
    "type": "function",
    "syntax": "function void sec.mark.delete.by.name (const string tablename())",
    "description": "Perform an MARK.DELETE on a secondary table. The record will be deleted on the next save ( update.db ).",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename()",
        "description": "The name of the secondary table. This must be the name of a table for which sec.add.table() has been called and a valid id has been returned."
      }
    ],
    "returnValue": "",
    "category": "multitable"
  },
  "sec.mark.delete": {
    "name": "sec.mark.delete",
    "type": "function",
    "syntax": "function void sec.mark.delete (long id)",
    "description": "Perform an MARK.DELETE on a secondary table. The record will be deleted on the next save ( update.db ).",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "The ID of the secondary table. This ID was obtained via a call to sec.add.table() ."
      }
    ],
    "returnValue": "",
    "category": "multitable"
  },
  "sec.record.exists.by.name": {
    "name": "sec.record.exists.by.name",
    "type": "function",
    "syntax": "function boolean sec.record.exists.by.name (const string tablename(), long occ)",
    "description": "Check whether a secondary table record exists. When the record is saved but not yet committed, the function returns true .",
    "arguments": [
      {
        "type": "const string",
        "name": "tablename()",
        "description": "The name of the secondary table. This must be the name of a table for which sec.add.table() has been called and a valid id has been returned."
      },
      {
        "type": "long",
        "name": "occ",
        "description": "The occurence number that must be checked. (Like actual.occ ). For single occurrence sessions this number will always be 1. For multi occurrence sessions it is a number between 1 and the number of rows."
      }
    ],
    "returnValue": "A boolean telling whether or not a record exists.",
    "category": "multitable"
  },
  "sec.record.exists": {
    "name": "sec.record.exists",
    "type": "function",
    "syntax": "function boolean sec.record.exists (long id, long occ)",
    "description": "Check whether a secondary table record exists. When the record is saved but not yet committed, the function returns true .",
    "arguments": [
      {
        "type": "long",
        "name": "id",
        "description": "The ID of the secondary table. This ID was obtained via a call to sec.add.table() ."
      },
      {
        "type": "long",
        "name": "occ",
        "description": "The occurence number that must be checked. (Like actual.occ ). For single occurrence sessions this number will always be 1. For multi occurrence sessions it is a number between 1 and the number of rows."
      }
    ],
    "returnValue": "A boolean telling whether or not a record exists.",
    "category": "multitable"
  },
  "multi table synopsis": {
    "name": "Multi Table synopsis",
    "type": "function",
    "syntax": "function Multi Table synopsis()",
    "description": "",
    "arguments": [],
    "returnValue": "",
    "category": "multitable"
  }
}